

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Common design patterns &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Clean architecture" href="../10_clean_architecture/index.html" />
    <link rel="prev" title="Unit testing and refactoring" href="../8_unit_testing/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                24/02/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1_docstrings_and_annotations/index.html">Docstrings and annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_solid_principles/index.html">The SOLID principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_decorators/index.html">Using decorators to improve our code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_descriptors/index.html">Getting more out of our objects with descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7_generators/index.html">Using generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_unit_testing/index.html">Unit testing and refactoring</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Common design patterns</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#considerations-for-design-patterns-in-python">1. Considerations for design patterns in Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="#design-patterns-in-action">2. Design patterns in action</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creational-patterns">2.1. Creational patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#factories">2.1.1. Factories</a></li>
<li class="toctree-l4"><a class="reference internal" href="#singleton-and-shared-state-monostate">2.1.2. Singleton and shared state (monostate)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#builder">2.1.3. Builder</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#structural-patterns">2.2. Structural patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#adapter">2.2.1. Adapter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#composite">2.2.2. Composite</a></li>
<li class="toctree-l4"><a class="reference internal" href="#decorator">2.2.3. Decorator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#facade">2.2.4. Facade</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#behavioral-patterns">2.3. Behavioral patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#chain-of-responsibility">2.3.1. Chain of responsibility</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-template-method">2.3.2. The template method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#command">2.3.3. Command</a></li>
<li class="toctree-l4"><a class="reference internal" href="#state">2.3.4. State</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-null-object-pattern">3. The null object pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="#final-thoughts-about-design-patterns">4. Final thoughts about design patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10_clean_architecture/index.html">Clean architecture</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Common design patterns</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/chapters/9_design_patterns/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="../10_clean_architecture/index.html" class="btn btn-neutral float-right" title="Clean architecture" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../8_unit_testing/index.html" class="btn btn-neutral float-left" title="Unit testing and refactoring" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="common-design-patterns">
<h1>Common design patterns<a class="headerlink" href="#common-design-patterns" title="Permalink to this headline">¶</a></h1>
<p>Design patterns have been a widespread topic in software engineering since their original
inception in the famous <strong>Gang of Four (GoF) book</strong>, “Design Patterns: Elements of Reusable
Object-Oriented Software”. Design patterns help to solve common problems with abstractions
that work for certain scenarios. When they are implemented properly, the general design of
the solution can benefit from them.</p>
<p>In this chapter we take a look at some of the most common design patterns, but not from
the perspective of tools to apply under certain conditions (once the patterns have been
devised), but rather we analyze how design patterns contribute to clean code. After
presenting a solution that implements a design pattern, we analyze how the final
implementation is comparatively better as if we had chosen a different path.</p>
<p>As part of this analysis, we will see how to concretely implement design patterns in Python.
As a result of that, we will see that the dynamic nature of Python implies some differences
of implementation, with respect to other static typed languages, for which many of the
design patterns were originally thought of. This means that there are some particularities
about design patterns that you should bear in mind when it comes to Python, and, in some
cases, trying to apply a design pattern where it doesn’t really fit is non-Pythonic.</p>
<div class="section" id="considerations-for-design-patterns-in-python">
<h2>1. Considerations for design patterns in Python<a class="headerlink" href="#considerations-for-design-patterns-in-python" title="Permalink to this headline">¶</a></h2>
<p>Object-oriented design patterns are ideas of software construction that appear in different
scenarios when we deal with models of the problem we’re solving. Because they’re high-
level ideas, it’s hard to think of them as being tied to particular programming languages.
They are instead more general concepts about how objects will interact in the application.
Of course, they will have their implementation details, varying from language to language,
but that doesn’t form the essence of a design pattern.</p>
<p>That’s the theoretical aspect of a design pattern, the fact that it is an abstract idea that
expresses concepts about the layout of the objects in the solution. There are plenty of other
books and several other resources about object-oriented design, and design patterns in
particular, so in this book, we are going to focus on those implementation details for
Python.</p>
<p>Given the nature of Python, some of the classical design patterns aren’t actually needed.
That means that Python already supports features that render those patterns invisible.
Some argue that they don’t exist in Python, but keep in mind that invisible doesn’t mean
non-existing. They are there, just embedded in Python itself, so it’s likely that we won’t
even notice them.</p>
<p>Others have a much simpler implementation, again thanks to the dynamic nature of the
language, and the rest of them are practically the same as they are in other platforms, with
small differences.</p>
<p>In any case, the important goal for achieving clean code in Python is knowing what
patterns to implement and how. That means recognizing some of the patterns that Python
already abstracts and how we can leverage them. For instance, it would be completely non-
Pythonic to try to implement the standard definition of the iterator pattern (as we would do
in different languages), because (as we have already covered) iteration is deeply embedded
in Python, and the fact that we can create objects that will directly work in a for loop
makes this the right way to proceed.</p>
<p>Something similar happens with some of the creational patterns. Classes are regular objects
in Python, and so are functions. As we have seen in several examples so far, they can be
passed around, decorated, reassigned, and so on. That means that whatever kind of
customization we would like to make to our objects, we can most likely do it without
needing any particular setup of factory classes. In addition, there is no special syntax for
creating objects in Python (no new keyword, for example). This is another reason why,
most of the time, a simple function call will just work as a factory.</p>
<p>Other patterns are still needed, and we will see how, with some small adaptations, we can
make them more Pythonic, taking full advantage of the features that the language provides
(magic methods or the standard library).</p>
<p>Out of all the patterns available, not all of them are equally frequent, nor useful, so we will
focus on the main ones, those that we would expect to see the most in our applications, and
we will do so by following a pragmatic approach.</p>
</div>
<div class="section" id="design-patterns-in-action">
<h2>2. Design patterns in action<a class="headerlink" href="#design-patterns-in-action" title="Permalink to this headline">¶</a></h2>
<p>The canonical reference in this subject, as written by the GoF, introduces 23 design patterns,
each falling under one of the creational, structural, and behavioral categories. There are
even more patterns or variations of existing ones, but rather than learning all of these
patterns off by heart, we should focus on keeping two things in mind. Some of the patterns
are invisible in Python, and we use them probably without even noticing. Secondly, not all
patterns are equally common; some of them are tremendously useful, and so they are found
very frequently, while others are for more specific cases.</p>
<p>In this section, we will revisit the most common patterns, those that are most likely to
emerge from our design. Note the use of the word emerge here. It is important. We should
not force the application of a design pattern to the solution we are building, but rather
evolve, refactor, and improve our solution until a pattern emerges.</p>
<p>Design patterns are therefore not invented but discovered. When a situation that occurs
repeatedly in our code reveals itself, the general and more abstract layout of classes, objects,
and related components appears under a name by which we identify a pattern.</p>
<p>Thinking the same thing, but now backward, we realize that the name of a design pattern
wraps up a lot of concepts. This is probably the best thing about design patterns; they
provide a language. Through design patterns, it’s easier to communicate design ideas
effectively. When two or more software engineers share the same vocabulary, and one of
them mentions builder, the rest of them can immediately think about all the classes, and
how they would be related, what their mechanics would be, and so on, without having to
repeat this explanation all over again.</p>
<p>The reader will notice that the code shown in this chapter is different from the canonical or
original envisioning of the design pattern in question. There is more than one reason for
this. The first reason is that the examples take a more pragmatic approach, aimed at
solutions for particular scenarios rather than exploring general design theory. The second
reason is that the patterns are implemented with the particularities of Python, which in
some cases are very subtle, but in other cases, the differences are noticeable, generally
simplifying the code.</p>
<div class="section" id="creational-patterns">
<h3>2.1. Creational patterns<a class="headerlink" href="#creational-patterns" title="Permalink to this headline">¶</a></h3>
<p>In software engineering, creational patterns are those that deal with object instantiation,
trying to abstract away much of the complexity (like determining the parameters to
initialize an object, all the related objects that might be needed, etc.), in order to leave the
user with a simpler interface, that should be safer to use. The basic form of object creation
could result in design problems or added complexity to the design. Creational design
patterns solve this problem by somehow controlling this object creation.</p>
<p>Out of the five patterns for creating objects, we will discuss mainly the variants that are
used to avoid the singleton pattern, and replace it with the Borg pattern (most commonly
used in Python applications), discussing their differences and advantages.</p>
<div class="section" id="factories">
<h4>2.1.1. Factories<a class="headerlink" href="#factories" title="Permalink to this headline">¶</a></h4>
<p>As was mentioned in the introduction, one of the core features of Python is that everything
is an object, and as such, they can all be treated equally. This means that there are no special
distinctions of things that we can or cannot do with classes, functions, or custom objects.
They can all be passed by parameter, assigned, and so on.</p>
<p>It is for this reason that many of the factory patterns are not really needed. We could just
simply define a function that will construct a set of objects, and we can even pass the class
that we want to create by a parameter.</p>
</div>
<div class="section" id="singleton-and-shared-state-monostate">
<h4>2.1.2. Singleton and shared state (monostate)<a class="headerlink" href="#singleton-and-shared-state-monostate" title="Permalink to this headline">¶</a></h4>
<p>The singleton pattern, on the other hand, is something not entirely abstracted away by
Python. The truth is that most of the time, this pattern is either not really needed or is a bad
choice. There are a lot of problems with singletons (after all, they are, in fact, a form of
global variables for object-oriented software, and as such, are a bad practice). They are hard
to unit test, the fact that they might be modified at any time by any object makes them hard
to predict, and their side-effects can be really problematic.</p>
<p>As a general principle, we should avoid using singletons as much as possible. If in some
extreme case, they are required, the easiest way of achieving this in Python is by using a
module. We can create an object in a module, and once it’s there, it will be available from
every part of the module that is imported. Python itself makes sure that modules are
already singletons, in the sense that no matter how many times they’re imported, and from
how many places, the same module is always the one that is going to be loaded
into <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.</p>
<div class="section" id="shared-state">
<h5>2.1.2.1. Shared state<a class="headerlink" href="#shared-state" title="Permalink to this headline">¶</a></h5>
<p>Rather than forcing our design to have a singleton in which only one instance is created, no
matter how the object is invoked, constructed, or initialized, it is better to replicate the data
across multiple instances.</p>
<p>The idea of the monostate pattern is that we can have many instances that are
just regular objects, without having to care whether they’re singletons or not (seeing as
they’re just objects). The good thing about this pattern is that these objects will have their
information synchronized, in a completely transparent way, without us having to worry
about how this works internally.</p>
<p>This makes this pattern a much better choice, not only for its convenience, but also because
it is less error-prone, and suffers from fewer of the disadvantages of singletons (regarding
their testability, creating derived classes, and so on).</p>
<p>We can use this pattern on many levels, depending on how much information we need to
synchronize.</p>
<p>In its simplest form, we can assume that we only need to have one attribute to be reflected
across all instances. If that is the case, the implementation is as trivial as using a class
variable, and we just need to take care in providing a correct interface to update and
retrieve the value of the attribute.</p>
<p>Let’s say we have an object that has to pull a version of a code in a Git repository by the
latest tag . There might be multiple instances of this object, and when every client calls the
method for fetching the code, this object will use the tag version from its attribute. At any
point, this tag can be updated for a newer version, and we want any other instance (new or
already created) to use this new branch when the fetch operation is being called, as shown
in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GitFetcher</span><span class="p">:</span>
    <span class="n">_current_tag</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span> <span class="o">=</span> <span class="n">tag</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">current_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;tag was never set&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tag</span>

<span class="nd">@current_tag</span><span class="o">.</span><span class="n">setter</span>
<span class="k">def</span> <span class="nf">current_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_tag</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_current_tag</span> <span class="o">=</span> <span class="n">new_tag</span>

<span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span>
</pre></div>
</div>
<p>The reader can simply verify that creating multiple objects of the GitFetcher type with
different versions will result in all objects being set with the latest version at any time, as
shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">GitFetcher</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">GitFetcher</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">current_tag</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span><span class="o">.</span><span class="n">pull</span><span class="p">()</span>
<span class="go">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">pull</span><span class="p">()</span>
<span class="go">0.3</span>
</pre></div>
</div>
<p>In the case that we need more attributes, or that we wish to encapsulate the shared attribute
a bit more, to make the design cleaner, we can use a descriptor.</p>
<p>A descriptor, like the one shown in the following code, solves the problem, and while it’s
true that it requires more code, it also encapsulates a more concrete responsibility, and part
of the code is actually moved away from our original class, making either one of them more
cohesive and compliant with the single responsibility principle:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedAttribute</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">initial_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self._name}</span><span class="s2"> was never set&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>Apart from these considerations, it’s also true that the pattern is now more reusable. If we
want to repeat this logic, we just have to create a new descriptor object that would work
(complying with the DRY principle).</p>
<p>If we now want to do the same, but for the current branch, we create this new class
attribute, and the rest of the class is kept intact, while still having the desired logic in place,
as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GitFetcher</span><span class="p">:</span>
    <span class="n">current_tag</span> <span class="o">=</span> <span class="n">SharedAttribute</span><span class="p">()</span>
    <span class="n">current_branch</span> <span class="o">=</span> <span class="n">SharedAttribute</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">branch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">=</span> <span class="n">branch</span>

    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span>
</pre></div>
</div>
<p>The balance and trade-off of this new approach should be clear by now. This new
implementation uses a bit more code, but it’s reusable, so it saves lines of code (and
duplicated logic) in the long run. Once again, refer to the three or more instances rule to
decide if you should create such an abstraction.</p>
<p>Another important benefit of this solution is that it also reduces the repetition of unit tests.
Reusing code here will give us more confidence on the overall quality of the solution,
because now we just have to write unit tests for the descriptor object, not for all the classes
that use it (we can safely assume that they’re correct as long as the unit tests prove the
descriptor to be correct).</p>
</div>
<div class="section" id="the-borg-pattern">
<h5>2.1.2.2. The borg pattern<a class="headerlink" href="#the-borg-pattern" title="Permalink to this headline">¶</a></h5>
<p>The previous solutions should work for most cases, but if we really have to go for a
singleton (and this has to be a really good exception), then there is one last better
alternative to it, only this is a riskier one.</p>
<p>This is the actual monostate pattern, referred to as the borg pattern in Python. The idea is to
create an object that is capable of replicating all of its attributes among all instances of the
same class. The fact that absolutely every attribute is being replicated has to be a warning to
keep in mind undesired side-effects. Still, this pattern has many advantages over the
singleton.</p>
<p>In this case, we are going to split the previous object into two: one that works over Git
tags, and the other over branches. And we are using the code that will make the borg
pattern work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BaseFetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>

<span class="k">class</span> <span class="nc">TagFetcher</span><span class="p">(</span><span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from tag </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Tag = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>

<span class="k">class</span> <span class="nc">BranchFetcher</span><span class="p">(</span><span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from branch </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Branch = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>Both objects have a base class, sharing their initialization method. But then they have to
implement it again in order to make the borg logic work. The idea is that we use a class
attribute that is a dictionary to store the attributes, and then we make the dictionary of each
object (at the time it’s being initialized) to use this very same dictionary. This means that
any update on the dictionary of an object will be reflected in the class, which will be the
same for the rest of the objects because their class is the same, and dictionaries are mutable
objects that are passed as a reference. In other words, when we create new objects of this
type, they will all use the same dictionary, and this dictionary is constantly being updated.</p>
<p>Note that we cannot put the logic of the dictionary on the base class, because this will mix
the values among the objects of different classes, which is not what we want. This
boilerplate solution is what would make many think it’s actually an idiom rather than a
pattern.</p>
<p>A possible way of abstracting this in a way that achieves the DRY principle would be to
create a mixin class, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedAllMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BaseFetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>

<span class="k">class</span> <span class="nc">TagFetcher</span><span class="p">(</span><span class="n">SharedAllMixin</span><span class="p">,</span> <span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from tag </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Tag = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>

<span class="k">class</span> <span class="nc">BranchFetcher</span><span class="p">(</span><span class="n">SharedAllMixin</span><span class="p">,</span> <span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from branch </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Branch = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>This time, we are using the mixin class to create the dictionary with the attributes in each
class in case it doesn’t already exist, and then continuing with the same logic.</p>
<p>This implementation should not have any major problems with inheritance, so it’s a more
viable alternative.</p>
</div>
</div>
<div class="section" id="builder">
<h4>2.1.3. Builder<a class="headerlink" href="#builder" title="Permalink to this headline">¶</a></h4>
<p>The builder pattern is an interesting pattern that abstracts away all the complex
initialization of an object. This pattern does not rely on any particularity of the language, so
it’s as equally applicable in Python as it would be in any other language.</p>
<p>While it solves a valid case, it’s usually also a complicated case that is more likely to appear
in the design of a framework, library, or an API. Similar to the recommendations given for
descriptors, we should reserve this implementation for cases where we expect to expose an
API that is going to be consumed by multiple users.</p>
<p>The high level idea of this patter is that we need to create a complex object, that is an object
that also requires many others to work with. Rather than letting the user create all those
auxiliary objects, and then assign them to the main one, we would like to create an
abstraction that allows all of that to be done in a single step. In order to achieve this, we will
have a builder object that knows how to create all the parts and link them together, giving
the user an interface (which could be a class method), to parametrize all the information
about what the resulting object should look like.</p>
</div>
</div>
<div class="section" id="structural-patterns">
<h3>2.2. Structural patterns<a class="headerlink" href="#structural-patterns" title="Permalink to this headline">¶</a></h3>
<p>Structural patterns are useful for situations where we need to create simpler interfaces or
objects that are more powerful by extending their functionality without adding complexity
to their interfaces.</p>
<p>The best thing about these patterns is that we can create more interesting objects, with
enhanced functionality, and we can achieve this in a clean way; that is, by composing
multiple single objects (the clearest example of this being the composite pattern), or by
gathering many simple and cohesive interfaces.</p>
<div class="section" id="adapter">
<h4>2.2.1. Adapter<a class="headerlink" href="#adapter" title="Permalink to this headline">¶</a></h4>
<p>The adapter pattern is probably one of the simplest design patterns there are, and one of the
most useful ones at the same time. Also known as a wrapper, this pattern solves the
problem of adapting interfaces of two or more objects that are not compatible.</p>
<p>We typically encounter the situation where part of our code works with a model or set of
classes that were polymorphic with respect to a method. For example, if there were
multiple objects for retrieving data with a <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> method, then we want to maintain this
interface so we don’t have to make major changes to our code.</p>
<p>But then we come to a point where the need to add a new data source, and alas, this one
won’t have a <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> method. To make things worse, not only is this type of object not
compatible, but it is also not something we control (perhaps a different team decided on the
API, and we cannot modify the code).</p>
<p>Instead of using this object directly, we adopt its interface to the one we need. There are
two ways of doing this.</p>
<p>The first way would be to create a class that inherits from the one we want to use, and that
creates an alias for the method (if required, it will also have to adapt the parameters and the
signature).</p>
<p>By means of inheritance, we import the external class and create a new one that will define
the new method, calling the one that has a different name. In this example, let’s say the
external dependency has a method named <code class="docutils literal notranslate"><span class="pre">search()</span></code>, which takes only one parameter for
the search because it queries in a different fashion, so our <code class="docutils literal notranslate"><span class="pre">adapter</span></code> method not only calls
the external one, but it also translates the parameters accordingly, as shown in the
following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_adapter_base</span> <span class="kn">import</span> <span class="n">UsernameLookup</span>


<span class="k">class</span> <span class="nc">UserSource</span><span class="p">(</span><span class="n">UsernameLookup</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="n">user_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_arguments</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">user_namespace</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_adapt_arguments</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{user_id}</span><span class="s2">:</span><span class="si">{username}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>It might be the case that our class already derives from another one, in which case, this will
end up as a case of multiple inheritances, which Python supports, so it shouldn’t be a
problem. However, as we have seen many times before, inheritance comes with more
coupling (who knows how many other methods are being carried from the external
library?), and it’s inflexible. Conceptually, it also wouldn’t be the right choice because we
reserve inheritance for situations of specification (an is a kind of relationship), and in this
case, it’s not clear at all that our object has to be one of the kinds that are provided by a
third-party library (especially since we don’t fully comprehend that object).</p>
<p>Therefore, a better approach would be to use composition instead. Assuming that we can
provide our object with an instance of UsernameLookup, the code would be as simple as
just redirecting the petition prior to adopting the parameters, as shown in the following
code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UserSource</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="n">user_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_arguments</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">username_lookup</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">user_namespace</span><span class="p">)</span>
</pre></div>
</div>
<p>If we need to adopt multiple methods, and we can devise a generic way of adapting their
signature as well, it might be worth using the <code class="docutils literal notranslate"><span class="pre">__getattr__()</span></code> magic method to redirect
requests towards the wrapped object, but as always with generic implementations, we
should be careful of not adding more complexity to the solution.</p>
</div>
<div class="section" id="composite">
<h4>2.2.2. Composite<a class="headerlink" href="#composite" title="Permalink to this headline">¶</a></h4>
<p>There will be parts of our programs that require us to work with objects that are made out
of other objects. We have base objects that have a well-defined logic, and then we will have
other container objects that will group a bunch of base objects, and the challenge is that we
want to treat both of them (the base and the container objects) without noticing any
differences.</p>
<p>The objects are structured in a tree hierarchy, where the basic objects would be the leaves of
the tree, and the composed objects intermediate nodes. A client might want to call any of
them to get the result of a method that is called. The composite object, however, will act as a
client; this also will pass this request along with all the objects it contains whether they are
leaves or other intermediate notes until they all are processed.</p>
<p>Imagine a simplified version of an online store in which we have products. Say that we
offer the possibility of grouping those products, and we give customers a discount per
group of products. A product has a price, and this value will be asked for when the
customers come to pay. But a set of grouped products also has a price that has to be
computed. We will have an object that represents this group that contains the products, and
that delegates the responsibility of asking the price to each particular product (which might
be another group of products as well), and so on, until there is nothing else to compute. The
implementation of this is shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Product</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_price</span> <span class="o">=</span> <span class="n">price</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_price</span>

<span class="k">class</span> <span class="nc">ProductBundle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">,</span>
                 <span class="n">perc_discount</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">products</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Product</span><span class="p">,</span> <span class="s2">&quot;ProductBundle&quot;</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_perc_discount</span> <span class="o">=</span> <span class="n">perc_discount</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_products</span> <span class="o">=</span> <span class="n">products</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">price</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_products</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">total</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perc_discount</span><span class="p">)</span>
</pre></div>
</div>
<p>We expose the public interface through a property, and leave the price as a private
attribute. The <code class="docutils literal notranslate"><span class="pre">ProductBundle</span></code> class uses this property to compute the value with the
discount applied by first adding all the prices of all the products it contains.</p>
<p>The only discrepancy between these objects is that they are created with different
parameters. To be fully compatible, we should have tried to mimic the same interface and
then added extra methods for adding products to the bundle but using an interface that
allows the creation of complete objects. Not needing these extra steps is an advantage that
justifies this small difference.</p>
</div>
<div class="section" id="decorator">
<h4>2.2.3. Decorator<a class="headerlink" href="#decorator" title="Permalink to this headline">¶</a></h4>
<p>Don’t confuse the decorator pattern with the concept of a Python decorator. There is some
resemblance, but the idea of the design pattern is quite different.</p>
<p>This pattern allows us to dynamically extend the functionality of some objects, without
needing inheritance. It’s a good alternative to multiple inheritance in creating more flexible
objects.</p>
<p>We are going to create a structure that let’s a user define a set of operations (decorations) to
be applied over an object, and we’ll see how each step takes place in the specified order.</p>
<p>The following code example is a simplified version of an object that constructs a query in
the form of a dictionary from parameters that are passed to it (it might be an object that we
would use for running queries to elasticsearch, for instance, but the code leaves out
distracting implementation details to focus on the concepts of the pattern).</p>
<p>In its most basic form, the query just returns the dictionary with the data it was provided
when it was created. Clients expect to use the <code class="docutils literal notranslate"><span class="pre">render()</span></code> method of this object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DictQuery</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_query</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_query</span>
</pre></div>
</div>
<p>Now we want to render the query in different ways by applying transformations to the
data (filtering values, normalizing them, and so on). We could create decorators and apply
them to the render method, but that wouldn’t be flexible enough what if we want to
change them at runtime? Or if we want to select some of them, but not others?</p>
<p>The design is to create another object, with the same interface and the capability of
enhancing (decorating) the original result through many steps, but which can be combined.
These objects are chained, and each one of them does what it was originally supposed to
do, plus something else. This something else is the particular decoration step.</p>
<p>Since Python has duck typing, we don’t need to create a new base class and make these new
objects part of that hierarchy, along with <code class="docutils literal notranslate"><span class="pre">DictQuery</span></code>. Simply creating a new class that has
a <code class="docutils literal notranslate"><span class="pre">render()</span></code> method will be enough (again, polymorphism should not require inheritance).
This process is shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">QueryEnhancer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">DictQuery</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decorated</span> <span class="o">=</span> <span class="n">query</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorated</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">RemoveEmpty</span><span class="p">(</span><span class="n">QueryEnhancer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">original</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">original</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">CaseInsensitive</span><span class="p">(</span><span class="n">QueryEnhancer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">original</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">original</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">QueryEnhancer</span></code> phrase has an interface that is compatible with what the clients
of <code class="docutils literal notranslate"><span class="pre">DictQuery</span></code> are expecting, so they are interchangeable. This object is designed to receive
a decorated one. It’s going to take the values from this and convert them, returning the
modified version of the code.</p>
<p>If we want to remove all values that evaluate to <code class="docutils literal notranslate"><span class="pre">False</span></code> and normalize them to form our
original query, we would have to use the following schema:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">DictQuery</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">none</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="s2">&quot;UPPERCASE&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Title&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_query</span> <span class="o">=</span> <span class="n">CaseInsensitive</span><span class="p">(</span><span class="n">RemoveEmpty</span><span class="p">(</span><span class="n">original</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="go">{&#39;key&#39;: &#39;value&#39;, &#39;empty&#39;: &#39;&#39;, &#39;none&#39;: None, &#39;upper&#39;: &#39;UPPERCASE&#39;, &#39;title&#39;:</span>
<span class="go">&#39;Title&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_query</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="go">{&#39;key&#39;: &#39;value&#39;, &#39;upper&#39;: &#39;uppercase&#39;, &#39;title&#39;: &#39;title&#39;}</span>
</pre></div>
</div>
<p>This is a pattern that we can also implement in different ways, taking advantage of the
dynamic nature of Python, and the fact that functions are objects. We could implement this
pattern with functions that are provided to the base decorator object (<code class="docutils literal notranslate"><span class="pre">QueryEnhancer</span></code>),
and define each decoration step as a function, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">QueryEnhancer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">query</span><span class="p">:</span> <span class="n">DictQuery</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">decorators</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="n">decorators</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">deco</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span><span class="p">:</span>
            <span class="n">current_result</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">current_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_result</span>
</pre></div>
</div>
<p>With respect to the client, nothing has changed because this class maintains the
compatibility through its <code class="docutils literal notranslate"><span class="pre">render()</span></code> method. Internally, however, this object is used in a
slightly different fashion, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">query</span> <span class="o">=</span> <span class="n">DictQuery</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">none</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="s2">&quot;UPPERCASE&quot;</span><span class="p">,</span>
<span class="go">title=&quot;Title&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueryEnhancer</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">remove_empty</span><span class="p">,</span> <span class="n">case_insensitive</span><span class="p">)</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="go">{&#39;foo&#39;: &#39;bar&#39;, &#39;upper&#39;: &#39;uppercase&#39;, &#39;title&#39;: &#39;title&#39;}</span>
</pre></div>
</div>
<p>In the preceding code, <code class="docutils literal notranslate"><span class="pre">remove_empty</span></code> and <code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code> are just regular functions
that transform a dictionary.</p>
<p>In this example, the function-based approach seems easier to understand. There might be
cases with more complex rules that rely on data from the object being decorated (not only
its result), and in those cases, it might be worth going for the object-oriented approach,
especially if we really want to create a hierarchy of objects where each class actually
represents some knowledge we want to make explicit in our design.</p>
</div>
<div class="section" id="facade">
<h4>2.2.4. Facade<a class="headerlink" href="#facade" title="Permalink to this headline">¶</a></h4>
<p>Facade is an excellent pattern. It’s useful in many situations where we want to simplify the
interaction between objects. The pattern is applied where there is a relation of many-to-many
among several objects, and we want them to interact. Instead of creating all of these
connections, we place an intermediate object in front of many of them that act as a facade.</p>
<p>The facade works as a hub or a single point of reference in this layout. Every time a new
object wants to connect to another one, instead of having to have N interfaces for all N
possible objects it needs to connect to, it will instead just talk to the facade, and this will
redirect the request accordingly. Everything that’s behind the facade is completely opaque
to the rest of the external objects.</p>
<p>Apart from the main and obvious benefit (the decoupling of objects), this pattern also
encourages a simpler design with fewer interfaces and better encapsulation.</p>
<p>This is a pattern that we can use not only for improving the code of our domain problem
but also to create better APIs. If we use this pattern and provide a single interface, acting as
a single point of truth or entry point for our code, it will be much easier for our users to
interact with the functionality exposed. Not only that, but by exposing a functionality and
hiding everything behind an interface, we are free of changing or refactoring that
underlying code as many times as we want, because as long as it is behind the facade, it
will not break backward compatibility, and our users will not be affected.
Note how this idea of using facades is not even limited to objects and classes, but also
applies to packages (technically, packages are objects in Python, but still). We can use this
idea of the facade to decide the layout of a package; that is, what is visible to the user and
importable, and what is internal and should not be imported directly.
When we create a directory to build a package, we place the __init__.py file along with
the rest of the files. This is the root of the module, a sort of facade. The rest of the files
define the objects to export, but they shouldn’t be directly imported by clients. The init file
should import them and then clients should get them from there. This creates a better
interface because users only need to know a single entry point from which to get the
objects, and more importantly, the package (the rest of the files) can be refactored or
rearranged as many times as needed, and this will not affect clients as long as the main API
on the init file is maintained. It is of utmost importance to keep principles like this one in
mind in order to build maintainable software.
There is an example of this in Python itself, with the os module. This module groups an
operating system’s functionality, but underneath it, uses the posix module for Portable
Operating System Interface (POSIX) operating systems (this is called nt in Windows
platforms). The idea is that, for portability reasons, we shouldn’t ever really import
the posix module directly, but always the os module. It is up to this module to determine
from which platform it is being called, and expose the corresponding functionality.</p>
</div>
</div>
<div class="section" id="behavioral-patterns">
<h3>2.3. Behavioral patterns<a class="headerlink" href="#behavioral-patterns" title="Permalink to this headline">¶</a></h3>
<p>Behavioral patterns aim to solve the problem of how objects should cooperate, how they
should communicate, and what their interfaces should be at run-time.
We discuss mainly the following behavioral patterns:
Chain of responsibility
Template method
Command
State
[ 269 ]Common Design Patterns
Chapter 9
This can be accomplished statically by means of inheritance or dynamically by using
composition. Regardless of what the pattern uses, what we will see throughout the
following examples is that what these patterns have in common is the fact that the resulting
code is better in some significant way, whether this is because it avoids duplication or
creates good abstractions that encapsulate behavior accordingly and decouple our models.</p>
<div class="section" id="chain-of-responsibility">
<h4>2.3.1. Chain of responsibility<a class="headerlink" href="#chain-of-responsibility" title="Permalink to this headline">¶</a></h4>
<p>Now we are going to take another look at our event systems. We want to parse information
about the events that happened on the system from the log lines (text files, dumped from
our HTTP application server, for example), and we want to extract this information in a
convenient way.
In our previous implementation, we achieved an interesting solution that was compliant
with the open/closed principle and relied on the use of the __subclasses__() magic
method to discover all possible event types and process the data with the right event,
resolving the responsibility through a method encapsulated on each class.
This solution worked for our purposes, and it was quite extensible, but as we’ll see, this
design pattern will bring additional benefits.
The idea here is that we are going to create the events in a slightly different way. Each event
still has the logic to determine whether or not it can process a particular log line, but it will
also have a successor. This successor is a new event, the next one in the line, that will
continue processing the text line in case the first one was not able to do so. The logic is
simple—we chain the events, and each one of them tries to process the data. If it can, then it
just returns the result. If it can’t, it will pass it to its successor and repeat, as shown in the
following code:
import re
class Event:
pattern = None
def __init__(self, next_event=None):
self.successor = next_event
def process(self, logline: str):
if self.can_process(logline):
return self._process(logline)
if self.successor is not None:
return self.successor.process(logline)
[ 270 ]Common Design Patterns
Chapter 9
def _process(self, logline: str) -&gt; dict:
parsed_data = self._parse_data(logline)
return {
“type”: self.__class__.__name__,
“id”: parsed_data[“id”],
“value”: parsed_data[“value”],
}
&#64;classmethod
def can_process(cls, logline: str) -&gt; bool:
return cls.pattern.match(logline) is not None
&#64;classmethod
def _parse_data(cls, logline: str) -&gt; dict:
return cls.pattern.match(logline).groupdict()
class LoginEvent(Event):
pattern = re.compile(r”(?P&lt;id&gt;d+):s+logins+(?P&lt;value&gt;S+)”)
class LogoutEvent(Event):
pattern = re.compile(r”(?P&lt;id&gt;d+):s+logouts+(?P&lt;value&gt;S+)”)
With this implementation, we create the event objects, and arrange them in the particular
order in which they are going to be processed. Since they all have a process() method,
they are polymorphic for this message, so the order in which they are aligned is completely
transparent to the client, and either one of them would be transparent too. Not only that,
but the process() method has the same logic; it tries to extract the information if the data
provided is correct for the type of object handling it, and if not, it moves on to the next one
in the line.
This way, we could process a login event in the following way:
&gt;&gt;&gt; chain = LogoutEvent(LoginEvent())
&gt;&gt;&gt; chain.process(“567: login User”)
{‘type’: ‘LoginEvent’, ‘id’: ‘567’, ‘value’: ‘User’}
Note how LogoutEvent received LoginEvent as its successor, and when it was asked to
process something that it couldn’t handle, it redirected to the correct object. As we can see
from the type key on the dictionary, LoginEvent was the one that actually created that
dictionary.
This solution is flexible enough, and shares an interesting trait with our previous one—all
conditions are mutually exclusive. As long as there are no collisions, and no piece of data
has more than one handler, processing the events in any order will not be an issue.
[ 271 ]Common Design Patterns
Chapter 9
But what if we cannot make such an assumption? With the previous implementation, we
could still change the __subclasses__() call for a list that we made according to our
criteria, and that would have worked just fine. And what if we wanted that order of
precedence to be determined at runtime (by the user or client, for example)? That would be
a shortcoming.
With the new solution, it’s possible to accomplish such requirements, because we assemble
the chain at runtime, so we can manipulate it dynamically as we need to.
For example, now we add a generic type that groups both the login and logout a session
event, as shown in the following code:
class SessionEvent(Event):
pattern = re.compile(r”(?P&lt;id&gt;d+):s+log(in|out)s+(?P&lt;value&gt;S+)”)
If for some reason, and in some part of the application, we want to capture this before the
login event, this can be done by the following chain :
chain = SessionEvent(LoginEvent(LogoutEvent()))
By changing the order, we can, for instance, say that a generic session event has a higher
priority than the login, but not the logout, and so on.
The fact that this pattern works with objects makes it more flexible with respect to our
previous implementation, which relied on classes (and while they are still objects in Python,
they aren’t excluded from some degree of rigidity).</p>
</div>
<div class="section" id="the-template-method">
<h4>2.3.2. The template method<a class="headerlink" href="#the-template-method" title="Permalink to this headline">¶</a></h4>
<p>The template method is a pattern that yields important benefits when implemented
properly. Mainly, it allows us to reuse code, and it also makes our objects more flexible and
easy to change while preserving polymorphism.
The idea is that there is a class hierarchy that defines some behavior, let’s say an important
method of its public interface. All of the classes of the hierarchy share a common template
and might need to change only certain elements of it. The idea, then, is to place this generic
logic in the public method of the parent class that will internally call all other (private)
methods, and these methods are the ones that the derived classes are going to modify;
therefore, all the logic in the template is reused.
[ 272 ]Common Design Patterns
Chapter 9
Avid readers might have noticed that we already implemented this pattern in the previous
section (as part of the chain of responsibility example). Note that the classes derived
from Event implement only one thing their particular pattern. For the rest of the logic, the
template is in the Event class. The process event is generic, and relies on two auxiliary
methods can_process() and process() (which in turn calls _parse_data() ).
These extra methods rely on a class attribute pattern. Therefore, in order to extend this with
a new type of object, we just have to create a new derived class and place the regular
expression. After that, the rest of the logic will be inherited with this new attribute changed.
This reuses a lot of code because the logic for processing the log lines is defined once and
only once in the parent class.
This makes the design flexible because preserving the polymorphism is also easily
achievable. If we need a new event type that for some reason needs a different way of
parsing data, we only override this private method in that subclass, and the compatibility
will be kept, as long as it returns something of the same type as the original one (complying
with Liskov’s substitution and open/closed principles). This is because it is the parent class
that is calling the method from the derived classes.
This pattern is also useful if we are designing our own library or framework. By arranging
the logic this way, we give users the ability to change the behavior of one of the classes
quite easily. They would have to create a subclass and override the particular private
method, and the result will be a new object with the new behavior that is guaranteed to be
compatible with previous callers of the original object.</p>
</div>
<div class="section" id="command">
<h4>2.3.3. Command<a class="headerlink" href="#command" title="Permalink to this headline">¶</a></h4>
<p>The command pattern provides us with the ability to separate an action that needs to be
done from the moment that it is requested to its actual execution. More than that, it can also
separate the original request issued by a client from its recipient, which might be a different
object. In this section, we are going to focus mainly on the first aspect of the patterns; the
fact that we can separate how an order has to be run from when it actually executes.
We know we can create callable objects by implementing the __call__() magic method,
so we could just initialize the object and then call it later on. In fact, if this is the only
requirement, we might even achieve this through a nested function that, by means of a
closure, creates another function to achieve the effect of a delayed execution. But this
pattern can be extended to ends that aren’t so easily achievable.
[ 273 ]Common Design Patterns
Chapter 9
The idea is that the command might also be modified after its definition. This means that
the client specifies a command to run, and then some of its parameters might be changed,
more options added, and so on, until someone finally decides to perform the action.
Examples of this can be found in libraries that interact with databases. For instance,
in psycopg2 (a PostgreSQL client library), we establish a connection. From this, we get a
cursor, and to that cursor we can pass an SQL statement to run. When we call the execute
method, the internal representation of the object changes, but nothing is actually run in the
database. It is when we call fetchall() (or a similar method) that the data is actually
queried and is available in the cursor.
The same happens in the popular Object Relational Mapper SQLAlchemy
(ORM SQLAlchemy). A query is defined through several steps, and once we have the
query object, we can still interact with it (add or remove filters, change the conditions,
apply for an order, and so on), until we decide we want the results of the query. After
calling each method, the query object changes its internal properties and returns self
(itself).
These are examples that resemble the behavior that we would like to achieve. A very
simple way of creating this structure would be to have an object that stores the parameters
of the commands that are to be run. After that, it has to also provide methods for
interacting with those parameters (adding or removing filters, and so on). Optionally, we
can add tracing or logging capabilities to that object to audit the operations that have been
taking place. Finally, we need to provide a method that will actually perform the action.
This one can be just __call__() or a custom one. Let’s call it do() .</p>
</div>
<div class="section" id="state">
<h4>2.3.4. State<a class="headerlink" href="#state" title="Permalink to this headline">¶</a></h4>
<p>The state pattern is a clear example of reification in software design, making the concept of
our domain problem an explicit object rather than just a side value.
In Chapter 8 , Unit Testing and Refactoring, we had an object that represented a merge
request, and it had a state associated with it (open, closed, and so on). We used an enum to
represent those states because, at that point, they were just data holding a value the string
representation of that particular state. If they had to have some behavior, or the entire
merge request had to perform some actions depending on its state and transitions, this
would not have been enough.
[ 274 ]Common Design Patterns
Chapter 9
The fact that we are adding behavior, a runtime structure, to a part of the code has to make
us think in terms of objects, because that’s what objects are supposed to do, after all. And
here comes the reification—now the state cannot just simply be an enumeration with a
string; it needs to be an object.
Imagine that we have to add some rules to the merge request say, that when it moves from
open to closed, all approvals are removed (they will have to review the code again)—and
that when a merge request is just opened, the number of approvals is set to zero (regardless
of whether it’s a reopened or a brand new merge request). Another rule could be that when
a merge request is merged, we want to delete the source branch, and of course, we want to
forbid users from performing invalid transitions (for example, a closed merge request
cannot be merged, and so on).
If we were to put all that logic into a single place, namely in the MergeRequest class, we
will end up with a class that has lots of responsibilities (a poor design), probably many
methods, and a very large number of if statements. It would be hard to follow the code
and to understand which part is supposed to represent which business rule.
It’s better to distribute this into smaller objects, each one with fewer responsibilities, and the
state objects are a good place for this. We create an object for each kind of state we want to
represent, and, in their methods, we place the logic for the transitions with the
aforementioned rules. The MergeRequest object will then have a state collaborator, and
this, in turn, will also know about MergeRequest (the double-dispatching mechanism is
needed to run the appropriate actions on MergeRequest and handle the transitions).
We define a base abstract class with the set of methods to be implemented, and then a
subclass for each particular state we want to represent. Then the MergeRequest object
delegates all the actions to state , as shown in the following code:
class InvalidTransitionError(Exception):
“””Raised when trying to move to a target state from an unreachable
source
state.
“””
class MergeRequestState(abc.ABC):
def __init__(self, merge_request):
self._merge_request = merge_request
&#64;abc.abstractmethod
def open(self):
…
[ 275 ]Common Design Patterns
Chapter 9
&#64;abc.abstractmethod
def close(self):
…
&#64;abc.abstractmethod
def merge(self):
…
def __str__(self):
return self.__class__.__name__
class Open(MergeRequestState):
def open(self):
self._merge_request.approvals = 0
def close(self):
self._merge_request.approvals = 0
self._merge_request.state = Closed
def merge(self):
logger.info(“merging %s”, self._merge_request)
logger.info(“deleting branch %s”,
self._merge_request.source_branch)
self._merge_request.state = Merged
class Closed(MergeRequestState):
def open(self):
logger.info(“reopening closed merge request %s”,
self._merge_request)
self._merge_request.state = Open
def close(self):
pass
def merge(self):
raise InvalidTransitionError(“can’t merge a closed request”)
class Merged(MergeRequestState):
def open(self):
raise InvalidTransitionError(“already merged request”)
def close(self):
raise InvalidTransitionError(“already merged request”)
def merge(self):
[ 276 ]Common Design Patterns
Chapter 9
pass
class MergeRequest:
def __init__(self, source_branch: str, target_branch: str) -&gt; None:
self.source_branch = source_branch
self.target_branch = target_branch
self._state = None
self.approvals = 0
self.state = Open
&#64;property
def state(self):
return self._state
&#64;state.setter
def state(self, new_state_cls):
self._state = new_state_cls(self)
def open(self):
return self.state.open()
def close(self):
return self.state.close()
def merge(self):
return self.state.merge()
def __str__(self):
return f”{self.target_branch}:{self.source_branch}”
The following list outlines some clarifications about implementation details and the design
decisions that should be made:
The state is a property, so not only is it public, but there is a single place with the
definitions of how states are created for a merge request, passing self as a
parameter.
The abstract base class is not strictly needed, but there are benefits to having it.
First, it makes the kind of object we are dealing with more explicit. Second, it
forces every substate to implement all the methods of the interface. There are two
alternatives to this:
We could have not put the methods, and let AttributeError raise when
trying to perform an invalid action, but this is not correct, and it doesn’t
express what happened.
[ 277 ]Common Design Patterns
Chapter 9
Related to this point is the fact that we could have just used a simple base
class and left those methods empty, but then the default behavior of not
doing anything doesn’t make it any clearer what should happen. If one of
the methods in the subclass should do nothing (as in the case of merge),
then it’s better to let the empty method just sit there and make it explicit that
for that particular case, nothing should be done, as opposed to force that
logic to all objects.
MergeRequest and MergeRequestState have links to each other. The moment
a transition is made, the former object will not have extra references and should
be garbage-collected, so this relationship should be always 1:1. With some small
and more detailed considerations, a weak reference might be used.
The following code shows some examples of how the object is used:
&gt;&gt;&gt; mr = MergeRequest(“develop”, “master”)
&gt;&gt;&gt; mr.open()
&gt;&gt;&gt; mr.approvals
0
&gt;&gt;&gt; mr.approvals = 3
&gt;&gt;&gt; mr.close()
&gt;&gt;&gt; mr.approvals
0
&gt;&gt;&gt; mr.open()
<a class="reference external" href="INFO:log:reopening">INFO:log:reopening</a> closed merge request master:develop
&gt;&gt;&gt; mr.merge()
INFO:log:merging master:develop
INFO:log:deleting branch develop
&gt;&gt;&gt; mr.close()
Traceback (most recent call last):
…
InvalidTransitionError: already merged request
The actions for transitioning states are delegated to the state object, which MergeRequest
holds at all times (this can be any of the subclasses of ABC ). They all know how to respond
to the same messages (in different ways), so these objects will take the appropriate actions
corresponding to each transition (deleting branches, raising exceptions, and so on), and
will then move MergeRequest to the next state.
Since MergeRequest delegates all actions to its state object, we will find that this
typically happens every time the actions that it needs to do are in the form
self.state.open() , and so on. Can we remove some of that boilerplate?
[ 278 ]Common Design Patterns
Chapter 9
We could, by means of __getattr__() , as it is portrayed in the following code:
class MergeRequest:
def __init__(self, source_branch: str, target_branch: str) -&gt; None:
self.source_branch = source_branch
self.target_branch = target_branch
self._state: MergeRequestState
self.approvals = 0
self.state = Open
&#64;property
def state(self):
return self._state
&#64;state.setter
def state(self, new_state_cls):
self._state = new_state_cls(self)
&#64;property
def status(self):
return str(self.state)
def __getattr__(self, method):
return getattr(self.state, method)
def __str__(self):
return f”{self.target_branch}:{self.source_branch}”
On the one hand, it is good that we reuse some code and remove repetitive lines. This gives
the abstract base class even more sense. Somewhere, we want to have all possible actions
documented, listed in a single place. That place used to be the MergeRequest class, but
now those methods are gone, so the only remaining source of that truth is
in MergeRequestState . Luckily, the type annotation on the state attribute is really
helpful for users to know where to look for the interface definition.
A user can simply take a look and see that everything that MergeRequest doesn’t have will
be asked of its state attribute. From the init definition, the annotation will tell us that
this is an object of the MergeRequestState type, and by looking at this interface, we will
see that we can safely ask for the open() , close() , and merge() methods on it.</p>
</div>
</div>
</div>
<div class="section" id="the-null-object-pattern">
<h2>3. The null object pattern<a class="headerlink" href="#the-null-object-pattern" title="Permalink to this headline">¶</a></h2>
<p>The null object pattern is an idea that relates to the good practices that were mentioned in
previous chapters of this book. Here, we are formalizing them, and giving more context
and analysis to this idea.
The principle is rather simple—functions or methods must return objects of a consistent
type. If this is guaranteed, then clients of our code can use the objects that are returned with
polymorphism, without having to run extra checks on them.
In the previous examples, we explored how the dynamic nature of Python made things
easier for most design patterns. In some cases, they disappear entirely, and in others, they
are much easier to implement. The main goal of design patterns as they were originally
thought of is that methods or functions should not explicitly name the class of the object
that they need in order to work. For this reason, they propose the creation of interfaces and
a way of rearranging the objects to make them fit these interfaces in order to modify the
design. But most of the time, this is not needed in Python, and we can just pass different
objects, and as long as they respect the methods they must have, then the solution will
work.
On the other hand, the fact that objects don’t necessarily have to comply with an interface
requires us to be more careful as to the things that are returning from such methods and
functions. In the same way that our functions didn’t make any assumptions about what
they were receiving, it’s fair to assume that clients of our code will not make any
assumptions either (it is our responsibility to provide objects that are compatible). This can
be enforced or validated with design by contract. Here, we will explore a simple pattern
that will help us avoid these kinds of problems.
Consider the chain or responsibility design pattern explored in the previous section. We
saw how flexible it is and its many advantages, such as decoupling responsibilities into
smaller objects. One of the problems it has is that we never actually know what object will
end up processing the message, if any. In particular, in our example, if there was no
suitable object to process the log line, then the method would simply return None .
We don’t know how users will use the data we passed, but we do know that they are
expecting a dictionary. Therefore, the following error might occur:
AttributeError: ‘NoneType’ object has no attribute ‘keys’
In this case, the fix is rather simple—the default value of the process() method should be
an empty dictionary rather than None .
Ensure that you return objects of a consistent type.
[ 280 ]Common Design Patterns
Chapter 9
But what if the method didn’t return a dictionary, but a custom object of our domain?
To solve this problem, we should have a class that represents the empty state for that object
and return it. If we have a class that represents users in our system, and a function that
queries users by their ID, then in the case that a user is not found, it should do one of the
following two things:
Raise an exception
Return an object of the UserUnknown type
But in no case should it return None . The phrase None doesn’t represent what just
happened, and the caller might legitimately try to ask methods to it, and it will fail with
AttributeError .
We have discussed exceptions and their pros and cons earlier on, so we should mention
that this null object should just have the same methods as the original user and do nothing
for each one of them.
The advantage of using this structure is that not only are we avoiding an error at runtime
but also that this object might be useful. It could make the code easier to test, and it can
even, for instance, help in debugging (maybe we could put logging into the methods to
understand why that state was reached, what data was provided to it, and so on).
By exploiting almost all of the magic methods of Python, it would be possible to create a
generic null object that does absolutely nothing, no matter how it is called, but which can
be called from almost any client. Such an object would slightly resemble a Mock object. It is
not advisable to go down that path because of the following reasons:
It loses meaning with the domain problem. Back in our example, having an object
of the UnknownUser type makes sense, and gives the caller a clear idea that
something went wrong with the query.
It doesn’t respect the original interface. This is problematic. Remember that the
point is that an UnknownUser is a user, and therefore it must have the same
methods. If the caller accidentally asks for a method that is not there, then, in that
case, it should raise an AttributeError exception, and that would be good.
With the generic null object that can do anything and respond to anything, we
would be losing this information, and bugs might creep in. If we opt for creating
a Mock object with spec=User , then this anomaly would be caught, but again,
using a Mock object to represent what is actually an empty state harms
the intention revealing the degree of the code.
This pattern is a good practice that allows us to maintain polymorphism in our objects.</p>
</div>
<div class="section" id="final-thoughts-about-design-patterns">
<h2>4. Final thoughts about design patterns<a class="headerlink" href="#final-thoughts-about-design-patterns" title="Permalink to this headline">¶</a></h2>
<p>We have seen the world of design patterns in Python, and in doing so, we have found
solutions to common problems, as well as more techniques that will help us achieve a clean
design.
All of this sounds good, but it begs the question, how good are design patterns? Some
people argue that they do more harm than good, that they were created for languages
whose limited type system (and lack of first-class functions) makes it impossible to
accomplish things we would normally do in Python. Others claim that design patterns
force a design solution, creating some bias that limits a design that would have otherwise
emerged, and which would have been better. Let’s look at each of these points in turn.
The influence of patterns over the design
A design patterns, as with any other topic in software engineering, cannot be good or bad
in and of itself, but rather in how it’s implemented. In some cases, there is actually no need
for a design pattern, and a simpler solution would do. Trying to force a pattern where it
doesn’t fit is a case of over-engineering, and that’s clearly bad, but it doesn’t mean that there
is a problem with the design patterns, and most likely in these scenarios, the problem is not
even related to patterns at all. Some people try to over-engineer everything because they
don’t understand what flexible and adaptable software really means. As we mentioned
before in this book, making good software is not about anticipating future requirements
(there is no point in doing futurology), but just solving the problem that we have at
hand right now, in a way that doesn’t prevent us from making changes to it in the future. It
doesn’t have to handle those changes now; it just needs to be flexible enough so that it can
be modified in the future. And when that future comes, we will still have to remember the
rule of three or more instances of the same problem before coming up with a generic
solution or a proper abstraction.
This is typically the point where the design patterns should emerge, once we have
identified the problem correctly and are able to recognize the pattern and abstract
accordingly.
[ 282 ]Common Design Patterns
Chapter 9
Let’s come back to the topic of the suitability of the patterns to the language. As we said in
the introduction of the chapter, design patterns are high-level ideas. They typically refer to
the relation of objects and their interactions. It’s hard to think that such things might
disappear from one language to another. It’s true that some patterns are actually
implemented manually in Python, as is the case of the iterator pattern (which, as it was
heavily discussed earlier in the book, is built in Python), or a strategy (because, instead, we
would just pass functions as any other regular object; we don’t need to encapsulate the
strategy method into an object the function itself would be an object).
But other patterns are actually needed, and they indeed solve problems, as in the case of the
decorator and composite patterns. In other cases, there are design patterns that Python
itself implements, and we just don’t always see them, as in the case of the facade pattern
that we discussed in the section on os .
As to our design patterns leading our solution in a wrong direction, we have to be careful
here. Once again, it’s better if we start designing our solution by thinking in terms of the
domain problem and creating the right abstractions, and then later see whether there is a
design pattern that emerges from that design. Let’s say that it does. Is that a bad thing? The
fact that there is already a solution to the problem we’re trying to solve cannot be a bad
thing. It would be bad to reinvent the wheel, as happens many times in our field. Moreover,
the fact that we are applying a pattern, something already proven and validated, should
give us greater confidence in the quality of what we are building.
Names in our models
Should we mention that we are using a design pattern in our code?
If the design is good and the code is clean, it should speak for itself. It is not recommended
that you name things after the design patterns you are using for a couple of reasons:
Users of our code and other developers don’t need to know the design pattern
behind the code, as long as it works as intended.
Stating the design pattern ruins the intention revealing principle. Adding the
name of the design pattern to a class makes it lose part of its original meaning. If
a class represents a query, it should be named Query or EnhancedQuery ,
something that reveals the intention of what that object is supposed to
do. EnhancedQueryDecorator doesn’t mean anything meaningful, and the
Decorator suffix creates more confusion than clarity.
[ 283 ]Common Design Patterns
Chapter 9
Mentioning the design patterns in docstrings might be acceptable because they work as
documentation, and expressing the design ideas (again, communicating) in our design is a
good thing. However, this should not be needed. Most of the time, though, we do not need
to know that a design pattern is there.
The best designs are those in which design patterns are completely transparent to the users.
An example of this is how the facade pattern appears in the standard library, making it
completely transparent to users as to how to access the os module. An even more elegant
example is how the iterator design pattern is so completely abstracted by the language that
we don’t even have to think about it.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../10_clean_architecture/index.html" class="btn btn-neutral float-right" title="Clean architecture" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../8_unit_testing/index.html" class="btn btn-neutral float-left" title="Unit testing and refactoring" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>