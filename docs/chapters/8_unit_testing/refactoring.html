

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3. Refactoring &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                21/02/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../1_docstrings_and_annotations/index.html">Docstrings and annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_solid_principles/index.html">The SOLID principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_decorators/index.html">Using decorators to improve our code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_descriptors/index.html">Getting more out of our objects with descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7_generators/index.html">Using generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Unit testing and refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../9_design_patterns/index.html">Common design patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_clean_architecture/index.html">Clean architecture</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>3. Refactoring</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/chapters/8_unit_testing/refactoring.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="refactoring">
<h1>3. Refactoring<a class="headerlink" href="#refactoring" title="Permalink to this headline">¶</a></h1>
<p>Refactoring is a critical activity in software maintenance, yet something that can’t be done
(at least correctly) without having unit tests. Every now and then, we need to support a
new feature or use our software in unintended ways. We need to realize that the only way
to accommodate such requirements is by first refactoring our code, make it more generic.
Only then can we move forward.
[ 243 ]Unit Testing and Refactoring
Chapter 8
Typically, when refactoring our code, we want to improve its structure and make it better,
sometimes more generic, more readable, or more flexible. The challenge is to achieve these
goals while at the same time preserving the exact same functionality it had prior to the
modifications that were made. This means that, in the eyes of the clients of those
components we’re refactoring, it might as well be the case that nothing had happened at all.
This constraint of having to support the same functionalities as before but with a different
version of the code implies that we need to run regression tests on code that was modified.
The only cost-effective way of running regression tests is if those tests are automatic. The
most cost-effective version of automatic tests is unit tests.
Evolving our code
In the previous example, we were able to separate out the side-effects from our code to
make it testable by patching those parts of the code that depended on things we couldn’t
control on the unit test. This is a good approach since, after all, the mock.patch function
comes in handy for these sorts of task and replaces the objects we tell it to, giving us back a
Mock object.
The downside of that is that we have to provide the path of the object we are going to
mock, including the module, as a string. This is a bit fragile, because if we refactor our code
(let’s say we rename the file or move it to some other location), all the places with the patch
will have to be updated, or the test will break.
In the example, the fact that the notify() method directly depends on an implementation
detail (the requests module) is a design issue, that is, it is taking its toll on the unit tests as
well with the aforementioned fragility that is implied.
We still need to replace those methods with doubles (mocks), but if we refactor the code,
we can do it in a better way. Let’s separate these methods into smaller ones, and most
importantly inject the dependency rather than keep it fixed. The code now applies
the dependency inversion principle, and it expects to work with something that supports
an interface (in this example, implicit one) such as the one the requests module provides:
from datetime import datetime
from constants import STATUS_ENDPOINT
class BuildStatus:
endpoint = STATUS_ENDPOINT
[ 244 ]Unit Testing and Refactoring
Chapter 8
def __init__(self, transport):
self.transport = transport
&#64;staticmethod
def build_date() -&gt; str:
return datetime.utcnow().isoformat()
def compose_payload(self, merge_request_id, status) -&gt; dict:
return {
“id”: merge_request_id,
“status”: status,
“built_at”: self.build_date(),
}
def deliver(self, payload):
response = self.transport.post(self.endpoint, json=payload)
response.raise_for_status()
return response
def notify(self, merge_request_id, status):
return self.deliver(self.compose_payload(merge_request_id, status))
We separate the methods (not notify is now compose + deliver),
make compose_payload() a new method (so that we can replace, without the need to
patch the class), and require the transport dependency to be injected. Now that
transport is a dependency, it is much easier to change that object for any double we want.
It is even possible to expose a fixture of this object with the doubles replaced as required:
&#64;pytest.fixture
def build_status():
bstatus = BuildStatus(Mock())
bstatus.build_date = Mock(return_value=”2018-01-01T00:00:01”)
return bstatus
def test_build_notification_sent(build_status):
build_status.notify(1234, “OK”)
expected_payload = {
“id”: 1234,
“status”: “OK”,
“built_at”: build_status.build_date(),
}
[ 245 ]Unit Testing and Refactoring
Chapter 8
build_status.transport.post.assert_called_with(
build_status.endpoint, json=expected_payload
)
Production code isn’t the only thing that evolves
We keep saying that unit tests are as important as production code. And if we are careful
enough with production code as to create the best possible abstraction, why wouldn’t we
do the same for unit tests?
If the code for unit tests is as important as the main code, then it’s definitely wise to design
it with extensibility in mind and make it as maintainable as possible. After all, this is the
code that will have to be maintained by an engineer other than its original author, so it has
to be readable.
The reason why we pay so much attention to make the code’s flexibility is that we know
requirements change and evolve over time, and eventually as domain business rules
change, our code will have to change as well to support these new requirements. Since the
production code changed to support new requirements, in turn, the testing code will have
to change as well to support the newer version of the production code.
In one of the first examples we used, we created a series of tests for the merge request
object, trying different combinations and checking the status at which the merge request
was left. This is a good first approach, but we can do better than that.
Once we understand the problem better, we can start creating better abstractions. With this,
the first idea that comes to mind is that we can create a higher-level abstraction that checks
for particular conditions. For example, if we have an object that is a test suite that
specifically targets the MergeRequest class, we know its functionality will be limited to the
behavior of this class (because it should comply to the SRP), and therefore we could create
specific testing methods on this testing class. These will only make sense for this class, but
that will be helpful in reducing a lot of boilerplate code.
[ 246 ]Unit Testing and Refactoring
Chapter 8
Instead of repeating assertions that follow the exact same structure, we can create a method
that encapsulates this and reuse it across all of the tests:
class TestMergeRequestStatus(unittest.TestCase):
def setUp(self):
self.merge_request = MergeRequest()
def assert_rejected(self):
self.assertEqual(
self.merge_request.status, MergeRequestStatus.REJECTED
)
def assert_pending(self):
self.assertEqual(
self.merge_request.status, MergeRequestStatus.PENDING
)
def assert_approved(self):
self.assertEqual(
self.merge_request.status, MergeRequestStatus.APPROVED
)
def test_simple_rejected(self):
self.merge_request.downvote(“maintainer”)
self.assert_rejected()
def test_just_created_is_pending(self):
self.assert_pending()
If something changes with how we check the status of a merge request (or let’s say we want
to add extra checks), there is only one place (the assert_approved() method) that will
have to be modified. More importantly, by creating these higher-level abstractions, the code
that started as merely unit tests starts to evolve into what could end up being a testing
framework with its own API or domain language, making testing more declarative.</p>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>