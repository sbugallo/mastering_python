

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2. Design patterns in action &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                03/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../how_python_works/index.html">How does Python work?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development_environments/index.html">Modern Python Development Environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solid_principles/index.html">SOLID</a></li>
<li class="toctree-l1"><a class="reference internal" href="../decorators/index.html">Decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../descriptors/index.html">Descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generators/index.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/index.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../naming/index.html">Naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unit_testing/index.html">Unit testing and refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Design patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../clean_architecture/index.html">Clean architecture</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>2. Design patterns in action</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/chapters/design_patterns/design_patterns.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="design-patterns-in-action">
<h1>2. Design patterns in action<a class="headerlink" href="#design-patterns-in-action" title="Permalink to this headline">¶</a></h1>
<p>The canonical reference in this subject, as written by the GoF, introduces 23 design patterns,
each falling under one of the creational, structural, and behavioral categories. There are
even more patterns or variations of existing ones, but rather than learning all of these
patterns off by heart, we should focus on keeping two things in mind. Some of the patterns
are invisible in Python, and we use them probably without even noticing. Secondly, not all
patterns are equally common; some of them are tremendously useful, and so they are found
very frequently, while others are for more specific cases.</p>
<p>In this section, we will revisit the most common patterns, those that are most likely to
emerge from our design. Note the use of the word emerge here. It is important. We should
not force the application of a design pattern to the solution we are building, but rather
evolve, refactor, and improve our solution until a pattern emerges.</p>
<p>Design patterns are therefore not invented but discovered. When a situation that occurs
repeatedly in our code reveals itself, the general and more abstract layout of classes, objects,
and related components appears under a name by which we identify a pattern.</p>
<p>Thinking the same thing, but now backward, we realize that the name of a design pattern
wraps up a lot of concepts. This is probably the best thing about design patterns; they
provide a language. Through design patterns, it’s easier to communicate design ideas
effectively. When two or more software engineers share the same vocabulary, and one of
them mentions builder, the rest of them can immediately think about all the classes, and
how they would be related, what their mechanics would be, and so on, without having to
repeat this explanation all over again.</p>
<p>The reader will notice that the code shown in this chapter is different from the canonical or
original envisioning of the design pattern in question. There is more than one reason for
this. The first reason is that the examples take a more pragmatic approach, aimed at
solutions for particular scenarios rather than exploring general design theory. The second
reason is that the patterns are implemented with the particularities of Python, which in
some cases are very subtle, but in other cases, the differences are noticeable, generally
simplifying the code.</p>
<div class="section" id="creational-patterns">
<h2>2.1. Creational patterns<a class="headerlink" href="#creational-patterns" title="Permalink to this headline">¶</a></h2>
<p>In software engineering, creational patterns are those that deal with object instantiation,
trying to abstract away much of the complexity (like determining the parameters to
initialize an object, all the related objects that might be needed, etc.), in order to leave the
user with a simpler interface, that should be safer to use. The basic form of object creation
could result in design problems or added complexity to the design. Creational design
patterns solve this problem by somehow controlling this object creation.</p>
<p>Out of the five patterns for creating objects, we will discuss mainly the variants that are
used to avoid the singleton pattern, and replace it with the Borg pattern (most commonly
used in Python applications), discussing their differences and advantages.</p>
<div class="section" id="factories">
<h3>2.1.1. Factories<a class="headerlink" href="#factories" title="Permalink to this headline">¶</a></h3>
<p>As was mentioned in the introduction, one of the core features of Python is that everything
is an object, and as such, they can all be treated equally. This means that there are no special
distinctions of things that we can or cannot do with classes, functions, or custom objects.
They can all be passed by parameter, assigned, and so on.</p>
<p>It is for this reason that many of the factory patterns are not really needed. We could just
simply define a function that will construct a set of objects, and we can even pass the class
that we want to create by a parameter.</p>
</div>
<div class="section" id="singleton-and-shared-state-monostate">
<h3>2.1.2. Singleton and shared state (monostate)<a class="headerlink" href="#singleton-and-shared-state-monostate" title="Permalink to this headline">¶</a></h3>
<p>The singleton pattern, on the other hand, is something not entirely abstracted away by
Python. The truth is that most of the time, this pattern is either not really needed or is a bad
choice. There are a lot of problems with singletons (after all, they are, in fact, a form of
global variables for object-oriented software, and as such, are a bad practice). They are hard
to unit test, the fact that they might be modified at any time by any object makes them hard
to predict, and their side-effects can be really problematic.</p>
<p>As a general principle, we should avoid using singletons as much as possible. If in some
extreme case, they are required, the easiest way of achieving this in Python is by using a
module. We can create an object in a module, and once it’s there, it will be available from
every part of the module that is imported. Python itself makes sure that modules are
already singletons, in the sense that no matter how many times they’re imported, and from
how many places, the same module is always the one that is going to be loaded
into <code class="docutils literal notranslate"><span class="pre">sys.modules</span></code>.</p>
<div class="section" id="shared-state">
<h4>2.1.2.1. Shared state<a class="headerlink" href="#shared-state" title="Permalink to this headline">¶</a></h4>
<p>Rather than forcing our design to have a singleton in which only one instance is created, no
matter how the object is invoked, constructed, or initialized, it is better to replicate the data
across multiple instances.</p>
<p>The idea of the monostate pattern is that we can have many instances that are
just regular objects, without having to care whether they’re singletons or not (seeing as
they’re just objects). The good thing about this pattern is that these objects will have their
information synchronized, in a completely transparent way, without us having to worry
about how this works internally.</p>
<p>This makes this pattern a much better choice, not only for its convenience, but also because
it is less error-prone, and suffers from fewer of the disadvantages of singletons (regarding
their testability, creating derived classes, and so on).</p>
<p>We can use this pattern on many levels, depending on how much information we need to
synchronize.</p>
<p>In its simplest form, we can assume that we only need to have one attribute to be reflected
across all instances. If that is the case, the implementation is as trivial as using a class
variable, and we just need to take care in providing a correct interface to update and
retrieve the value of the attribute.</p>
<p>Let’s say we have an object that has to pull a version of a code in a Git repository by the
latest tag . There might be multiple instances of this object, and when every client calls the
method for fetching the code, this object will use the tag version from its attribute. At any
point, this tag can be updated for a newer version, and we want any other instance (new or
already created) to use this new branch when the fetch operation is being called, as shown
in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GitFetcher</span><span class="p">:</span>
    <span class="n">_current_tag</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span> <span class="o">=</span> <span class="n">tag</span>

<span class="nd">@property</span>
<span class="k">def</span> <span class="nf">current_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;tag was never set&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_tag</span>

<span class="nd">@current_tag</span><span class="o">.</span><span class="n">setter</span>
<span class="k">def</span> <span class="nf">current_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_tag</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_current_tag</span> <span class="o">=</span> <span class="n">new_tag</span>

<span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span>
</pre></div>
</div>
<p>The reader can simply verify that creating multiple objects of the GitFetcher type with
different versions will result in all objects being set with the latest version at any time, as
shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">GitFetcher</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">GitFetcher</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">current_tag</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span><span class="o">.</span><span class="n">pull</span><span class="p">()</span>
<span class="go">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">pull</span><span class="p">()</span>
<span class="go">0.3</span>
</pre></div>
</div>
<p>In the case that we need more attributes, or that we wish to encapsulate the shared attribute
a bit more, to make the design cleaner, we can use a descriptor.</p>
<p>A descriptor, like the one shown in the following code, solves the problem, and while it’s
true that it requires more code, it also encapsulates a more concrete responsibility, and part
of the code is actually moved away from our original class, making either one of them more
cohesive and compliant with the single responsibility principle:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedAttribute</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">initial_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self._name}</span><span class="s2"> was never set&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
</pre></div>
</div>
<p>Apart from these considerations, it’s also true that the pattern is now more reusable. If we
want to repeat this logic, we just have to create a new descriptor object that would work
(complying with the DRY principle).</p>
<p>If we now want to do the same, but for the current branch, we create this new class
attribute, and the rest of the class is kept intact, while still having the desired logic in place,
as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">GitFetcher</span><span class="p">:</span>
    <span class="n">current_tag</span> <span class="o">=</span> <span class="n">SharedAttribute</span><span class="p">()</span>
    <span class="n">current_branch</span> <span class="o">=</span> <span class="n">SharedAttribute</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">branch</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_branch</span> <span class="o">=</span> <span class="n">branch</span>

    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tag</span>
</pre></div>
</div>
<p>The balance and trade-off of this new approach should be clear by now. This new
implementation uses a bit more code, but it’s reusable, so it saves lines of code (and
duplicated logic) in the long run. Once again, refer to the three or more instances rule to
decide if you should create such an abstraction.</p>
<p>Another important benefit of this solution is that it also reduces the repetition of unit tests.
Reusing code here will give us more confidence on the overall quality of the solution,
because now we just have to write unit tests for the descriptor object, not for all the classes
that use it (we can safely assume that they’re correct as long as the unit tests prove the
descriptor to be correct).</p>
</div>
<div class="section" id="the-borg-pattern">
<h4>2.1.2.2. The borg pattern<a class="headerlink" href="#the-borg-pattern" title="Permalink to this headline">¶</a></h4>
<p>The previous solutions should work for most cases, but if we really have to go for a
singleton (and this has to be a really good exception), then there is one last better
alternative to it, only this is a riskier one.</p>
<p>This is the actual monostate pattern, referred to as the borg pattern in Python. The idea is to
create an object that is capable of replicating all of its attributes among all instances of the
same class. The fact that absolutely every attribute is being replicated has to be a warning to
keep in mind undesired side-effects. Still, this pattern has many advantages over the
singleton.</p>
<p>In this case, we are going to split the previous object into two: one that works over Git
tags, and the other over branches. And we are using the code that will make the borg
pattern work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BaseFetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>

<span class="k">class</span> <span class="nc">TagFetcher</span><span class="p">(</span><span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from tag </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Tag = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>

<span class="k">class</span> <span class="nc">BranchFetcher</span><span class="p">(</span><span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from branch </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Branch = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>Both objects have a base class, sharing their initialization method. But then they have to
implement it again in order to make the borg logic work. The idea is that we use a class
attribute that is a dictionary to store the attributes, and then we make the dictionary of each
object (at the time it’s being initialized) to use this very same dictionary. This means that
any update on the dictionary of an object will be reflected in the class, which will be the
same for the rest of the objects because their class is the same, and dictionaries are mutable
objects that are passed as a reference. In other words, when we create new objects of this
type, they will all use the same dictionary, and this dictionary is constantly being updated.</p>
<p>Note that we cannot put the logic of the dictionary on the base class, because this will mix
the values among the objects of different classes, which is not what we want. This
boilerplate solution is what would make many think it’s actually an idiom rather than a
pattern.</p>
<p>A possible way of abstracting this in a way that achieves the DRY principle would be to
create a mixin class, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SharedAllMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BaseFetcher</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>

<span class="k">class</span> <span class="nc">TagFetcher</span><span class="p">(</span><span class="n">SharedAllMixin</span><span class="p">,</span> <span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from tag </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Tag = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>

<span class="k">class</span> <span class="nc">BranchFetcher</span><span class="p">(</span><span class="n">SharedAllMixin</span><span class="p">,</span> <span class="n">BaseFetcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">pull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;pulling from branch </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Branch = </span><span class="si">{self.source}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>This time, we are using the mixin class to create the dictionary with the attributes in each
class in case it doesn’t already exist, and then continuing with the same logic.</p>
<p>This implementation should not have any major problems with inheritance, so it’s a more
viable alternative.</p>
</div>
</div>
<div class="section" id="builder">
<h3>2.1.3. Builder<a class="headerlink" href="#builder" title="Permalink to this headline">¶</a></h3>
<p>The builder pattern is an interesting pattern that abstracts away all the complex
initialization of an object. This pattern does not rely on any particularity of the language, so
it’s as equally applicable in Python as it would be in any other language.</p>
<p>While it solves a valid case, it’s usually also a complicated case that is more likely to appear
in the design of a framework, library, or an API. Similar to the recommendations given for
descriptors, we should reserve this implementation for cases where we expect to expose an
API that is going to be consumed by multiple users.</p>
<p>The high level idea of this patter is that we need to create a complex object, that is an object
that also requires many others to work with. Rather than letting the user create all those
auxiliary objects, and then assign them to the main one, we would like to create an
abstraction that allows all of that to be done in a single step. In order to achieve this, we will
have a builder object that knows how to create all the parts and link them together, giving
the user an interface (which could be a class method), to parametrize all the information
about what the resulting object should look like.</p>
</div>
</div>
<div class="section" id="structural-patterns">
<h2>2.2. Structural patterns<a class="headerlink" href="#structural-patterns" title="Permalink to this headline">¶</a></h2>
<p>Structural patterns are useful for situations where we need to create simpler interfaces or
objects that are more powerful by extending their functionality without adding complexity
to their interfaces.</p>
<p>The best thing about these patterns is that we can create more interesting objects, with
enhanced functionality, and we can achieve this in a clean way; that is, by composing
multiple single objects (the clearest example of this being the composite pattern), or by
gathering many simple and cohesive interfaces.</p>
<div class="section" id="adapter">
<h3>2.2.1. Adapter<a class="headerlink" href="#adapter" title="Permalink to this headline">¶</a></h3>
<p>The adapter pattern is probably one of the simplest design patterns there are, and one of the
most useful ones at the same time. Also known as a wrapper, this pattern solves the
problem of adapting interfaces of two or more objects that are not compatible.</p>
<p>We typically encounter the situation where part of our code works with a model or set of
classes that were polymorphic with respect to a method. For example, if there were
multiple objects for retrieving data with a <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> method, then we want to maintain this
interface so we don’t have to make major changes to our code.</p>
<p>But then we come to a point where the need to add a new data source, and alas, this one
won’t have a <code class="docutils literal notranslate"><span class="pre">fetch()</span></code> method. To make things worse, not only is this type of object not
compatible, but it is also not something we control (perhaps a different team decided on the
API, and we cannot modify the code).</p>
<p>Instead of using this object directly, we adopt its interface to the one we need. There are
two ways of doing this.</p>
<p>The first way would be to create a class that inherits from the one we want to use, and that
creates an alias for the method (if required, it will also have to adapt the parameters and the
signature).</p>
<p>By means of inheritance, we import the external class and create a new one that will define
the new method, calling the one that has a different name. In this example, let’s say the
external dependency has a method named <code class="docutils literal notranslate"><span class="pre">search()</span></code>, which takes only one parameter for
the search because it queries in a different fashion, so our <code class="docutils literal notranslate"><span class="pre">adapter</span></code> method not only calls
the external one, but it also translates the parameters accordingly, as shown in the
following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_adapter_base</span> <span class="kn">import</span> <span class="n">UsernameLookup</span>


<span class="k">class</span> <span class="nc">UserSource</span><span class="p">(</span><span class="n">UsernameLookup</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="n">user_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_arguments</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">user_namespace</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_adapt_arguments</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{user_id}</span><span class="s2">:</span><span class="si">{username}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>It might be the case that our class already derives from another one, in which case, this will
end up as a case of multiple inheritances, which Python supports, so it shouldn’t be a
problem. However, as we have seen many times before, inheritance comes with more
coupling (who knows how many other methods are being carried from the external
library?), and it’s inflexible. Conceptually, it also wouldn’t be the right choice because we
reserve inheritance for situations of specification (an is a kind of relationship), and in this
case, it’s not clear at all that our object has to be one of the kinds that are provided by a
third-party library (especially since we don’t fully comprehend that object).</p>
<p>Therefore, a better approach would be to use composition instead. Assuming that we can
provide our object with an instance of UsernameLookup, the code would be as simple as
just redirecting the petition prior to adopting the parameters, as shown in the following
code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UserSource</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="n">user_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_arguments</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">username_lookup</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">user_namespace</span><span class="p">)</span>
</pre></div>
</div>
<p>If we need to adopt multiple methods, and we can devise a generic way of adapting their
signature as well, it might be worth using the <code class="docutils literal notranslate"><span class="pre">__getattr__()</span></code> magic method to redirect
requests towards the wrapped object, but as always with generic implementations, we
should be careful of not adding more complexity to the solution.</p>
</div>
<div class="section" id="composite">
<h3>2.2.2. Composite<a class="headerlink" href="#composite" title="Permalink to this headline">¶</a></h3>
<p>There will be parts of our programs that require us to work with objects that are made out
of other objects. We have base objects that have a well-defined logic, and then we will have
other container objects that will group a bunch of base objects, and the challenge is that we
want to treat both of them (the base and the container objects) without noticing any
differences.</p>
<p>The objects are structured in a tree hierarchy, where the basic objects would be the leaves of
the tree, and the composed objects intermediate nodes. A client might want to call any of
them to get the result of a method that is called. The composite object, however, will act as a
client; this also will pass this request along with all the objects it contains whether they are
leaves or other intermediate notes until they all are processed.</p>
<p>Imagine a simplified version of an online store in which we have products. Say that we
offer the possibility of grouping those products, and we give customers a discount per
group of products. A product has a price, and this value will be asked for when the
customers come to pay. But a set of grouped products also has a price that has to be
computed. We will have an object that represents this group that contains the products, and
that delegates the responsibility of asking the price to each particular product (which might
be another group of products as well), and so on, until there is nothing else to compute. The
implementation of this is shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Product</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">price</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_price</span> <span class="o">=</span> <span class="n">price</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_price</span>

<span class="k">class</span> <span class="nc">ProductBundle</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">,</span>
                 <span class="n">perc_discount</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">products</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Product</span><span class="p">,</span> <span class="s2">&quot;ProductBundle&quot;</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_perc_discount</span> <span class="o">=</span> <span class="n">perc_discount</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_products</span> <span class="o">=</span> <span class="n">products</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">price</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_products</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">total</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_perc_discount</span><span class="p">)</span>
</pre></div>
</div>
<p>We expose the public interface through a property, and leave the price as a private
attribute. The <code class="docutils literal notranslate"><span class="pre">ProductBundle</span></code> class uses this property to compute the value with the
discount applied by first adding all the prices of all the products it contains.</p>
<p>The only discrepancy between these objects is that they are created with different
parameters. To be fully compatible, we should have tried to mimic the same interface and
then added extra methods for adding products to the bundle but using an interface that
allows the creation of complete objects. Not needing these extra steps is an advantage that
justifies this small difference.</p>
</div>
<div class="section" id="decorator">
<h3>2.2.3. Decorator<a class="headerlink" href="#decorator" title="Permalink to this headline">¶</a></h3>
<p>Don’t confuse the decorator pattern with the concept of a Python decorator. There is some
resemblance, but the idea of the design pattern is quite different.</p>
<p>This pattern allows us to dynamically extend the functionality of some objects, without
needing inheritance. It’s a good alternative to multiple inheritance in creating more flexible
objects.</p>
<p>We are going to create a structure that let’s a user define a set of operations (decorations) to
be applied over an object, and we’ll see how each step takes place in the specified order.</p>
<p>The following code example is a simplified version of an object that constructs a query in
the form of a dictionary from parameters that are passed to it (it might be an object that we
would use for running queries to elasticsearch, for instance, but the code leaves out
distracting implementation details to focus on the concepts of the pattern).</p>
<p>In its most basic form, the query just returns the dictionary with the data it was provided
when it was created. Clients expect to use the <code class="docutils literal notranslate"><span class="pre">render()</span></code> method of this object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DictQuery</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_query</span> <span class="o">=</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_query</span>
</pre></div>
</div>
<p>Now we want to render the query in different ways by applying transformations to the
data (filtering values, normalizing them, and so on). We could create decorators and apply
them to the render method, but that wouldn’t be flexible enough what if we want to
change them at runtime? Or if we want to select some of them, but not others?</p>
<p>The design is to create another object, with the same interface and the capability of
enhancing (decorating) the original result through many steps, but which can be combined.
These objects are chained, and each one of them does what it was originally supposed to
do, plus something else. This something else is the particular decoration step.</p>
<p>Since Python has duck typing, we don’t need to create a new base class and make these new
objects part of that hierarchy, along with <code class="docutils literal notranslate"><span class="pre">DictQuery</span></code>. Simply creating a new class that has
a <code class="docutils literal notranslate"><span class="pre">render()</span></code> method will be enough (again, polymorphism should not require inheritance).
This process is shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">QueryEnhancer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">DictQuery</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decorated</span> <span class="o">=</span> <span class="n">query</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decorated</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">RemoveEmpty</span><span class="p">(</span><span class="n">QueryEnhancer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">original</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">original</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">}</span>

<span class="k">class</span> <span class="nc">CaseInsensitive</span><span class="p">(</span><span class="n">QueryEnhancer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">original</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">original</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">QueryEnhancer</span></code> phrase has an interface that is compatible with what the clients
of <code class="docutils literal notranslate"><span class="pre">DictQuery</span></code> are expecting, so they are interchangeable. This object is designed to receive
a decorated one. It’s going to take the values from this and convert them, returning the
modified version of the code.</p>
<p>If we want to remove all values that evaluate to <code class="docutils literal notranslate"><span class="pre">False</span></code> and normalize them to form our
original query, we would have to use the following schema:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">original</span> <span class="o">=</span> <span class="n">DictQuery</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">none</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="s2">&quot;UPPERCASE&quot;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Title&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_query</span> <span class="o">=</span> <span class="n">CaseInsensitive</span><span class="p">(</span><span class="n">RemoveEmpty</span><span class="p">(</span><span class="n">original</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">original</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="go">{&#39;key&#39;: &#39;value&#39;, &#39;empty&#39;: &#39;&#39;, &#39;none&#39;: None, &#39;upper&#39;: &#39;UPPERCASE&#39;, &#39;title&#39;:</span>
<span class="go">&#39;Title&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_query</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="go">{&#39;key&#39;: &#39;value&#39;, &#39;upper&#39;: &#39;uppercase&#39;, &#39;title&#39;: &#39;title&#39;}</span>
</pre></div>
</div>
<p>This is a pattern that we can also implement in different ways, taking advantage of the
dynamic nature of Python, and the fact that functions are objects. We could implement this
pattern with functions that are provided to the base decorator object (<code class="docutils literal notranslate"><span class="pre">QueryEnhancer</span></code>),
and define each decoration step as a function, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">QueryEnhancer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">query</span><span class="p">:</span> <span class="n">DictQuery</span><span class="p">,</span>
                 <span class="o">*</span><span class="n">decorators</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span> <span class="o">=</span> <span class="n">query</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span> <span class="o">=</span> <span class="n">decorators</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorated</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">deco</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decorators</span><span class="p">:</span>
            <span class="n">current_result</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">current_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">current_result</span>
</pre></div>
</div>
<p>With respect to the client, nothing has changed because this class maintains the
compatibility through its <code class="docutils literal notranslate"><span class="pre">render()</span></code> method. Internally, however, this object is used in a
slightly different fashion, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">query</span> <span class="o">=</span> <span class="n">DictQuery</span><span class="p">(</span><span class="n">foo</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">none</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="s2">&quot;UPPERCASE&quot;</span><span class="p">,</span>
<span class="go">title=&quot;Title&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QueryEnhancer</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">remove_empty</span><span class="p">,</span> <span class="n">case_insensitive</span><span class="p">)</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
<span class="go">{&#39;foo&#39;: &#39;bar&#39;, &#39;upper&#39;: &#39;uppercase&#39;, &#39;title&#39;: &#39;title&#39;}</span>
</pre></div>
</div>
<p>In the preceding code, <code class="docutils literal notranslate"><span class="pre">remove_empty</span></code> and <code class="docutils literal notranslate"><span class="pre">case_insensitive</span></code> are just regular functions
that transform a dictionary.</p>
<p>In this example, the function-based approach seems easier to understand. There might be
cases with more complex rules that rely on data from the object being decorated (not only
its result), and in those cases, it might be worth going for the object-oriented approach,
especially if we really want to create a hierarchy of objects where each class actually
represents some knowledge we want to make explicit in our design.</p>
</div>
<div class="section" id="facade">
<h3>2.2.4. Facade<a class="headerlink" href="#facade" title="Permalink to this headline">¶</a></h3>
<p>Facade is an excellent pattern. It’s useful in many situations where we want to simplify the
interaction between objects. The pattern is applied where there is a relation of many-to-many
among several objects, and we want them to interact. Instead of creating all of these
connections, we place an intermediate object in front of many of them that act as a facade.</p>
<p>The facade works as a hub or a single point of reference in this layout. Every time a new
object wants to connect to another one, instead of having to have N interfaces for all N
possible objects it needs to connect to, it will instead just talk to the facade, and this will
redirect the request accordingly. Everything that’s behind the facade is completely opaque
to the rest of the external objects.</p>
<p>Apart from the main and obvious benefit (the decoupling of objects), this pattern also
encourages a simpler design with fewer interfaces and better encapsulation.</p>
<p>This is a pattern that we can use not only for improving the code of our domain problem
but also to create better APIs. If we use this pattern and provide a single interface, acting as
a single point of truth or entry point for our code, it will be much easier for our users to
interact with the functionality exposed. Not only that, but by exposing a functionality and
hiding everything behind an interface, we are free of changing or refactoring that
underlying code as many times as we want, because as long as it is behind the facade, it
will not break backward compatibility, and our users will not be affected.</p>
<p>Note how this idea of using facades is not even limited to objects and classes, but also
applies to packages (technically, packages are objects in Python, but still). We can use this
idea of the facade to decide the layout of a package; that is, what is visible to the user and
importable, and what is internal and should not be imported directly.</p>
<p>When we create a directory to build a package, we place the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file along with
the rest of the files. This is the root of the module, a sort of facade. The rest of the files
define the objects to export, but they shouldn’t be directly imported by clients. The init file
should import them and then clients should get them from there. This creates a better
interface because users only need to know a single entry point from which to get the
objects, and more importantly, the package (the rest of the files) can be refactored or
rearranged as many times as needed, and this will not affect clients as long as the main API
on the init file is maintained. It is of utmost importance to keep principles like this one in
mind in order to build maintainable software.</p>
<p>There is an example of this in Python itself, with the os module. This module groups an
operating system’s functionality, but underneath it, uses the posix module for Portable
Operating System Interface (POSIX) operating systems (this is called nt in Windows
platforms). The idea is that, for portability reasons, we shouldn’t ever really import
the posix module directly, but always the os module. It is up to this module to determine
from which platform it is being called, and expose the corresponding functionality.</p>
</div>
</div>
<div class="section" id="behavioral-patterns">
<h2>2.3. Behavioral patterns<a class="headerlink" href="#behavioral-patterns" title="Permalink to this headline">¶</a></h2>
<p>Behavioral patterns aim to solve the problem of how objects should cooperate, how they
should communicate, and what their interfaces should be at run-time.</p>
<p>This can be accomplished statically by means of inheritance or dynamically by using
composition. Regardless of what the pattern uses, what we will see throughout the
following examples is that what these patterns have in common is the fact that the resulting
code is better in some significant way, whether this is because it avoids duplication or
creates good abstractions that encapsulate behavior accordingly and decouple our models.</p>
<div class="section" id="chain-of-responsibility">
<h3>2.3.1. Chain of responsibility<a class="headerlink" href="#chain-of-responsibility" title="Permalink to this headline">¶</a></h3>
<p>Now we are going to take another look at our event systems. We want to parse information
about the events that happened on the system from the log lines (text files, dumped from
our HTTP application server, for example), and we want to extract this information in a
convenient way.</p>
<p>In our previous implementation, we achieved an interesting solution that was compliant
with the open/closed principle and relied on the use of the <code class="docutils literal notranslate"><span class="pre">__subclasses__()</span></code> magic
method to discover all possible event types and process the data with the right event,
resolving the responsibility through a method encapsulated on each class.</p>
<p>This solution worked for our purposes, and it was quite extensible, but as we’ll see, this
design pattern will bring additional benefits.</p>
<p>The idea here is that we are going to create the events in a slightly different way. Each event
still has the logic to determine whether or not it can process a particular log line, but it will
also have a successor. This successor is a new event, the next one in the line, that will
continue processing the text line in case the first one was not able to do so. The logic is
simple—we chain the events, and each one of them tries to process the data. If it can, then it
just returns the result. If it can’t, it will pass it to its successor and repeat, as shown in the
following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>


<span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">next_event</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">successor</span> <span class="o">=</span> <span class="n">next_event</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logline</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_process</span><span class="p">(</span><span class="n">logline</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process</span><span class="p">(</span><span class="n">logline</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">successor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">successor</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">logline</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logline</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">parsed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_data</span><span class="p">(</span><span class="n">logline</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">parsed_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">parsed_data</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">can_process</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">logline</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">logline</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">logline</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">logline</span><span class="p">)</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">LoginEvent</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;id&gt;\d+):\s+login\s+(?P&lt;value&gt;\S+)&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LogoutEvent</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;id&gt;\d+):\s+logout\s+(?P&lt;value&gt;\S+)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>With this implementation, we create the event objects, and arrange them in the particular
order in which they are going to be processed. Since they all have a <code class="docutils literal notranslate"><span class="pre">process()</span></code> method,
they are polymorphic for this message, so the order in which they are aligned is completely
transparent to the client, and either one of them would be transparent too. Not only that,
but the <code class="docutils literal notranslate"><span class="pre">process()</span></code> method has the same logic; it tries to extract the information if the data
provided is correct for the type of object handling it, and if not, it moves on to the next one
in the line.</p>
<p>This way, we could process a login event in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">LogoutEvent</span><span class="p">(</span><span class="n">LoginEvent</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="s2">&quot;567: login User&quot;</span><span class="p">)</span>
<span class="go">{&#39;type&#39;: &#39;LoginEvent&#39;, &#39;id&#39;: &#39;567&#39;, &#39;value&#39;: &#39;User&#39;}</span>
</pre></div>
</div>
<p>Note how <code class="docutils literal notranslate"><span class="pre">LogoutEvent</span></code> received <code class="docutils literal notranslate"><span class="pre">LoginEvent</span></code> as its successor, and when it was asked to
process something that it couldn’t handle, it redirected to the correct object. As we can see
from the type key on the dictionary, <code class="docutils literal notranslate"><span class="pre">LoginEvent</span></code> was the one that actually created that
dictionary.</p>
<p>This solution is flexible enough, and shares an interesting trait with our previous one: all
conditions are mutually exclusive. As long as there are no collisions, and no piece of data
has more than one handler, processing the events in any order will not be an issue.</p>
<p>But what if we cannot make such an assumption? With the previous implementation, we
could still change the <code class="docutils literal notranslate"><span class="pre">__subclasses__()</span></code> call for a list that we made according to our
criteria, and that would have worked just fine. And what if we wanted that order of
precedence to be determined at runtime (by the user or client, for example)? That would be
a shortcoming.</p>
<p>With the new solution, it’s possible to accomplish such requirements, because we assemble
the chain at runtime, so we can manipulate it dynamically as we need to.</p>
<p>For example, now we add a generic type that groups both the login and logout a session
event, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SessionEvent</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?P&lt;id&gt;\d+):\s+log(in|out)\s+(?P&lt;value&gt;\S+)&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>If for some reason, and in some part of the application, we want to capture this before the
login event, this can be done by the following chain:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">chain</span> <span class="o">=</span> <span class="n">SessionEvent</span><span class="p">(</span><span class="n">LoginEvent</span><span class="p">(</span><span class="n">LogoutEvent</span><span class="p">()))</span>
</pre></div>
</div>
<p>By changing the order, we can, for instance, say that a generic session event has a higher
priority than the login, but not the logout, and so on.</p>
<p>The fact that this pattern works with objects makes it more flexible with respect to our
previous implementation, which relied on classes (and while they are still objects in Python,
they aren’t excluded from some degree of rigidity).</p>
</div>
<div class="section" id="the-template-method">
<h3>2.3.2. The template method<a class="headerlink" href="#the-template-method" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">template</span></code> method is a pattern that yields important benefits when implemented
properly. Mainly, it allows us to reuse code, and it also makes our objects more flexible and
easy to change while preserving polymorphism.</p>
<p>The idea is that there is a class hierarchy that defines some behavior, let’s say an important
method of its public interface. All of the classes of the hierarchy share a common template
and might need to change only certain elements of it. The idea, then, is to place this generic
logic in the public method of the parent class that will internally call all other (private)
methods, and these methods are the ones that the derived classes are going to modify;
therefore, all the logic in the template is reused.</p>
<p>Avid readers might have noticed that we already implemented this pattern in the previous
section (as part of the chain of responsibility example). Note that the classes derived
from <code class="docutils literal notranslate"><span class="pre">Event</span></code> implement only one thing their particular pattern. For the rest of the logic, the
template is in the <code class="docutils literal notranslate"><span class="pre">Event</span></code> class. The process event is generic, and relies on two auxiliary
methods <code class="docutils literal notranslate"><span class="pre">can_process()</span></code> and <code class="docutils literal notranslate"><span class="pre">process()</span></code> (which in turn calls <code class="docutils literal notranslate"><span class="pre">_parse_data()</span></code>).</p>
<p>These extra methods rely on a class attribute pattern. Therefore, in order to extend this with
a new type of object, we just have to create a new derived class and place the regular
expression. After that, the rest of the logic will be inherited with this new attribute changed.
This reuses a lot of code because the logic for processing the log lines is defined once and
only once in the parent class.</p>
<p>This makes the design flexible because preserving the polymorphism is also easily
achievable. If we need a new event type that for some reason needs a different way of
parsing data, we only override this private method in that subclass, and the compatibility
will be kept, as long as it returns something of the same type as the original one (complying
with Liskov’s substitution and open/closed principles). This is because it is the parent class
that is calling the method from the derived classes.</p>
<p>This pattern is also useful if we are designing our own library or framework. By arranging
the logic this way, we give users the ability to change the behavior of one of the classes
quite easily. They would have to create a subclass and override the particular private
method, and the result will be a new object with the new behavior that is guaranteed to be
compatible with previous callers of the original object.</p>
</div>
<div class="section" id="command">
<h3>2.3.3. Command<a class="headerlink" href="#command" title="Permalink to this headline">¶</a></h3>
<p>The command pattern provides us with the ability to separate an action that needs to be
done from the moment that it is requested to its actual execution. More than that, it can also
separate the original request issued by a client from its recipient, which might be a different
object. In this section, we are going to focus mainly on the first aspect of the patterns; the
fact that we can separate how an order has to be run from when it actually executes.</p>
<p>We know we can create callable objects by implementing the <code class="docutils literal notranslate"><span class="pre">__call__()</span></code> magic method,
so we could just initialize the object and then call it later on. In fact, if this is the only
requirement, we might even achieve this through a nested function that, by means of a
closure, creates another function to achieve the effect of a delayed execution. But this
pattern can be extended to ends that aren’t so easily achievable.</p>
<p>The idea is that the command might also be modified after its definition. This means that
the client specifies a command to run, and then some of its parameters might be changed,
more options added, and so on, until someone finally decides to perform the action.</p>
<p>Examples of this can be found in libraries that interact with databases. For instance,
in <code class="docutils literal notranslate"><span class="pre">psycopg2</span></code> (a PostgreSQL client library), we establish a connection. From this, we get a
cursor, and to that cursor we can pass an SQL statement to run. When we call the execute
method, the internal representation of the object changes, but nothing is actually run in the
database. It is when we call <code class="docutils literal notranslate"><span class="pre">fetchall()</span></code> (or a similar method) that the data is actually
queried and is available in the cursor.</p>
<p>The same happens in the popular Object Relational Mapper SQLAlchemy
(ORM SQLAlchemy). A query is defined through several steps, and once we have the
query object, we can still interact with it (add or remove filters, change the conditions,
apply for an order, and so on), until we decide we want the results of the query. After
calling each method, the query object changes its internal properties and returns self
(itself).</p>
<p>These are examples that resemble the behavior that we would like to achieve. A very
simple way of creating this structure would be to have an object that stores the parameters
of the commands that are to be run. After that, it has to also provide methods for
interacting with those parameters (adding or removing filters, and so on). Optionally, we
can add tracing or logging capabilities to that object to audit the operations that have been
taking place. Finally, we need to provide a method that will actually perform the action.
This one can be just <code class="docutils literal notranslate"><span class="pre">__call__()</span></code> or a custom one. Let’s call it <code class="docutils literal notranslate"><span class="pre">do()</span></code>.</p>
</div>
<div class="section" id="state">
<h3>2.3.4. State<a class="headerlink" href="#state" title="Permalink to this headline">¶</a></h3>
<p>The state pattern is a clear example of reification in software design, making the concept of
our domain problem an explicit object rather than just a side value.</p>
<p>Previously, we had an object that represented a merge
request, and it had a state associated with it (open, closed, and so on). We used an enum to
represent those states because, at that point, they were just data holding a value the string
representation of that particular state. If they had to have some behavior, or the entire
merge request had to perform some actions depending on its state and transitions, this
would not have been enough.</p>
<p>The fact that we are adding behavior, a runtime structure, to a part of the code has to make
us think in terms of objects, because that’s what objects are supposed to do, after all. And
here comes the reification: now the state cannot just simply be an enumeration with a
string; it needs to be an object.</p>
<p>Imagine that we have to add some rules to the merge request say, that when it moves from
open to closed, all approvals are removed (they will have to review the code again), and
that when a merge request is just opened, the number of approvals is set to zero (regardless
of whether it’s a reopened or a brand new merge request). Another rule could be that when
a merge request is merged, we want to delete the source branch, and of course, we want to
forbid users from performing invalid transitions (for example, a closed merge request
cannot be merged, and so on).</p>
<p>If we were to put all that logic into a single place, namely in the MergeRequest class, we
will end up with a class that has lots of responsibilities (a poor design), probably many
methods, and a very large number of if statements. It would be hard to follow the code
and to understand which part is supposed to represent which business rule.</p>
<p>It’s better to distribute this into smaller objects, each one with fewer responsibilities, and the
state objects are a good place for this. We create an object for each kind of state we want to
represent, and, in their methods, we place the logic for the transitions with the
aforementioned rules. The <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> object will then have a state collaborator, and
this, in turn, will also know about <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> (the double-dispatching mechanism is
needed to run the appropriate actions on <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> and handle the transitions).</p>
<p>We define a base abstract class with the set of methods to be implemented, and then a
subclass for each particular state we want to represent. Then the MergeRequest object
delegates all the actions to state , as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InvalidTransitionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when trying to move to a target state from an unreachable source state.&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">MergeRequestState</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">merge_request</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span> <span class="o">=</span> <span class="n">merge_request</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

<span class="k">class</span> <span class="nc">Open</span><span class="p">(</span><span class="n">MergeRequestState</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="o">.</span><span class="n">approvals</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="o">.</span><span class="n">approvals</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Closed</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;merging </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;deleting branch </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="o">.</span><span class="n">source_branch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Merged</span>

<span class="k">class</span> <span class="nc">Closed</span><span class="p">(</span><span class="n">MergeRequestState</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reopening closed merge request </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_request</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Open</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidTransitionError</span><span class="p">(</span><span class="s2">&quot;can&#39;t merge a closed request&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Merged</span><span class="p">(</span><span class="n">MergeRequestState</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidTransitionError</span><span class="p">(</span><span class="s2">&quot;already merged request&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">InvalidTransitionError</span><span class="p">(</span><span class="s2">&quot;already merged request&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MergeRequest</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_branch</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_branch</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_branch</span> <span class="o">=</span> <span class="n">source_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_branch</span> <span class="o">=</span> <span class="n">target_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approvals</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Open</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>

    <span class="nd">@state</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_state_cls</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">new_state_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self.target_branch}</span><span class="s2">:</span><span class="si">{self.source_branch}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>The following list outlines some clarifications about implementation details and the design
decisions that should be made:</p>
<ul>
<li><p>The state is a property, so not only is it public, but there is a single place with the definitions of how states are created for a merge request, passing <code class="docutils literal notranslate"><span class="pre">self</span></code> as a parameter.</p></li>
<li><p>The abstract base class is not strictly needed, but there are benefits to having it. First, it makes the kind of object we are dealing with more explicit. Second, it forces every substate to implement all the methods of the interface. There are two alternatives to this:</p>
<blockquote>
<div><ul class="simple">
<li><p>We could have not put the methods, and let <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> raise when trying to perform an invalid action, but this is not correct, and it doesn’t express what happened.</p></li>
<li><p>Related to this point is the fact that we could have just used a simple base class and left those methods empty, but then the default behavior of not doing anything doesn’t make it any clearer what should happen. If one of the methods in the subclass should do nothing (as in the case of merge), then it’s better to let the empty method just sit there and make it explicit that for that particular case, nothing should be done, as opposed to force that logic to all objects.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> and <code class="docutils literal notranslate"><span class="pre">MergeRequestState</span></code> have links to each other. The moment a transition is made, the former object will not have extra references and should be garbage-collected, so this relationship should be always 1:1. With some small and more detailed considerations, a weak reference might be used.</p></li>
</ul>
<p>The following code shows some examples of how the object is used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span> <span class="o">=</span> <span class="n">MergeRequest</span><span class="p">(</span><span class="s2">&quot;develop&quot;</span><span class="p">,</span> <span class="s2">&quot;master&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">approvals</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">approvals</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">approvals</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
<span class="go">INFO:log:reopening closed merge request master:develop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span>
<span class="go">INFO:log:merging master:develop</span>
<span class="go">INFO:log:deleting branch develop</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">InvalidTransitionError</span>: <span class="n">already merged request</span>
</pre></div>
</div>
<p>The actions for transitioning states are delegated to the state object, which <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code>
holds at all times (this can be any of the subclasses of <code class="docutils literal notranslate"><span class="pre">ABC</span></code>). They all know how to respond
to the same messages (in different ways), so these objects will take the appropriate actions
corresponding to each transition (deleting branches, raising exceptions, and so on), and
will then move MergeRequest to the next state.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> delegates all actions to its state object, we will find that this
typically happens every time the actions that it needs to do are in the form
<code class="docutils literal notranslate"><span class="pre">self.state.open()</span></code>, and so on. Can we remove some of that boilerplate?</p>
<p>We could, by means of <code class="docutils literal notranslate"><span class="pre">__getattr__()</span></code>, as it is portrayed in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MergeRequest</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_branch</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_branch</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_branch</span> <span class="o">=</span> <span class="n">source_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_branch</span> <span class="o">=</span> <span class="n">target_branch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">:</span> <span class="n">MergeRequestState</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approvals</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">Open</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>

    <span class="nd">@state</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_state_cls</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">new_state_cls</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self.target_branch}</span><span class="s2">:</span><span class="si">{self.source_branch}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>On the one hand, it is good that we reuse some code and remove repetitive lines. This gives
the abstract base class even more sense. Somewhere, we want to have all possible actions
documented, listed in a single place. That place used to be the <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> class, but
now those methods are gone, so the only remaining source of that truth is
in <code class="docutils literal notranslate"><span class="pre">MergeRequestState</span></code>. Luckily, the type annotation on the state attribute is really
helpful for users to know where to look for the interface definition.</p>
<p>A user can simply take a look and see that everything that <code class="docutils literal notranslate"><span class="pre">MergeRequest</span></code> doesn’t have will
be asked of its state attribute. From the init definition, the annotation will tell us that
this is an object of the <code class="docutils literal notranslate"><span class="pre">MergeRequestState</span></code> type, and by looking at this interface, we will
see that we can safely ask for the <code class="docutils literal notranslate"><span class="pre">open()</span></code>, <code class="docutils literal notranslate"><span class="pre">close()</span></code>, and <code class="docutils literal notranslate"><span class="pre">merge()</span></code> methods on it.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>