

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>General traits of good code &mdash; Clean Code Python</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="The SOLID principles" href="../4_solid_principles/index.html" />
    <link rel="prev" title="Pythonic code" href="../2_pythonic_code/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Clean Code in Python
          

          
            
            <img src="../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                2019.12
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1_docstrings_and_annotations/index.html">Docstrings and annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">General traits of good code</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#design-by-contract">1. Design by contract</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#preconditions">1.1. Preconditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#postconditions">1.2. Postconditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pythonic-contracts">1.3. Pythonic contracts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conclusions">1.4. Conclusions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#defensive-programming">2. Defensive programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#error-handling">2.1. Error handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#value-substitution">2.1.1. Value substitution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exception-handling">2.1.2. Exception handling</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#handle-exceptions-at-the-right-level-of-abstraction">2.1.2.1. Handle exceptions at the right level of abstraction</a></li>
<li class="toctree-l5"><a class="reference internal" href="#do-not-expose-tracebacks">2.1.2.2 Do not expose tracebacks</a></li>
<li class="toctree-l5"><a class="reference internal" href="#avoid-empty-except-blocks">2.1.2.3 Avoid empty except blocks</a></li>
<li class="toctree-l5"><a class="reference internal" href="#include-the-original-exception">2.1.2.4. Include the original exception</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-assertions-in-python">2.2. Using assertions in Python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#separation-of-concerns">3. Separation of concerns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cohesion-and-coupling">3.1. Cohesion and coupling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#acronyms-to-live-by">4. Acronyms to live by</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dry-oaoo">4.1. DRY/OAOO</a></li>
<li class="toctree-l3"><a class="reference internal" href="#yagni">4.2. YAGNI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kis">4.3. KIS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eafp-lbyl">4.4. EAFP/LBYL</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#composition-and-inheritance">5. Composition and inheritance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#when-inheritance-is-a-good-decision">5.1. When inheritance is a good decision</a></li>
<li class="toctree-l3"><a class="reference internal" href="#anti-patterns-for-inheritance">5.2. Anti-patterns for inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-inheritance-in-python">5.3. Multiple inheritance in Python</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#method-resolution-order-mro">5.3.1. Method Resolution Order (MRO)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mixins">5.3.2. Mixins</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#arguments-in-functions-and-methods">6. Arguments in functions and methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="#final-remarks-on-good-practices-for-software-design">7. Final remarks on good practices for software design</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4_solid_principles/index.html">The SOLID principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_decorators/index.html">Using decorators to improve our code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_descriptors/index.html">Getting more out of our objects with descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7_generators/index.html">Using generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_unit_testing/index.html">Unit testing and refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../9_design_patterns/index.html">Common design patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_clean_architecture/index.html">Clean architecture</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Clean Code in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>General traits of good code</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/chapters/3_general_traits/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="../4_solid_principles/index.html" class="btn btn-neutral float-right" title="The SOLID principles" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../2_pythonic_code/index.html" class="btn btn-neutral float-left" title="Pythonic code" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="general-traits-of-good-code">
<h1>General traits of good code<a class="headerlink" href="#general-traits-of-good-code" title="Permalink to this headline">¶</a></h1>
<div class="section" id="design-by-contract">
<h2>1. Design by contract<a class="headerlink" href="#design-by-contract" title="Permalink to this headline">¶</a></h2>
<p>Some parts of the software we are working on are not meant to be called directly by users, but instead by
other parts of the code. Such is the case when we divide the responsibilities of the application into
different components or layers, and we have to think about the interaction between them.</p>
<p>We will have to encapsulate some functionality behind each component, and expose an interface to clients who
are going to use that functionality, namely an <strong>Application Programming Interface (API)</strong>. The functions,
classes, or methods we write for that component have a particular way of working under certain considerations
that, if they are not met, will make our code crash. Conversely, clients calling that code expect a particular
response, and any failure of our function to provide this would represent a defect. That is to say that if,
for example, we have a function that is expected to work with a series of parameters of type integers, and
some other function invokes our passing strings, it is clear that it should not work as expected, but in
reality, the function should not run at all because it was called incorrectly (the client made a mistake).
This error should not pass silently.</p>
<p>Of course, when designing an API, the expected input, output, and side-effects should be documented. But
documentation cannot enforce the behavior of the software at runtime. These rules, what every part of the code
expects in order to work properly and what the caller is expecting from them, should be part of the design,
and here is where the concept of a contract comes into place.</p>
<p>The idea behind the DbC is that instead of implicitly placing in the code what every party is expecting, both
parties agree on a contract that, if violated, will raise an exception, clearly stating why it cannot
continue.</p>
<p>In our context, a contract is a construction that enforces some rules that must be honored during the
communication of software components. A contract entails mainly preconditions and postconditions, but in some
cases, invariants, and side-effects are also described:</p>
<ul class="simple">
<li><p><strong>Preconditions</strong>: We can say that these are all the checks code will do before running. It will check for all the conditions that have to be made before the function can proceed. In general, it’s implemented by validating the data set provided in the parameters passed, but nothing should stop us from running all sorts of validations (for example, validating a set in a database, a file, another method that was called before, and so on) if we consider that their side-effects are overshadowed by the importance of such a validation. Notice that this imposes a constraint on the caller.</p></li>
<li><p><strong>Postconditions</strong>: The opposite of preconditions, here, the validations are done after the function call is returned. Postcondition validations are run to validate what the caller is expecting from this component.</p></li>
<li><p><strong>Invariants</strong>: Optionally, it would be a good idea to document, in the docstring of a function, the invariants, the things that are kept constant while the code of the function is running, as an expression of the logic of the function to be correct.</p></li>
<li><p><strong>Side-effects</strong>: Optionally, we can mention any side-effects of our code in the docstring.</p></li>
</ul>
<p>While conceptually all of these items form part of the contract for a software component, and this is what
should go to the documentation of such piece, only the first two (preconditions and postconditions) are to be
enforced at a low level (code).</p>
<p>The reason why we would design by contract is that if errors occur, they must
be easy to spot (and by noticing whether it was either the precondition or postcondition that failed, we will
find the culprit much easily) so that they can be quickly corrected. More importantly, we want critical parts
of the code to avoid being executed under the wrong assumptions. This should help to clearly mark the limits
for the responsibilities and errors if they occur, as opposed to something saying—this part of the application
is failing… But the caller code provided the wrong arguments, so where should we apply the fix?</p>
<p>The idea is that preconditions bind the client (they have an obligation to meet them if they want to run some part of the
code), whereas postconditions bind the component in question to some guarantees that the client can verify and
enforce.</p>
<p>This way, we can quickly identify responsibilities. If the precondition fails, we know it is due to a
defect on the client. On the other hand, if the postcondition check fails, we know the problem is in the
routine or class (supplier) itself.</p>
<p>Specifically regarding preconditions, it is important to highlight that they can be checked at runtime, and if
they occur, the code that is being called should not be run at all (it does not make sense to run it because
its conditions do not hold, and further more, doing so might end up making things worse).</p>
<div class="section" id="preconditions">
<h3>1.1. Preconditions<a class="headerlink" href="#preconditions" title="Permalink to this headline">¶</a></h3>
<p>Preconditions are all of the guarantees a function or method expects to receive in order to work correctly. In
general programming terms, this usually means to provide data that is properly formed, for example, objects
that are initialized, non-null values, and many more. For Python, in particular, being dynamically typed, this
also means that sometimes we need to check for the exact type of data that is provided. This is not exactly
the same as type checking, the kind mypy would do this, but rather verify for exact values that are needed.</p>
<p>Part of these checks can be detected early on by using static analysis tools, such as mypy, but
these checks are not enough. A function should have proper validation for the information that it is going to
handle.</p>
<p>Now, this poses the question of where to place the validation logic, depending on whether we let the clients
validate all the data before calling the function, or allow this one to validate everything that it received
prior running its own logic. The former corresponds to a tolerant approach (because the function itself is
still allowing any data, potentially malformed data as well), whereas the latter corresponds to a demanding
approach.</p>
<p>For the purposes of this analysis, we prefer a demanding approach when it comes to DbC, because it is usually
the safest choice in terms of robustness, and usually the most common practice in the industry.</p>
<p>Regardless of the approach we decide to take, we should always keep in mind the non-redundancy principle,
which states that the enforcement of each precondition for a function should be done by only one of the two
parts of the contract, but not both. This means that we put the validation logic on the client, or we leave it
to the function itself, but in no cases should we duplicate it (which also relates to the DRY principle).</p>
</div>
<div class="section" id="postconditions">
<h3>1.2. Postconditions<a class="headerlink" href="#postconditions" title="Permalink to this headline">¶</a></h3>
<p>Postconditions are the part of the contract that is responsible for enforcing the state after the method or
function has returned.</p>
<p>Assuming that the function or method has been called with the correct properties (that is, with its
preconditions met), then the postconditions will guarantee that certain properties are preserved.</p>
<p>The idea is to use postconditions to check and validate for everything that a client might need. If the method
executed properly, and the postcondition validations pass, then any client calling that code should be able to
work with the returned object without problems, as the contract has been fulfilled.</p>
</div>
<div class="section" id="pythonic-contracts">
<h3>1.3. Pythonic contracts<a class="headerlink" href="#pythonic-contracts" title="Permalink to this headline">¶</a></h3>
<p>Programming by Contract for Python, is deferred. This doesn’t mean that we cannot implement it in Python,
because, as introduced at the beginningf, this is a general design principle.</p>
<p>Probably the best way to enforce this is by adding control mechanisms to our methods, functions, and classes,
and if they fail raise a RuntimeError exception or ValueError . It’s hard to devise a general rule for the
correct type of exception, as that would pretty much depend on the application in particular. These previously
mentioned exceptions are the most common types of exception, but if they don’t fit accurately with the
problem, creating a custom exception would be the best choice.</p>
<p>We would also like to keep the code as isolated as possible. That is, the code for the preconditions in one
part, the one for the postconditions in another, and the core of the function separated. We could achieve this
separation by creating smaller functions, but in some cases implementing a decorator would be an interesting
alternative.</p>
</div>
<div class="section" id="conclusions">
<h3>1.4. Conclusions<a class="headerlink" href="#conclusions" title="Permalink to this headline">¶</a></h3>
<p>The main value of this design principle is to effectively identify where the problem is. By defining a
contract, when something fails at runtime it will be clear what part of the code is broken, and what broke the
contract.</p>
<p>As a result of following this principle, the code will be more robust. Each component is enforcing its own
constraints and maintaining some invariants, and the program can be proven correct as long as these invariants
are preserved.</p>
<p>It also serves the purpose of clarifying the structure of the program better. Instead of trying to run ad hoc
validations, or trying to surmount all possible failure scenarios, the contracts explicitly specify what each
function or method expects to work properly, and what is expected from them.</p>
<p>Of course, following these principles also adds extra work, because we are not just programming the core logic
of our main application, but also the contracts. In addition, we might also want to consider adding unit tests
for these contracts as well. However, the quality gained by this approach pays off in the long run; hence, it
is a good idea to implement this principle for critical components of the application.</p>
<p>Nonetheless, for this method to be effective, we should carefully think about what are we willing to validate,
and this has to be a meaningful value. For example, it would not make much sense to define contracts that only
check for the correct data types of the parameters provided to a function. Many programmers would argue that
this would be like trying to make Python a statically-typed language. Regardless of this, tools such as Mypy,
in combination with the use of annotations, would serve this purpose much better and with less effort. With
that in mind, design contracts so that there is actually value on them.</p>
</div>
</div>
<div class="section" id="defensive-programming">
<h2>2. Defensive programming<a class="headerlink" href="#defensive-programming" title="Permalink to this headline">¶</a></h2>
<p>Defensive programming follows a somewhat different approach than DbC; instead of stating all conditions that
must be held in a contract, that if unmet will raise an exception and make the program fail, this is more
about making all parts of the code (objects, functions, or methods) able to protect themselves against invalid
inputs.</p>
<p>Defensive programming is a technique that has several aspects, and it is particularly useful if it is combined
with other design principles (this means that the fact that it follows a different philosophy than DbC does
not mean that it is a case of either one or the other—it could mean that they might complement each other).</p>
<p>The main ideas on the subject of defensive programming are how to handle errors for scenarios that we might
expect to occur, and how to deal with errors that should never occur (when impossible conditions happen). The
former will fall into error handling procedures, while the latter will be the case for assertions, both topics
we will be exploring in the following sections.</p>
<div class="section" id="error-handling">
<h3>2.1. Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h3>
<p>In our programs, we resort to error handling procedures for situations that we anticipate as prone to cause
errors. This is usually the case for data input.</p>
<p>The idea behind error handling is to gracefully respond to these expected errors in an attempt to either
continue our program execution or decide to fail if the error turns out to be insurmountable.</p>
<p>There are different approaches by which we can handle errors on our programs, but not all of them are always
applicable. Some of these approaches are as follows:</p>
<ul class="simple">
<li><p>Value substitution</p></li>
<li><p>Error logging</p></li>
<li><p>Exception handling</p></li>
</ul>
<div class="section" id="value-substitution">
<h4>2.1.1. Value substitution<a class="headerlink" href="#value-substitution" title="Permalink to this headline">¶</a></h4>
<p>In some scenarios, when there is an error and there is a risk of the software producing an incorrect value or
failing entirely, we might be able to replace the result with another, safer value. We call this value
substitution, since we are in fact replacing the actual erroneous result for a value that is to be considered
non-disruptive (it could be a default, a well-known constant, a sentinel value, or simply something that does
not affect the result at all, like returning zero in a case where the result is intended to be applied to a
sum).</p>
<p>Value substitution is not always possible, however. This strategy has to be carefully chosen for cases where
the substituted value is actually a safe option. Making this decision is a trade-off between robustness and
correctness. A software program is robust when it does not fail, even in the presence of an erroneous
scenario. But this is not correct either. This might not be acceptable for some kinds of software. If the
application is critical, or the data being handled is too sensitive, this is not an option, since we cannot
afford to provide users (or other parts of the application) with erroneous results. In these cases, we opt
for correctness, rather than let the program explode when yielding the wrong results.</p>
<p>A slightly different, and safer, version of this decision is to use default values for data that is not
provided. This can be the case for parts of the code that can work with a default behavior, for example,
default values for environment variables that are not set, for missing entries in configuration files, or for
parameters of functions. We can find examples of Python supporting this throughout different methods of its
API, for example, dictionaries have a get method, whose (optional) second parameter allows you to indicate a
default value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">configuration</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dbport&quot;</span><span class="p">:</span> <span class="mi">5432</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">configuration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dbhost&quot;</span><span class="p">,</span> <span class="s2">&quot;localhost&quot;</span><span class="p">)</span>
<span class="go">&#39;localhost&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">configuration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dbport&quot;</span><span class="p">)</span>
<span class="go">5432</span>
</pre></div>
</div>
<p>Environment variables have a similar API:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;DBHOST&quot;</span><span class="p">)</span>
<span class="go">&#39;localhost&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;DPORT&quot;</span><span class="p">,</span> <span class="mi">5432</span><span class="p">)</span>
<span class="go">5432</span>
</pre></div>
</div>
<p>In both previous examples, if the second parameter is not provided, None will be returned, because it’s the
default value those functions are defined with. We can also define default values for the parameters of our
own functions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">connect_database</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5432</span><span class="p">):</span>
<span class="gp">...</span>
<span class="go">        logger.info(&quot;connecting to database server at %s:%i&quot;, host, port)</span>
</pre></div>
</div>
<p>In general, replacing missing parameters with default values is acceptable, but substituting erroneous data
with legal close values is more dangerous and can mask some errors. Take this criterion into consideration
when deciding on this approach.</p>
</div>
<div class="section" id="exception-handling">
<h4>2.1.2. Exception handling<a class="headerlink" href="#exception-handling" title="Permalink to this headline">¶</a></h4>
<p>In the presence of incorrect or missing input data, sometimes it is possible to correct the situation with
some examples such as the ones mentioned in the previous section. In other cases, however, it is better to
stop the program from continuing to run with the wrong data than to leave it computing under erroneous
assumptions. In those cases, failing and notifying the caller that something is wrong is a good approach, and
this is the case for a precondition that was violated, as we saw in DbC.</p>
<p>Nonetheless, erroneous input data is not the only possible way in which a function can go wrong. After all,
functions are not just about passing data around; they also have side-effects and connect to external
components.</p>
<p>It could be possible that a fault in a function call is due to a problem on one of these external components,
and not in our function itself. If that is the case, our function should communicate this properly. This will
make it easier to debug. The function should clearly and unambiguously notify the rest of the application
about errors that cannot be ignored so that they can be addressed accordingly.</p>
<p>The mechanism for accomplishing this is an exception. It is important to emphasize that this is what
exceptions should be used for—clearly announcing an exceptional situation, not altering the flow of the
program according to business logic.</p>
<p>If the code tries to use exceptions to handle expected scenarios or business logic, the flow of the program
will become harder to read. This will lead to a situation where exceptions are used as a sort of go-to
statement, that (to make things worse) could span multiple levels on the call stack (up to caller functions),
violating the encapsulation of the logic into its correct level of abstraction. The case could get even worse
if these except blocks are mixing business logic with truly exceptional cases that the code is trying to
defend against; in that case, it will be harder to distinguish between the core logic we have to maintain and
errors to be handled.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not use exceptions as a go-to mechanism for business logic. Raise exceptions when there is
actually something wrong with the code that callers need to be aware of.</p>
</div>
<p>This last concept is an important one; exceptions are usually about notifying the caller about something that
is amiss. This means that exceptions should be used carefully because they weaken encapsulation. The more
exceptions a function has, the more the caller function will have to anticipate, therefore knowing about the
function it is calling. And if a function raises too many exceptions, this means that is not so context-free,
because every time we want to invoke it, we will have to keep all of its possible side-effects in mind.</p>
<p>This can be used as a heuristic to tell when a function is not cohesive enough and has too many
responsibilities. If it raises too many exceptions, it could be a sign that it has to be broken down into
multiple, smaller ones.</p>
<div class="section" id="handle-exceptions-at-the-right-level-of-abstraction">
<h5>2.1.2.1. Handle exceptions at the right level of abstraction<a class="headerlink" href="#handle-exceptions-at-the-right-level-of-abstraction" title="Permalink to this headline">¶</a></h5>
<p>Exceptions are also part of the principal functions that do one thing, and one thing only. The exception the
function is handling (or raising) has to be consistent with the logic encapsulated on it.</p>
<p>In this example, we can see what we mean by mixing different levels of abstractions. Imagine an object that
acts as a transport for some data in our application. It connects to an external component where the data is
going to be sent upon decoding. In the following listing, we will focus on the deliver_event method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataTransport</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An example of an object handling exceptions of different levels.&quot;&quot;&quot;</span>
    <span class="n">retry_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">retry_n_times</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connector</span> <span class="o">=</span> <span class="n">connector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">deliver_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;connection error detected: {e}&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{event} contains incorrect data: {e}&quot;</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">retry_n_times</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connector</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">ConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{e}: attempting new connection in {self.retry_threshold}&quot;</span><span class="p">)</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">retry_threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span>

        <span class="k">raise</span> <span class="n">ConnectionError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Couldn&#39;t connect after {self.retry_n_times} times&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>For our analysis, let’s zoom in and focus on how the deliver_event() method handles exceptions.</p>
<p>What does <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> have to do with <code class="docutils literal notranslate"><span class="pre">ConnectionError</span></code>? Not much. By looking at these two highly
different types of error, we can get an idea of how responsibilities should be divided. The
<code class="docutils literal notranslate"><span class="pre">ConnectionError</span></code> should be handled inside the connect method. This will allow a clear separation of
behavior. For example, if this method needs to support retries, that would be a way of doing it. Conversely,
<code class="docutils literal notranslate"><span class="pre">ValueError</span></code> belongs to the decode method of the event. With this new implementation, this method does not
need to catch any exception: the exceptions it was worrying about before are either handled by internal
methods or deliberately left to be raised.</p>
<p>We should separate these fragments into different methods or functions. For connection management, a small
function should be enough. This function will be in charge of trying to establish the connection, catching
exceptions (should they occur), and logging them accordingly:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">connect_with_retry</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">retry_n_times</span><span class="p">,</span> <span class="n">retry_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tries to establish the connection of &lt;connector&gt; retrying</span>
<span class="sd">    &lt;retry_n_times&gt;.</span>
<span class="sd">    If it can connect, returns the connection object.</span>
<span class="sd">    If it&#39;s not possible after the retries, raises ConnectionError</span>
<span class="sd">    :param connector: An object with a `.connect()` method.</span>
<span class="sd">    :param retry_n_times int: The number of times to try to call</span>
<span class="sd">    ``connector.connect()``.</span>
<span class="sd">    :param retry_threshold int: The time lapse between retry calls.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retry_n_times</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">connector</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">ConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{e}: attempting new connection in {retry_threshold}&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">retry_threshold</span><span class="p">)</span>
    <span class="n">exc</span> <span class="o">=</span> <span class="n">ConnectionError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Couldn&#39;t connect after {retry_n_times} times&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">exc</span>
</pre></div>
</div>
<p>Then, we will call this function in our method. As for the <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception on the event, we could
separate it with a new object and do composition, but for this limited case it would be overkill, so just
moving the logic to a separate method would be enough. With these two considerations in place, the new version
of the method looks much more compact and easier to read:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataTransport</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An example of an object that separates the exception handling by</span>
<span class="sd">    abstraction levels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">retry_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">retry_n_times</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connector</span> <span class="o">=</span> <span class="n">connector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">deliver_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connect_with_retry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retry_n_times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retry_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;{event} contains incorrect data: {e}&quot;</span><span class="p">)</span>
            <span class="k">raise</span>
</pre></div>
</div>
</div>
<div class="section" id="do-not-expose-tracebacks">
<h5>2.1.2.2 Do not expose tracebacks<a class="headerlink" href="#do-not-expose-tracebacks" title="Permalink to this headline">¶</a></h5>
<p>This is a security consideration. When dealing with exceptions, it might be acceptable to let them propagate
if the error is too important, and maybe even let the program fail if this is the decision for that particular
scenario and correctness was favored over robustness.</p>
<p>When there is an exception that denotes a problem, it’s important to log in with as much detail as possible
(including the traceback information, message, and all we can gather) so that the issue can be corrected
efficiently. At the same time, we want to include as much detail as possible for ourselves: we definitely
don’t want any of this becoming visible to users.</p>
<p>In Python, tracebacks of exceptions contain very rich and useful debugging information. Unfortunately, this
information is also very useful for attackers or malicious users who want to try and harm the application, not
to mention that the leak would represent an important information disclosure, jeopardizing the intellectual
property of your organization (parts of the code will be exposed).</p>
<p>If you choose to let exceptions propagate, make sure not to disclose any sensitive information. Also, if you
have to notify users about a problem, choose generic messages (such as Something went wrong, or Page not
found). This is a common technique used in web applications that display generic informative messages when an
HTTP error occurs.</p>
</div>
<div class="section" id="avoid-empty-except-blocks">
<h5>2.1.2.3 Avoid empty except blocks<a class="headerlink" href="#avoid-empty-except-blocks" title="Permalink to this headline">¶</a></h5>
<p>This was even referred to as the most diabolical Python anti-pattern. While it is good to anticipate and
defend our programs against some errors, being too defensive might lead to even worse problems. In particular,
the only problem with being too defensive is that there is an empty except block that silently passes without
doing anything.</p>
<p>Python is so flexible that it allows us to write code that can be faulty and yet, will not raise an error,
like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">process_data</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The problem with this is that it will not fail, ever. Even when it should. It is also non-Pythonic if you
remember from the zen of Python that errors should never pass silently.</p>
<p>If there is a true exception, this block of code will not fail, which might be what we wanted in the first
place. But what if there is a defect? We need to know if there is an error in our logic to be able to correct
it. Writing blocks such as this one will mask problems, making things harder to maintain.</p>
<p>There are two alternatives:</p>
<ul class="simple">
<li><p>Catch a more specific exception (not too broad, such as an Exception). In fact, some linting tools and IDEs will warn you in some cases when the code is handling too broad an exception.</p></li>
<li><p>Do some actual error handling on the except block.</p></li>
</ul>
<p>The best thing to do would be to apply both items simultaneously.</p>
<p>Handling a more specific exception (for example, AttributeError or KeyError) will make the program more
maintainable because the reader will know what to expect, and can get an idea of the why of it. It will also
leave other exceptions free to be raised, and if that happens, this probably means a bug, only this time it
can be discovered.</p>
<p>Handling the exception itself can mean multiple things. In its simplest form, it could be just about logging
the exception (make sure to use logger.exception or logger.error to provide the full context of what
happened). Other alternatives could be to return a default value (substitution, only that in this case after
detecting an error, not prior to causing it), or raising a different exception.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you choose to raise a different exception, to include the original exception that caused the problem,
which leads us to the next point.</p>
</div>
</div>
<div class="section" id="include-the-original-exception">
<h5>2.1.2.4. Include the original exception<a class="headerlink" href="#include-the-original-exception" title="Permalink to this headline">¶</a></h5>
<p>As part of our error handling logic, we might decide to raise a different one, and maybe even change its
message. If that is the case, it is recommended to include the original exception that led to that.</p>
<p>In Python 3, we can now use the raise &lt;e&gt; from &lt;original_exception&gt; syntax. When using this construction, the
original traceback will be embedded into the new exception, and the original exception will be set in the
<code class="docutils literal notranslate"><span class="pre">__cause__</span></code> attribute of the resulting one.</p>
<p>For example, if we desire to wrap default exceptions with custom ones internally to our project, we could
still do that while including information about the root exception:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InternalDataError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An exception with the data of our domain problem.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">data_dictionary</span><span class="p">,</span> <span class="n">record_id</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_dictionary</span><span class="p">[</span><span class="n">record_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InternalDataError</span><span class="p">(</span><span class="s2">&quot;Record not present&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Always use the raise &lt;e&gt; from &lt;o&gt; syntax when changing the type of the exception.</p>
</div>
</div>
</div>
</div>
<div class="section" id="using-assertions-in-python">
<h3>2.2. Using assertions in Python<a class="headerlink" href="#using-assertions-in-python" title="Permalink to this headline">¶</a></h3>
<p>Assertions are to be used for situations that should never happen, so the expression on the assert statement
has to mean an impossible condition. Should this condition happen, it means there is a defect in the software.</p>
<p>In contrast with the error handling approach, here there is (or should not be) a possibility of continuing the
program. If such an error occurs, the program must stop. It makes sense to stop the program because, as
commented before, we are in the presence of a defect, so there is no way to move forward by releasing a new
version of the software that corrects this defect.</p>
<p>The idea of using assertions is to prevent the program from causing further damage if such an invalid scenario
is presented. Sometimes, it is better to stop and let the program crash, rather than let it continue
processing under the wrong assumptions.</p>
<p>For this reason, assertions should not be mixed with the business logic, or used as control flow mechanisms
for the software. The following example is a bad idea:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">condition</span><span class="o">.</span><span class="n">holds</span><span class="p">(),</span> <span class="s2">&quot;Condition is not satisfied&quot;</span>
<span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
    <span class="n">alternative_procedure</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not catch the AssertionError exception.</p>
</div>
<p>Make sure that the program terminates when an assertion fails.</p>
<p>Include a descriptive error message in the assertion statement and log the errors to make sure that you can
properly debug and correct the problem later on.</p>
<p>Another important reason why the previous code is a bad idea is that besides catching AssertionError, the
statement in the assertion is a function call. Function calls can have side-effects, and they aren’t always
repeatable (we don’t know if calling condition.holds() again will yield the same result). Moreover, if we stop
the debugger at that line, we might not be able to conveniently see the result that causes the error, and,
again, even if we call that function again, we don’t know if that was the offending value.</p>
<p>A better alternative requires fewer lines of code and provides more useful information:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">condition</span><span class="o">.</span><span class="n">holds</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error with {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="separation-of-concerns">
<h2>3. Separation of concerns<a class="headerlink" href="#separation-of-concerns" title="Permalink to this headline">¶</a></h2>
<p>This is a design principle that is applied at multiple levels. It is not just about the low-level design
(code), but it is also relevant at a higher level of abstraction, so it will come up later when we talk about
architecture.</p>
<p>Different responsibilities should go into different components, layers, or modules of the application. Each
part of the program should only be responsible for a part of the functionality (what we call its concerns) and
should know nothing about the rest.</p>
<p>The goal of separating concerns in software is to enhance maintainability by minimizing ripple effects. A
ripple effect means the propagation of a change in the software from a starting point. This could be the case
of an error or exception triggering a chain of other exceptions, causing failures that will result in a defect
on a remote part of the application. It can also be that we have to change a lot of code scattered through
multiple parts of the code base, as a result of a simple change in a function definition.</p>
<p>Clearly, we do not want these scenarios to happen. The software has to be easy to change. If we have to modify
or refactor some part of the code that has to have a minimal impact on the rest of the application, the way to
achieve this is through proper encapsulation.</p>
<p>In a similar way, we want any potential errors to be contained so that they don’t cause major damage.</p>
<p>This concept is related to the DbC principle in the sense that each concern can be enforced by a contract.
When a contract is violated, and an exception is raised as a result of such a violation, we know what part of
the program has the failure, and what responsibilities failed to be met.</p>
<p>Despite this similarity, separation of concerns goes further. We normally think of contracts between
functions, methods, or classes, and while this also applies to responsibilities that have to be separated, the
idea of separation of concerns also applies to Python modules, packages, and basically any software component.</p>
<div class="section" id="cohesion-and-coupling">
<h3>3.1. Cohesion and coupling<a class="headerlink" href="#cohesion-and-coupling" title="Permalink to this headline">¶</a></h3>
<p>These are important concepts for good software design.</p>
<p>On the one hand, cohesion means that objects should have a small and well-defined purpose, and they should do
as little as possible. It follows a similar philosophy as Unix commands that do only one thing and do it well.
The more cohesive our objects are, the more useful and reusable they become, making our design better.</p>
<p>On the other hand, coupling refers to the idea of how two or more objects depend on each other. This
dependency poses a limitation. If two parts of the code (objects or methods) are too dependent on each other,
they bring with them some undesired consequences:</p>
<ul class="simple">
<li><p><strong>No code reuse</strong>: If one function depends too much on a particular object, or takes too many parameters, it’s coupled with this object, which means that it will be really difficult to use that function in a different context (in order to do so, we will have to find a suitable parameter that complies with a very restrictive interface).</p></li>
<li><p><strong>Ripple effects</strong>: Changes in one of the two parts will certainly impact the other, as they are too close</p></li>
<li><p><strong>Low level of abstraction</strong>: When two functions are so closely related, it is hard to see them as different concerns resolving problems at different levels of abstraction</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rule of thumb: Well-defined software will achieve high cohesion and low coupling.</p>
</div>
</div>
</div>
<div class="section" id="acronyms-to-live-by">
<h2>4. Acronyms to live by<a class="headerlink" href="#acronyms-to-live-by" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will review some principles that yield some good design ideas. The point is to quickly
relate to good software practices by acronyms that are easy to remember, working as a sort of mnemonic rule.
If you keep these words in mind, you will be able to associate them with good practices more easily, and
finding the right idea behind a particular line of code that you are looking at will be faster.</p>
<p>These are by no means formal or academic definitions, but more like empirical ideas that emerged from years of
working in the software industry. Some of them do appear in books, as they were coined by important authors,
and others have their roots probably in blog posts, papers, or conference talks.</p>
<div class="section" id="dry-oaoo">
<h3>4.1. DRY/OAOO<a class="headerlink" href="#dry-oaoo" title="Permalink to this headline">¶</a></h3>
<p>The ideas of <strong>Don’t Repeat Yourself (DRY) and Once and Only Once (OAOO)</strong> are closely related, so they were
included together here. They are self-explanatory, you should avoid duplication at all costs.</p>
<p>Things in the code, knowledge, have to be defined only once and in a single place. When you have to make a
change in the code, there should be only one rightful location to modify. Failure to do so is a sign of a
poorly designed system.</p>
<p>Code duplication is a problem that directly impacts maintainability. It is very undesirable to have code
duplication because of its many negative consequences:</p>
<ul class="simple">
<li><p><strong>It’s error prone</strong>: When some logic is repeated multiple times throughout the code, and this needs to change, it means we depend on efficiently correcting all the instances with this logic, without forgetting of any of them, because in that case there will be a bug.</p></li>
<li><p><strong>It’s expensive</strong>: Linked to the previous point, making a change in multiple places takes much more time (development and testing effort) than if it was defined only once. This will slow the team down.</p></li>
<li><p><strong>It’s unreliable</strong>: Also linked to the first point, when multiple places need to be changed for a single change in the context, you rely on the person who wrote the code to remember all the instances where the modification has to be made. There is no single source of truth.</p></li>
</ul>
<p>Duplication is often caused by ignoring (or forgetting) that code represents knowledge. By giving meaning to
certain parts of the code, we are identifying and labeling that knowledge.</p>
<p>Let’s see what this means with an example. Imagine that, in a study center, students are ranked by the
following criteria: 11 points per exam passed, minus five points per exam failed, and minus two per year in
the institution. The following is not actual code, but just a representation of how this might be scattered in
a real code base:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_students_list</span><span class="p">(</span><span class="n">students</span><span class="p">):</span>
    <span class="c1"># do some processing...</span>
    <span class="n">students_ranking</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">students</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">passed</span> <span class="o">*</span> <span class="mi">11</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">failed</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">years</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># more processing</span>
    <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">students_ranking</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name: {student.name}, Score: {student.passed * 11 - student.failed * 5 - student.years * 2}&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice how the lambda which is in the key of the sorted function represents some valid knowledge from the
domain problem, yet it doesn’t reflect it (it doesn’t have a name, a proper and rightful location, there is no
meaning assigned to that code, nothing). This lack of meaning in the code leads to the duplication we find
when the score is printed out while listing the raking.</p>
<p>We should reflect our knowledge of our domain problem in our code, and our code will then be less likely to
suffer from duplication and will be easier to understand:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">score_for_student</span><span class="p">(</span><span class="n">student</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">student</span><span class="o">.</span><span class="n">passed</span> <span class="o">*</span> <span class="mi">11</span> <span class="o">-</span> <span class="n">student</span><span class="o">.</span><span class="n">failed</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">-</span> <span class="n">student</span><span class="o">.</span><span class="n">years</span> <span class="o">*</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">process_students_list</span><span class="p">(</span><span class="n">students</span><span class="p">):</span>
    <span class="c1"># do some processing...</span>
    <span class="n">students_ranking</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">students</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">score_for_student</span><span class="p">)</span>
    <span class="c1"># more processing</span>
    <span class="k">for</span> <span class="n">student</span> <span class="ow">in</span> <span class="n">students_ranking</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name: {student.name}, Score: {core_for_student(student)}&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>A fair disclaimer: this is just an analysis of one of the traits of code duplication. In reality, there are
more cases, types, and taxonomies of code duplication, entire chapters could be dedicated to this topic, but
here we focus on one particular aspect to make the idea behind the acronym clear.</p>
<p>In this example, we have taken what is probably the simplest approach to eliminating duplication: creating a
function. Depending on the case, the best solution would be different. In some cases, there might be an
entirely new object that has to be created (maybe an entire abstraction was missing). In other cases, we can
eliminate duplication with a context manager. Iterators or generators could also help to avoid repetition in
the code, and decorators will also help.</p>
<p>Unfortunately, there is no general rule or pattern to tell you which of the features of Python are the most
suitable to address code duplication, but hopefully, after seeing the examples, and how the elements of Python
are used, you will be able to develop your own intuition.</p>
</div>
<div class="section" id="yagni">
<h3>4.2. YAGNI<a class="headerlink" href="#yagni" title="Permalink to this headline">¶</a></h3>
<p><strong>YAGNI (short for You Ain’t Gonna Need It)</strong> is an idea you might want to keep in mind very often when
writing a solution if you do not want to over-engineer it.</p>
<p>We want to be able to easily modify our programs, so we want to make them future-proof. In line with that,
many developers think that they have to anticipate all future requirements and create solutions that are very
complex, and so create abstractions that are hard to read, maintain, and understand. Sometime later, it turns
out that those anticipated requirements do not show up, or they do but in a different way (surprise!), and the
original code that was supposed to handle precisely that does not work. The problem is that now it is even
harder to refactor and extend our programs. What happened was that the original solution did not handle the
original requirements correctly, and neither do the current ones, simply because it is the wrong abstraction.</p>
<p>Having maintainable software is not about anticipating future requirements. It is about writing software that
only addresses current requirements in such a way that it will be possible (and easy) to change later on. In
other words, when designing, make sure that your decisions don’t tie you down, and that you will be able to
keep on building, but do not build more than what’s necessary.</p>
</div>
<div class="section" id="kis">
<h3>4.3. KIS<a class="headerlink" href="#kis" title="Permalink to this headline">¶</a></h3>
<p><strong>KIS (stands for Keep It Simple)</strong> relates very much to the previous point. When you are designing a software
component, avoid over-engineering it; ask yourself if your solution is the minimal one that fits the problem.</p>
<p>Implement minimal functionality that correctly solves the problem and does not complicate your solution more
than is necessary. Remember: the simpler the design, the more maintainable it will be.</p>
<p>This design principle is an idea we will want to keep in mind at all levels of abstraction, whether we are
thinking of a high-level design, or addressing a particular line of code.</p>
<p>At a high-level, think on the components we are creating. Do we really need all of them? Does this module a
ctually require being utterly extensible right now? Emphasize the last part—maybe we want to make that
component extensible, but now is not the right time, or it is not appropriate to do so because we still do not
have enough information to create the proper abstractions, and trying to come up with generic interfaces at
this point will only lead to even worse problems.</p>
<p>In terms of code, keeping it simple usually means using the smallest data structure that fits the problem.
You will most likely find it in the standard library.</p>
<p>Sometimes, we might over-complicate code, creating more functions or methods than what’s necessary. The
following class creates a namespace from a set of keyword arguments that have been provided, but it has a
rather complicated code interface:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ComplicatedNamespace</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An convoluted example of initializing an object with some</span>
<span class="sd">    properties.&quot;&quot;&quot;</span>

    <span class="n">ACCEPTED_VALUES</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;id_&quot;</span><span class="p">,</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">init_with_data</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ACCEPTED_VALUES</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instance</span>
</pre></div>
</div>
<p>Having an extra class method for initializing the object doesn’t seem really necessary. Then, the iteration,
and the call to setattr inside it, make things even more strange, and the interface that is presented to the
user is not very clear:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cn</span> <span class="o">=</span> <span class="n">ComplicatedNamespace</span><span class="o">.</span><span class="n">init_with_data</span><span class="p">(</span>
<span class="gp">...</span>
<span class="go">id_=42, user=&quot;root&quot;, location=&quot;127.0.0.1&quot;, extra=&quot;excluded&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cn</span><span class="o">.</span><span class="n">id_</span><span class="p">,</span> <span class="n">cn</span><span class="o">.</span><span class="n">user</span><span class="p">,</span> <span class="n">cn</span><span class="o">.</span><span class="n">location</span>
<span class="go">(42, &#39;root&#39;, &#39;127.0.0.1&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="s2">&quot;extra&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>The user has to know of the existence of this other method, which is not convenient. It would be better to
keep it simple, and just initialize the object as we initialize any other object in Python (after all, there
is a method for that) with the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Namespace</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create an object from keyword arguments.&quot;&quot;&quot;</span>

    <span class="n">ACCEPTED_VALUES</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;id_&quot;</span><span class="p">,</span> <span class="s2">&quot;user&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">):</span>
        <span class="n">accepted_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ACCEPTED_VALUES</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">accepted_data</span><span class="p">)</span>
</pre></div>
</div>
<p>Remember the zen of Python: simple is better than complex.</p>
</div>
<div class="section" id="eafp-lbyl">
<h3>4.4. EAFP/LBYL<a class="headerlink" href="#eafp-lbyl" title="Permalink to this headline">¶</a></h3>
<p><strong>EAFP (stands for Easier to Ask Forgiveness than Permission), while LBYL (stands for Look Before You Leap)</strong>.</p>
<p>The idea of EAFP is that we write our code so that it performs an action directly, and then we take care of
the consequences later in case it doesn’t work. Typically, this means try running some code, expecting it to
work, but catching an exception if it doesn’t, and then handling the corrective code on the except block.</p>
<p>This is the opposite of LBYL. As its name says, in the look before you leap approach, we first check what we
are about to use. For example, we might want to check if a file is available before trying to operate with it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>This might be good for other programming languages, but it is not the Pythonic way of writing code. Python was
built with ideas such as EAFP, and it encourages you to follow them (remember, explicit is better than
implicit). This code would instead be rewritten like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="n">FileNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Prefer EAFP over LBYL.</p>
</div>
</div>
</div>
<div class="section" id="composition-and-inheritance">
<h2>5. Composition and inheritance<a class="headerlink" href="#composition-and-inheritance" title="Permalink to this headline">¶</a></h2>
<p>In object-oriented software design, there are often discussions as to how to address some problems by using
the main ideas of the paradigm (polymorphism, inheritance, and encapsulation).</p>
<p>Probably the most commonly used of these ideas is inheritance—developers often start by creating a class
hierarchy with the classes they are going to need and decide the methods each one should implement.</p>
<p>While inheritance is a powerful concept, it does come with its perils. The main one is that every time we
extend a base class, we are creating a new one that is tightly coupled with the parent. As we have already
discussed, coupling is one of the things we want to reduce to a minimum when designing software.</p>
<p>One of the main uses developers relate inheritance with is code reuse. While we should always embrace code
reuse, it is not a good idea to force our design to use inheritance to reuse code just because we get the
methods from the parent class for free. The proper way to reuse code is to have highly cohesive objects that
can be easily composed and that could work on multiple contexts.</p>
<div class="section" id="when-inheritance-is-a-good-decision">
<h3>5.1. When inheritance is a good decision<a class="headerlink" href="#when-inheritance-is-a-good-decision" title="Permalink to this headline">¶</a></h3>
<p>We have to be careful when creating a derived class, because this is a double-edged sword—on the one hand, it
has the advantage that we get all the code of the methods from the parent class for free, but on the other
hand, we are carrying all of them to a new class, meaning that we might be placing too much functionality in a
new definition.</p>
<p>When creating a new subclass, we have to think if it is actually going to use all of the methods it has just
inherited, as a heuristic to see if the class is correctly defined. If instead, we find out that we do not
need most of the methods, and have to override or replace them, this is a design mistake that could be caused
by several reasons:</p>
<ul class="simple">
<li><p>The superclass is vaguely defined and contains too much responsibility, instead of a well-defined interface.</p></li>
<li><p>The subclass is not a proper specialization of the superclass it is trying to extend.</p></li>
</ul>
<p>A good case for using inheritance is the type of situation when you have a class that defines certain
components with its behavior that are defined by the interface of this class (its public methods and
attributes), and then you need to specialize this class in order to create objects that do the same but with
something else added, or with some particular parts of its behavior changed.</p>
<p>You can find examples of good uses of inheritance in the Python standard library itself. For example, in the
<code class="docutils literal notranslate"><span class="pre">http.server</span></code> package, we can find a base class such as <code class="docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code>, and subclasses such as
<code class="docutils literal notranslate"><span class="pre">SimpleHTTPRequestHandler</span></code> that extend this one by adding or changing part of its base interface.</p>
<p>Speaking of interface definition, this is another good use for inheritance. When we want to enforce the
interface of some objects, we can create an abstract base class that does not implement the behavior itself,
but instead just defines the interface—every class that extends this one will have to implement these to be a
proper subtype.</p>
<p>Finally, another good case for inheritance is exceptions. We can see that the standard exception in Python
derives from <code class="docutils literal notranslate"><span class="pre">Exception</span></code>. This is what allows you to have a generic clause such as <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception:</span></code>,
which will catch every possible error. The important point is the conceptual one, they are classes derived
from Exception because they are more specific exceptions. This also works in well-known libraries such as
<code class="docutils literal notranslate"><span class="pre">requests</span></code>, for instance, in which an <code class="docutils literal notranslate"><span class="pre">HTTPError</span></code> is <code class="docutils literal notranslate"><span class="pre">RequestException</span></code>, which in turn is an <code class="docutils literal notranslate"><span class="pre">IOError</span></code>.</p>
</div>
<div class="section" id="anti-patterns-for-inheritance">
<h3>5.2. Anti-patterns for inheritance<a class="headerlink" href="#anti-patterns-for-inheritance" title="Permalink to this headline">¶</a></h3>
<p>If the previous section had to be summarized into a single word, it would be specialization. The correct use
for inheritance is to specialize objects and create more detailed abstractions starting from base ones.</p>
<p>The parent (or base) class is part of the public definition of the new derived class. This is because the
methods that are inherited will be part of the interface of this new class. For this reason, when we read the
public methods of a class, they have to be consistent with what the parent class defines.</p>
<p>For example, if we see that a class derived from <code class="docutils literal notranslate"><span class="pre">BaseHTTPRequestHandler</span></code> implements a method named
<code class="docutils literal notranslate"><span class="pre">handle()</span></code>, it would make sense because it is overriding one of the parents. If it had any other method
whose name relates to an action that has to do with an HTTP request, then we could also think that is
correctly placed (but we would not think that if we found something called process_purchase() on that class).</p>
<p>The previous illustration might seem obvious, but it is something that happens very often, especially when
developers try to use inheritance with the sole goal of reusing code. In the next example, we will see a
typical situation that represents a common anti-pattern in Python: there is a domain problem that has to be
represented, and a suitable data structure is devised for that problem, but instead of creating an object that
uses such a data structure, the object becomes the data structure itself.</p>
<p>Let’s see these problems more concretely through an example. Imagine we have a system for managing insurance,
with a module in charge of applying policies to different clients. We need to keep in memory a set of
customers that are being processed at the time in order to apply those changes before further processing or
persistence. The basic operations we need are to store a new customer with its records as satellite data,
apply a change on a policy, or edit some of the data, just to name a few. We also need to support a batch
operation, that is, when something on the policy itself changes (the one this module is currently processing),
we have to apply these changes overall to customers on the current transaction.</p>
<p>Thinking in terms of the data structure we need, we realize that accessing the record for a particular
customer in constant time is a nice trait. Therefore, something like <code class="docutils literal notranslate"><span class="pre">policy_transaction[customer_id]</span></code>
looks like a nice interface. From this, we might think that a subscriptable object is a good idea, and further
on, we might get carried away into thinking that the object we need is a dictionary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransactionalPolicy</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">UserDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Example of an incorrect use of inheritance.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">change_in_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="o">**</span><span class="n">new_policy_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">customer_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">new_policy_data</span><span class="p">)</span>
</pre></div>
</div>
<p>With this code, we can get information about a policy for a customer by its identifier:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">policy</span> <span class="o">=</span> <span class="n">TransactionalPolicy</span><span class="p">({</span>
<span class="gp">...</span>
<span class="go">&quot;client001&quot;: {</span>
<span class="gp">...</span>
<span class="go">&quot;fee&quot;: 1000.0,</span>
<span class="gp">...</span>
<span class="go">&quot;expiration_date&quot;: datetime(2020, 1, 3),</span>
<span class="gp">...</span>
<span class="go">}</span>
<span class="gp">... </span><span class="p">})</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">policy</span><span class="p">[</span><span class="s2">&quot;client001&quot;</span><span class="p">]</span>
<span class="go">{&#39;fee&#39;: 1000.0, &#39;expiration_date&#39;: datetime.datetime(2020, 1, 3, 0, 0)}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">policy</span><span class="o">.</span><span class="n">change_in_policy</span><span class="p">(</span><span class="s2">&quot;client001&quot;</span><span class="p">,</span> <span class="n">expiration_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="go">4))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">policy</span><span class="p">[</span><span class="s2">&quot;client001&quot;</span><span class="p">]</span>
<span class="go">{&#39;fee&#39;: 1000.0, &#39;expiration_date&#39;: datetime.datetime(2020, 1, 4, 0, 0)}</span>
</pre></div>
</div>
<p>Sure, we achieved the interface we wanted in the first place, but at what cost? Now, this class has a lot of
extra behavior from carrying out methods that weren’t necessary:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span>
<span class="go">[ # all magic and special method have been omitted for brevity...</span>
<span class="go">&#39;change_in_policy&#39;, &#39;clear&#39;, &#39;copy&#39;, &#39;data&#39;, &#39;fromkeys&#39;, &#39;get&#39;, &#39;items&#39;,</span>
<span class="go">&#39;keys&#39;, &#39;pop&#39;, &#39;popitem&#39;, &#39;setdefault&#39;, &#39;update&#39;, &#39;values&#39;]</span>
</pre></div>
</div>
<p>There are (at least) two major problems with this design. On the one hand, the hierarchy is wrong. Creating a
new class from a base one conceptually means that it’s a more specific version of the class it’s extending
(hence the name). How is it that a <code class="docutils literal notranslate"><span class="pre">TransactionalPolicy</span></code> is a dictionary? Does this make sense? Remember,
this is part of the public interface of the object, so users will see this class, their hierarchy, and will
notice such an odd specialization, as well as its public methods.</p>
<p>This leads us to the second problem—coupling. The interface of the transactional policy now includes all
methods from a dictionary. Does a transactional policy really need methods such as <code class="docutils literal notranslate"><span class="pre">pop()</span></code> or <code class="docutils literal notranslate"><span class="pre">items()</span></code>?
However, there they are. They are also public, so any user of this interface is entitled to call them, with
whatever undesired side-effect they may carry. More on this point: we don’t really gain much by extending a
dictionary. The only method it actually needs to update for all customers affected by a change in the current
policy (<code class="docutils literal notranslate"><span class="pre">change_in_policy()</span></code>) is not on the base class, so we will have to define it ourselves either way.</p>
<p>This is a problem of mixing implementation objects with domain objects. A dictionary is an implementation
object, a data structure, suitable for certain kinds of operation, and with a trade-off like all data
structures. A transactional policy should represent something in the domain problem, an entity that is part of
the problem we are trying to solve.</p>
<p>Hierarchies like this one are incorrect, and just because we get a few magic methods from a base class (to
make the object subscriptable by extending a dictionary) is not reason enough to create such an extension.
Implementation classes should be extending solely when creating other, more specific, implementation classes.
In other words, extend a dictionary if you want to create another (more specific, or slightly modified)
dictionary. The same rule applies to classes of the domain problem.</p>
<p>The correct solution here is to use composition. <code class="docutils literal notranslate"><span class="pre">TransactionalPolicy</span></code> is not a dictionary: it uses a
dictionary. It should store a dictionary in a private attribute, and implement __getitem__() by proxying from
that dictionary and then only implementing the rest of the public method it requires:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TransactionalPolicy</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Example refactored to use composition.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy_data</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">policy_data</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_data</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">change_in_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">,</span> <span class="o">**</span><span class="n">new_policy_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">customer_id</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">new_policy_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">customer_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
</pre></div>
</div>
<p>This way is not only conceptually correct, but also more extensible. If the underlying data structure (which,
for now, is a dictionary) is changed in the future, callers of this object will not be affected, so long as
the interface is maintained. This reduces coupling, minimizes ripple effects, allows for better refactoring
(unit tests ought not to be changed), and makes the code more maintainable.</p>
</div>
<div class="section" id="multiple-inheritance-in-python">
<h3>5.3. Multiple inheritance in Python<a class="headerlink" href="#multiple-inheritance-in-python" title="Permalink to this headline">¶</a></h3>
<p>Python supports multiple inheritance. As inheritance, when improperly used, leads to design problems, you
could also expect that multiple inheritance will also yield even bigger problems when it’s not correctly
implemented.</p>
<p>Multiple inheritance is, therefore, a double-edged sword. It can also be very beneficial in some cases. Just
to be clear, there is nothing wrong with multiple inheritance, the only problem it has is that when it’s not
implemented correctly, it will multiply the problems.</p>
<p>Multiple inheritance is a perfectly valid solution when used correctly, and this opens up new patterns
(such as the adapter pattern) and mixins.</p>
<p>One of the most powerful applications of multiple inheritance is perhaps that which enables the creation of
mixins. Before exploring mixins, we need to understand how multiple inheritance works, and how methods are
resolved in a complex hierarchy.</p>
<div class="section" id="method-resolution-order-mro">
<h4>5.3.1. Method Resolution Order (MRO)<a class="headerlink" href="#method-resolution-order-mro" title="Permalink to this headline">¶</a></h4>
<p>Some people don’t like multiple inheritance because of the constraints it has in other programming languages,
for instance, the so-called diamond problem. When a class extends from two or more, and all of those classes
also extend from other base classes, the bottom ones will have multiple ways to resolve the methods coming
from the top-level classes. The question is, which of these implementations is used?</p>
<p>Consider the following diagram, which has a structure with multiple inheritance.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/ch3_diagram.png"><img alt="../../_images/ch3_diagram.png" src="../../_images/ch3_diagram.png" style="width: 50%;" /></a>
</div>
<p>The top-level class has a class attribute and implements the <code class="docutils literal notranslate"><span class="pre">__str__</span></code> method. Think of any of the concrete
classes, for example, <code class="docutils literal notranslate"><span class="pre">ConcreteModuleA12</span></code>: it extends from <code class="docutils literal notranslate"><span class="pre">BaseModule1</span></code> and <code class="docutils literal notranslate"><span class="pre">BaseModule2</span></code>, and each one
of them will take the implementation of <code class="docutils literal notranslate"><span class="pre">__str__</span></code> from <code class="docutils literal notranslate"><span class="pre">BaseModule</span></code>. Which of these two methods is going
to be the one for <code class="docutils literal notranslate"><span class="pre">ConcreteModuleA12</span></code>?</p>
<p>With the value of the class attribute, this will become evident:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BaseModule</span><span class="p">:</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;top&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">module_name</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;{self.module_name}:{self.name}&quot;</span>

<span class="k">class</span> <span class="nc">BaseModule1</span><span class="p">(</span><span class="n">BaseModule</span><span class="p">):</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;module-1&quot;</span>

<span class="k">class</span> <span class="nc">BaseModule2</span><span class="p">(</span><span class="n">BaseModule</span><span class="p">):</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;module-2&quot;</span>

<span class="k">class</span> <span class="nc">BaseModule3</span><span class="p">(</span><span class="n">BaseModule</span><span class="p">):</span>
    <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;module-3&quot;</span>

<span class="k">class</span> <span class="nc">ConcreteModuleA12</span><span class="p">(</span><span class="n">BaseModule1</span><span class="p">,</span> <span class="n">BaseModule2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extend 1 &amp; 2&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">ConcreteModuleB23</span><span class="p">(</span><span class="n">BaseModule2</span><span class="p">,</span> <span class="n">BaseModule3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extend 2 &amp; 3&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Now, let’s test this to see what method is being called:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">ConcreteModuleA12</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">))</span>
<span class="go">&#39;module-1:test&#39;</span>
</pre></div>
</div>
<p>There is no collision. Python resolves this by using an algorithm called C3 linearization or MRO, which
defines a deterministic way in which methods are going to be called.</p>
<p>In fact, we can specifically ask the class for its resolution order:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">ConcreteModuleA12</span><span class="o">.</span><span class="n">mro</span><span class="p">()]</span>
<span class="go">[&#39;ConcreteModuleA12&#39;, &#39;BaseModule1&#39;, &#39;BaseModule2&#39;, &#39;BaseModule&#39;, &#39;object&#39;]</span>
</pre></div>
</div>
<p>Knowing about how the method is going to be resolved in a hierarchy can be used to our advantage when
designing classes because we can make use of mixins.</p>
</div>
<div class="section" id="mixins">
<h4>5.3.2. Mixins<a class="headerlink" href="#mixins" title="Permalink to this headline">¶</a></h4>
<p>A mixin is a base class that encapsulates some common behavior with the goal of reusing code. Typically, a
mixin class is not useful on its own, and extending this class alone will certainly not work, because most of
the time it depends on methods and properties that are defined in other classes. The idea is to use mixin
classes along with other ones, through multiple inheritance, so that the methods or properties used on the
mixin will be available.</p>
<p>Imagine we have a simple parser that takes a string and provides iteration over it by its values separated by
hyphens (-):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BaseTokenizer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">str_token</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">str_token</span> <span class="o">=</span> <span class="n">str_token</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">str_token</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is quite straightforward:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tk</span> <span class="o">=</span> <span class="n">BaseTokenizer</span><span class="p">(</span><span class="s2">&quot;28a2320b-fd3f-4627-9792-a2b38e3c46b0&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">tk</span><span class="p">)</span>
<span class="go">[&#39;28a2320b&#39;, &#39;fd3f&#39;, &#39;4627&#39;, &#39;9792&#39;, &#39;a2b38e3c46b0&#39;]</span>
</pre></div>
</div>
<p>But now we want the values to be sent in upper-case, without altering the base class. For this simple example,
we could just create a new class, but imagine that a lot of classes are already extending from
<code class="docutils literal notranslate"><span class="pre">BaseTokenizer</span></code>, and we don’t want to replace all of them. We can mix a new class into the hierarchy that
handles this transformation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperIterableMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">Tokenizer</span><span class="p">(</span><span class="n">UpperIterableMixin</span><span class="p">,</span> <span class="n">BaseTokenizer</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The new <code class="docutils literal notranslate"><span class="pre">Tokenizer</span></code> class is really simple. It doesn’t need any code because it takes advantage of the mixin.
This type of mixing acts as a sort of decorator. Based on what we just saw, <code class="docutils literal notranslate"><span class="pre">Tokenizer</span></code> will take <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>
from the mixin, and this one, in turn, delegates to the next class on the line (by calling <code class="docutils literal notranslate"><span class="pre">super()</span></code>), which
is the <code class="docutils literal notranslate"><span class="pre">BaseTokenizer</span></code>, but it converts its values to uppercase, creating the desired effect.</p>
</div>
</div>
</div>
<div class="section" id="arguments-in-functions-and-methods">
<h2>6. Arguments in functions and methods<a class="headerlink" href="#arguments-in-functions-and-methods" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="final-remarks-on-good-practices-for-software-design">
<h2>7. Final remarks on good practices for software design<a class="headerlink" href="#final-remarks-on-good-practices-for-software-design" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../4_solid_principles/index.html" class="btn btn-neutral float-right" title="The SOLID principles" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../2_pythonic_code/index.html" class="btn btn-neutral float-left" title="Pythonic code" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>