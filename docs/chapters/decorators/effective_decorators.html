

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2. Effective decorators: avoid common mistakes &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                02/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../how_python_works/index.html">How does Python work?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development_environments/index.html">Modern Python Development Environments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../solid_principles/index.html">SOLID</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Decorators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../descriptors/index.html">Descriptors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generators/index.html">Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../metaprogramming/index.html">Metaprogramming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unit_testing/index.html">Unit testing and refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design_patterns/index.html">Design patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../clean_architecture/index.html">Clean architecture</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>2. Effective decorators: avoid common mistakes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/chapters/decorators/effective_decorators.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="effective-decorators-avoid-common-mistakes">
<h1>2. Effective decorators: avoid common mistakes<a class="headerlink" href="#effective-decorators-avoid-common-mistakes" title="Permalink to this headline">¶</a></h1>
<p>While decorators are a great feature of Python, they are not exempt from issues if used
incorrectly. In this section, we will see some common issues to avoid in order to create
effective decorators.</p>
<div class="section" id="preserving-data-about-the-original-wrapped-object">
<h2>2.1. Preserving data about the original wrapped object<a class="headerlink" href="#preserving-data-about-the-original-wrapped-object" title="Permalink to this headline">¶</a></h2>
<p>One of the most common problems when applying a decorator to a function is that some of
the properties or attributes of the original function are not maintained, leading to
undesired, and hard-to-track, side-effects.</p>
<p>To illustrate this we show a decorator that is in charge of logging when the function is
about to run:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trace_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;running </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now, let’s imagine we have a function with this decorator applied to it. We might initially
think that nothing of that function is modified with respect to its original definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@trace_decorator</span>
<span class="k">def</span> <span class="nf">process_account</span><span class="p">(</span><span class="n">account_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process an account by Id.&quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;processing account </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">account_id</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>But maybe there are changes.</p>
<p>The decorator is not supposed to alter anything from the original function, but, as it turns
out since it contains a flaw it’s actually modifying its name and docstring, among other
properties.</p>
<p>Let’s try to get help for this function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">process_account</span><span class="p">)</span>
<span class="go">Help on function wrapped in module decorator_wraps_1:</span>
<span class="go">wrapped(*args, **kwargs)</span>
</pre></div>
</div>
<p>And let’s check how it’s called:
.. code-block:: python</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">process_account</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;trace_decorator.&lt;locals&gt;.wrapped&#39;</span>
</pre></div>
</div>
<p>We can see that, since the decorator is actually changing the original function for a new one
(called <code class="docutils literal notranslate"><span class="pre">wrapped</span></code>), what we actually see are the properties of this function instead of those
from the original function.</p>
<p>If we apply a decorator like this one to multiple functions, all with different names, they
will all end up being called wrapped, which is a major concern (for example, if we want to
log or trace the function, this will make debugging even harder).</p>
<p>Another problem is that, in case we placed docstrings with tests on these functions, they
will be overridden by those of the decorator. As a result, the docstrings with the test we
want will not run when we call our code with the <code class="docutils literal notranslate"><span class="pre">doctest</span></code> module.</p>
<p>The fix is simple, though. We just have to apply the wraps decorator in the internal
function (<code class="docutils literal notranslate"><span class="pre">wrapped</span></code>), telling it that it is actually wrapping function :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trace_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;running </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now, if we check the properties, we will obtain what we expected in the first place.
Check help for the function, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Help</span> <span class="n">on</span> <span class="n">function</span> <span class="n">process_account</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">decorator_wraps_2</span><span class="p">:</span>
<span class="go">process_account(account_id)</span>
<span class="go">Process an account by Id.</span>
</pre></div>
</div>
<p>And verify that its qualified name is correct, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">process_account</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;process_account&#39;</span>
</pre></div>
</div>
<p>Most importantly, we recovered the unit tests we might have had on the docstrings! By
using the wraps decorator, we can also access the original, unmodified function under the
<code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> attribute. Although it should not be used in production, it might come in
handy in some unit tests when we want to check the unmodified version of the function.</p>
<p>In general, for simple decorators, the way we would use <code class="docutils literal notranslate"><span class="pre">functools.wraps</span></code> would
typically follow the general formula or structure:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">original_function</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">original_function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># modifications done by the decorator ...</span>
        <span class="k">return</span> <span class="n">original_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">return</span> <span class="n">decorated_function</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Always use <code class="docutils literal notranslate"><span class="pre">functools.wraps</span></code> applied over the wrapped function, when creating a decorator, as shown in the preceding formula.</p>
</div>
</div>
<div class="section" id="dealing-with-side-effects-in-decorators">
<h2>2.2. Dealing with side-effects in decorators<a class="headerlink" href="#dealing-with-side-effects-in-decorators" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will learn that it is advisable to avoid side-effects in the body of the
decorator. There are cases where this might be acceptable, but the bottom line is that, if in
case of doubt, decide against it, for the reasons that are explained ahead. Everything that
the decorator needs to do aside from the function that it’s decorating should be placed in
the innermost function definition, or there will be problems when it comes to importing.</p>
<p>Nonetheless, sometimes these side-effects are required (or even desired) to run at import
time, and the obverse applies.</p>
<p>We will see examples of both, and where each one applies. If in doubt, err on the side of
caution, and delay all side-effects until the very latest, right after the <code class="docutils literal notranslate"><span class="pre">wrapped</span></code> function is
going to be called.</p>
<p>Next, we will see when it’s not a good idea to place extra logic outside the <code class="docutils literal notranslate"><span class="pre">wrapped</span></code>
function.</p>
<div class="section" id="incorrect-handling-of-side-effects-in-a-decorator">
<h3>2.2.1. Incorrect handling of side-effects in a decorator<a class="headerlink" href="#incorrect-handling-of-side-effects-in-a-decorator" title="Permalink to this headline">¶</a></h3>
<p>Let’s imagine the case of a decorator that was created with the goal of logging when a
function started running and then logging its running time:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">traced_function_wrong</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;started execution of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;function </span><span class="si">%s</span><span class="s2"> took </span><span class="si">%.2f</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="n">function</span><span class="p">,</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now we will apply the decorator to a regular function, thinking that it will work just fine:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@traced_function_wrong</span>
<span class="k">def</span> <span class="nf">process_with_delay</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">callback</span><span class="p">()</span>
</pre></div>
</div>
<p>This decorator has a subtle, yet critical bug in it.
First, let’s import the function, call it several times, and see what happens:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decorator_side_effects_1</span> <span class="kn">import</span> <span class="n">process_with_delay</span>
<span class="go">INFO:started execution of &lt;function process_with_delay at 0x...&gt;</span>
</pre></div>
</div>
<p>Just by importing the function, we will notice that something’s amiss. The logging line
should not be there, because the function was not invoked.</p>
<p>Now, what happens if we run the function, and see how long it takes to run? Actually, we
would expect that calling the same function multiple times will give similar results:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">INFO:function &lt;function process_with_delay at 0x&gt; took 8.67s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">INFO:function &lt;function process_with_delay at 0x&gt; took 13.39s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">INFO:function &lt;function process_with_delay at 0x&gt; took 17.01s</span>
</pre></div>
</div>
<p>Every time we run the same function, it takes longer! At this point, you have probably
already noticed the (now obvious) error.</p>
<p>Remember the syntax for decorators. <code class="docutils literal notranslate"><span class="pre">&#64;traced_function_wrong</span></code> actually means the
following: <code class="docutils literal notranslate"><span class="pre">process_with_delay</span> <span class="pre">=</span> <span class="pre">traced_function_wrong(process_with_delay)</span></code>. And this will run when the
module is imported. Therefore, the time that is set in the
function will be the one at the time the module was imported. Successive calls will compute
the time difference from the running time until that original starting time. It will also log at
the wrong moment, and not when the function is actually called.</p>
<p>Luckily, the fix is also very simple: we just have to move the code inside the wrapped
function in order to delay its execution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">traced_function</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;started execution of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;function </span><span class="si">%s</span><span class="s2"> took </span><span class="si">%.2f</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>With this new version, the previous problems are resolved.</p>
<p>If the actions of the decorator had been different, the results could have been much more
disastrous. For instance, if it requires that you log events and send them to an external
service, it will certainly fail unless the configuration has been run right before this has been
imported, which we cannot guarantee. Even if we could, it would be bad practice. The
same applies if the decorator has any other sort of side-effect, such as reading from a file,
parsing a configuration, and many more.</p>
</div>
<div class="section" id="requiring-decorators-with-side-effects">
<h3>2.2.2. Requiring decorators with side-effects<a class="headerlink" href="#requiring-decorators-with-side-effects" title="Permalink to this headline">¶</a></h3>
<p>Sometimes, side-effects on decorators are necessary, and we should not delay their
execution until the very last possible time, because that’s part of the mechanism which is
required for them to work.</p>
<p>One common scenario for when we don’t want to delay the side-effect of decorators is
when we need to register objects to a public registry that will be available in the module.</p>
<p>For instance, going back to our previous event system example, we now want to only
make some events available in the module, but not all of them. In the hierarchy of events,
we might want to have some intermediate classes that are not actual events we want to
process on the system, but some of their derivative classes instead.</p>
<p>Instead of flagging each class based on whether it’s going to be processed or not, we could
explicitly register each class through a decorator.</p>
<p>In this case, we have a class for all events that relate to the activities of a user. However, this
is just an intermediate table for the types of event we actually want, namely
<code class="docutils literal notranslate"><span class="pre">UserLoginEvent</span></code> and <code class="docutils literal notranslate"><span class="pre">UserLogoutEvent</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">EVENTS_REGISTRY</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">register_event</span><span class="p">(</span><span class="n">event_cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Place the class for the event into the registry to make it</span>
<span class="sd">    accessible in</span>
<span class="sd">    the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EVENTS_REGISTRY</span><span class="p">[</span><span class="n">event_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_cls</span>
    <span class="k">return</span> <span class="n">event_cls</span>

<span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A base event object&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">UserEvent</span><span class="p">:</span>
    <span class="n">TYPE</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

<span class="nd">@register_event</span>
<span class="k">class</span> <span class="nc">UserLoginEvent</span><span class="p">(</span><span class="n">UserEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the event of a user when it has just accessed the</span>
<span class="sd">    system.&quot;&quot;&quot;</span>

<span class="nd">@register_event</span>
<span class="k">class</span> <span class="nc">UserLogoutEvent</span><span class="p">(</span><span class="n">UserEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Event triggered right after a user abandoned the system.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>When we look at the preceding code, it seems that <code class="docutils literal notranslate"><span class="pre">EVENTS_REGISTRY</span></code> is empty, but after
importing something from this module, it will get populated with all of the classes that are
under the register_event decorator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decorator_side_effects_2</span> <span class="kn">import</span> <span class="n">EVENTS_REGISTRY</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EVENTS_REGISTRY</span>
<span class="go">{&#39;UserLoginEvent&#39;: decorator_side_effects_2.UserLoginEvent,</span>
<span class="go">&#39;UserLogoutEvent&#39;: decorator_side_effects_2.UserLogoutEvent}</span>
</pre></div>
</div>
<p>This might seem like it’s hard to read, or even misleading, because <code class="docutils literal notranslate"><span class="pre">EVENTS_REGISTRY</span></code> will
have its final value at runtime, right after the module was imported, and we cannot easily
predict its value by just looking at the code.</p>
<p>While that is true, in some cases this pattern is justified. In fact, many web frameworks or
well-known libraries use this to work and expose objects or make them available.</p>
<p>It is also true that in this case, the decorator is not changing the wrapped object, nor altering
the way it works in any way. However, the important note here is that, if we were to do
some modifications and define an internal function that modifies the wrapped object, we
would still probably want the code that registers the resulting object outside it.</p>
<p>Notice the use of the word outside. It does not necessarily mean before, it’s just not part of
the same closure; but it’s in the outer scope, so it’s not delayed until runtime.</p>
</div>
</div>
<div class="section" id="creating-decorators-that-will-always-work">
<h2>2.3. Creating decorators that will always work<a class="headerlink" href="#creating-decorators-that-will-always-work" title="Permalink to this headline">¶</a></h2>
<p>There are several different scenarios to which decorators might apply. It can also be the
case that we need to use the same decorator for objects that fall into these different multiple
scenarios, for instance, if we want to reuse our decorator and apply it to a function, a class,
a method, or a static method.</p>
<p>If we create the decorator, just thinking about supporting only the first type of object we
want to decorate, we might notice that the same decorator does not work equally well on a
different type of object. The typical example is where we create a decorator to be used on a
function, and then we want to apply it to a method of a class, only to realize that it does not
work. A similar scenario might occur if we designed our decorator for a method, and then
we want it to also apply for static methods or class methods.</p>
<p>When designing decorators, we typically think about reusing code, so we will want to use
that decorator for functions and methods as well.</p>
<p>Defining our decorators with the signature <code class="docutils literal notranslate"><span class="pre">*args</span></code>, and <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>, will make them work in
all cases, because it’s the most generic kind of signature that we can have. However,
sometimes we might want not to use this, and instead define the decorator wrapping
function according to the signature of the original function, mainly because of two reasons:</p>
<ul class="simple">
<li><p>It will be more readable since it resembles the original function.</p></li>
<li><p>It actually needs to do something with the arguments, so receiving <code class="docutils literal notranslate"><span class="pre">*args</span></code> and <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> wouldn’t be convenient.</p></li>
</ul>
<p>Consider the case on which we have many functions in our code base that require a
particular object to be created from a parameter. For instance, we pass a string, and
initialize a driver object with it, repeatedly. Then we think we can remove the duplication
by using a decorator that will take care of converting this parameter accordingly.</p>
<p>In the next example, we pretend that <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code> is an object that knows how to connect and
run operations on a database, but it needs a connection string. The methods we have in our
code, are designed to receive a string with the information of the database and require to
create an instance of <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code> always. The idea of the decorator is that it’s going to take
place of this conversion automatically: the function will continue to receive a string, but
the decorator will create a <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code> and pass it to the function, so internally we can
assume that we receive the object we need directly.</p>
<p>An example of using this in a function is shown in the next listing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBDriver</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbstring</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dbstring</span> <span class="o">=</span> <span class="n">dbstring</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;query </span><span class="si">{query}</span><span class="s2"> at </span><span class="si">{self.dbstring}</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">inject_db_driver</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This decorator converts the parameter by creating a ``DBDriver``</span>
<span class="sd">    instance from the database dsn string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">dbstring</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">DBDriver</span><span class="p">(</span><span class="n">dbstring</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">wrapped</span>

<span class="nd">@inject_db_driver</span>
<span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">driver</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;test_function&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s easy to verify that if we pass a string to the function, we get the result done by an
instance of <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code>, so the decorator works as expected:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;test_OK&quot;</span><span class="p">)</span>
<span class="go">&#39;query test_function at test_OK&#39;</span>
</pre></div>
</div>
<p>But now, we want to reuse this same decorator in a class method, where we find the same
problem:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataHandler</span><span class="p">:</span>
    <span class="nd">@inject_db_driver</span>
    <span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">driver</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>We try to use this decorator, only to realize that it doesn’t work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">DataHandler</span><span class="p">()</span><span class="o">.</span><span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;test_fails&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">wrapped() takes 1 positional argument but 2 were given</span>
</pre></div>
</div>
<p>What is the problem? The method in the class is defined with an extra argument: <code class="docutils literal notranslate"><span class="pre">self</span></code>. Methods are just a
particular kind of function that receives self (the object they’re defined upon) as the first parameter.</p>
<p>Therefore, in this case, the decorator (designed to work with only one parameter, named
<code class="docutils literal notranslate"><span class="pre">dbstring</span></code>), will interpret that self is said parameter, and call the method passing the
string in the place of self, and nothing in the place for the second parameter, namely the
string we are passing.</p>
<p>To fix this issue, we need to create a decorator that will work equally for methods and
functions, and we do so by defining this as a decorator object, that also implements the
protocol descriptor.</p>
<p>The solution is to implement the decorator as a class object and make this object a
description, by implementing the <code class="docutils literal notranslate"><span class="pre">__get__</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>

<span class="k">class</span> <span class="nc">inject_db_driver</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert a string to a DBDriver instance and pass this to the</span>
<span class="sd">    wrapped function.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbstring</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">DBDriver</span><span class="p">(</span><span class="n">dbstring</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
</pre></div>
</div>
<p>For now, we can say that what this decorator does is
actually rebinding the callable it’s decorating to a method, meaning that it will bind the
function to the object, and then recreate the decorator with this new callable.</p>
<p>For functions, it still works, because it won’t call the <code class="docutils literal notranslate"><span class="pre">__get__</span></code> method at all.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>