

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Using generators &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Unit testing and refactoring" href="../8_unit_testing/index.html" />
    <link rel="prev" title="Getting more out of our objects with descriptors" href="../6_descriptors/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                24/02/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1_docstrings_and_annotations/index.html">Docstrings and annotations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_solid_principles/index.html">The SOLID principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5_decorators/index.html">Using decorators to improve our code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_descriptors/index.html">Getting more out of our objects with descriptors</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using generators</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-generators">1. Creating generators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-first-look-at-generators">1.1. A first look at generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generator-expressions">1.2. Generator expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#iterating-idiomatically">2. Iterating idiomatically</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#idioms-for-iteration">2.1. Idioms for iteration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-next-function">2.1.1. The next() function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-a-generator">2.1.2. Using a generator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#itertools">2.1.3. Itertools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simplifying-code-through-iterators">2.1.4. Simplifying code through iterators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-iterator-pattern-in-python">2.2. The iterator pattern in Python</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-interface-for-iteration">2.2.1. The interface for iteration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sequence-objects-as-iterables">2.2.2. Sequence objects as iterables</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#coroutines">3. Coroutines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-methods-of-the-generator-interface">3.1. The methods of the generator interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#close">3.1.1. close()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#throw-ex-type-ex-value-ex-traceback">3.1.2. throw(ex_type[, ex_value[, ex_traceback]])</a></li>
<li class="toctree-l4"><a class="reference internal" href="#send-value">3.1.3. send(value)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#more-advanced-coroutines">3.2. More advanced coroutines</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#returning-values-in-coroutines">3.2.1. Returning values in coroutines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#delegating-into-smaller-coroutines-the-yield-from-syntax">3.2.2. Delegating into smaller coroutines: the yield from syntax</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#asynchronous-programming">4. Asynchronous programming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8_unit_testing/index.html">Unit testing and refactoring</a></li>
<li class="toctree-l1"><a class="reference internal" href="../9_design_patterns/index.html">Common design patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_clean_architecture/index.html">Clean architecture</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>Using generators</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/chapters/7_generators/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="../8_unit_testing/index.html" class="btn btn-neutral float-right" title="Unit testing and refactoring" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../6_descriptors/index.html" class="btn btn-neutral float-left" title="Getting more out of our objects with descriptors" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="using-generators">
<h1>Using generators<a class="headerlink" href="#using-generators" title="Permalink to this headline">¶</a></h1>
<div class="section" id="creating-generators">
<h2>1. Creating generators<a class="headerlink" href="#creating-generators" title="Permalink to this headline">¶</a></h2>
<p>Generators were introduced in Python a long time ago (PEP-255), with the idea of
introducing iteration in Python while improving the performance of the program (by using
less memory) at the same time.</p>
<p>The idea of a generator is to create an object that is iterable, and, while it’s being iterated,
will produce the elements it contains, one at a time. The main use of generators is to save
memory: instead of having a very large list of elements in memory, holding everything at
once, we have an object that knows how to produce each particular element, one at a time,
as they are required.</p>
<p>This feature enables lazy computations or heavyweight objects in memory, in a similar
manner to what other functional programming languages (Haskell, for instance) provide. It
would even be possible to work with infinite sequences because the lazy nature of
generators allows for such an option.</p>
<div class="section" id="a-first-look-at-generators">
<h3>1.1. A first look at generators<a class="headerlink" href="#a-first-look-at-generators" title="Permalink to this headline">¶</a></h3>
<p>Let’s start with an example. The problem at hand now is that we want to process a large list
of records and get some metrics and indicators over them. Given a large data set with
information about purchases, we want to process it in order to get the lowest sale, highest
sale, and the average price of a sale.</p>
<p>For the simplicity of this example, we will assume a CSV with only two fields, in the
following format:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">purchase_date</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">price</span><span class="o">&gt;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>We are going to create an object that receives all the purchases, and this will give us the
necessary metrics. We could get some of these values out of the box by simply using the
<code class="docutils literal notranslate"><span class="pre">min()</span></code> and <code class="docutils literal notranslate"><span class="pre">max()</span></code> built-in functions, but that would require iterating all of the purchases
more than once, so instead, we are using our custom object, which will get these values in a
single iteration.</p>
<p>The code that will get the numbers for us looks rather simple. It’s just an object with a
method that will process all prices in one go, and, at each step, will update the value of each
particular metric we are interested in. First, we will show the first implementation in the
following listing, and, later on (once we have seen more about iteration), we
will revisit this implementation and get a much better (and compact) version of it. For now,
we are settling on the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PurchasesStats</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">purchases</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">purchases</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">purchases</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_price</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_price</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_purchases_price</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_purchases</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">first_value</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">purchases</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no values provided&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_price</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_price</span> <span class="o">=</span> <span class="n">first_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_avg</span><span class="p">(</span><span class="n">first_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">purchase_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">purchases</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_min</span><span class="p">(</span><span class="n">purchase_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_max</span><span class="p">(</span><span class="n">purchase_value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_avg</span><span class="p">(</span><span class="n">purchase_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_update_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_price</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">min_price</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="nf">_update_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_price</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_price</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">avg_price</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_purchases_price</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_purchases</span>

    <span class="k">def</span> <span class="nf">_update_avg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_purchases_price</span> <span class="o">+=</span> <span class="n">new_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_purchases</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self.__class__.__name__}</span><span class="s2">(</span><span class="si">{self.min_price}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self.max_price}</span><span class="s2">, </span><span class="si">{self.avg_price}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
</pre></div>
</div>
<p>This object will receive all the totals for the <code class="docutils literal notranslate"><span class="pre">purchases</span></code> and process the required values.
Now, we need a function that loads these numbers into something that this object can
process. Here is the first version:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_load_purchases</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">purchases</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">price_raw</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="n">purchases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">price_raw</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">purchases</span>
</pre></div>
</div>
<p>This code works; it loads all the numbers of the file into a list that, when passed to our
custom object, will produce the numbers we want. It has a performance issue, though. If
you run it with a rather large dataset, it will take a while to complete, and it might even fail
if the dataset is large enough as to not fit into the main memory.</p>
<p>If we take a look at our code that consumes this data, it is processing the <code class="docutils literal notranslate"><span class="pre">purchases</span></code>, one at
a time, so we might be wondering why our producer fits everything in memory at once. It
is creating a list where it puts all of the content of the file, but we know we can do better.</p>
<p>The solution is to create a generator. Instead of loading the entire content of the file in a list,
we will produce the results one at a time. The code will now look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_purchases</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">price_raw</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="k">yield</span> <span class="nb">float</span><span class="p">(</span><span class="n">price_raw</span><span class="p">)</span>
</pre></div>
</div>
<p>If you measure the process this time, you will notice that the usage of memory has dropped
significantly. We can also see how the code looks simpler: there is no need to define the
list (therefore, there is no need to append to it), and that the return statement also
disappeared.</p>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">load_purchases</span></code> function is a generator function, or simply a generator.</p>
<p>In Python, the mere presence of the keyword <code class="docutils literal notranslate"><span class="pre">yield</span></code> in any function makes it a generator,
and, as a result, when calling it, nothing other than creating an instance of the generator
will happen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">load_purchases</span><span class="p">(</span><span class="s2">&quot;file&quot;</span><span class="p">)</span>
<span class="go">&lt;generator object load_purchases at 0x...&gt;</span>
</pre></div>
</div>
<p>A generator object is an iterable (we will revisit iterables in more detail later on), which
means that it can work with for loops. Notice how we did not have to change anything on
the consumer code: our statistics processor remained the same, with the for loop
unmodified, after the new implementation.</p>
<p>Working with iterables allows us to create these kinds of powerful abstractions that are
polymorphic with respect to for loops. As long as we keep the iterable interface, we can
iterate over that object transparently.</p>
</div>
<div class="section" id="generator-expressions">
<h3>1.2. Generator expressions<a class="headerlink" href="#generator-expressions" title="Permalink to this headline">¶</a></h3>
<p>Generators save a lot of memory, and since they are iterators, they are a convenient
alternative to other iterables or containers that require more space in memory such as lists,
tuples, or sets.</p>
<p>Much like these data structures, they can also be defined by comprehension, only that it is
called a generator expression (there is an ongoing argument about whether they should be
called generator comprehensions).</p>
<p>In the same way, we would define a list comprehension. If we replace the square brackets
with parenthesis, we get a generator that results from the expression. Generator
expressions can also be passed directly to functions that work with iterables, such as <code class="docutils literal notranslate"><span class="pre">sum()</span></code>,
and, <code class="docutils literal notranslate"><span class="pre">max()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="go">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x...&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="go">285</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Always pass a generator expression, instead of a list comprehension, to functions that expect iterables, such as <code class="docutils literal notranslate"><span class="pre">min()</span></code>, <code class="docutils literal notranslate"><span class="pre">max()</span></code>, and <code class="docutils literal notranslate"><span class="pre">sum()</span></code>. This is more efficient and pythonic.</p>
</div>
<p>It is also worth mentioning, that we can only iterate 1 time over generators:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x7f95ece4dad0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="iterating-idiomatically">
<h2>2. Iterating idiomatically<a class="headerlink" href="#iterating-idiomatically" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will first explore some idioms that come in handy when we have to deal
with iteration in Python. These code recipes will help us get a better idea of the types of
things we can do with generators (especially after we have already seen generator
expressions), and how to solve typical problems in relation to them.</p>
<p>Once we have seen some idioms, we will move on to exploring iteration in Python in more
depth, analyzing the methods that make iteration possible, and how iterable objects work.</p>
<div class="section" id="idioms-for-iteration">
<h3>2.1. Idioms for iteration<a class="headerlink" href="#idioms-for-iteration" title="Permalink to this headline">¶</a></h3>
<p>We are already familiar with the built-in <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code> function that, given an iterable, will
return another one on which the element is a tuple, whose first element is the enumeration
of the second one (corresponding to the element in the original iterable):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;), (3, &#39;d&#39;), (4, &#39;e&#39;), (5, &#39;f&#39;)]</span>
</pre></div>
</div>
<p>We wish to create a similar object, but in a more low-level fashion; one that can simply
create an infinite sequence. We want an object that can produce a sequence of numbers,
from a starting one, without any limits.</p>
<p>An object as simple as the following one can do the trick. Every time we call this object, we
get the next number of the sequence <em>ad infinitum</em>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NumberSequence</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">start</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">current</span>
</pre></div>
</div>
<p>Based on this interface, we would have to use this object by explicitly invoking its next()
method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">NumberSequence</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq2</span> <span class="o">=</span> <span class="n">NumberSequence</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq2</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq2</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="go">11</span>
</pre></div>
</div>
<p>But with this code, we cannot reconstruct the <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code> function as we would like to,
because its interface does not support being iterated over a regular Python for loop, which
also means that we cannot pass it as a parameter to functions that expect something to
iterate over. Notice how the following code fails:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; list(zip(NumberSequence(), &quot;abcdef&quot;))
Traceback (most recent call last):
File &quot;...&quot;, line 1, in &lt;module&gt;
TypeError: zip argument #1 must support iteration
</pre></div>
</div>
<p>The problem lies in the fact that <code class="docutils literal notranslate"><span class="pre">NumberSequence</span></code> does not support iteration. To fix this,
we have to make the object an iterable by implementing the magic
method <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code>. We have also changed the previous <code class="docutils literal notranslate"><span class="pre">next()</span></code> method, by using the
magic method <code class="docutils literal notranslate"><span class="pre">__next__</span></code>, which makes the object an iterator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SequenceOfNumbers</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">start</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">current</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
</pre></div>
</div>
<p>This has an advantage: not only can we iterate over the element, we also don’t even need
the <code class="docutils literal notranslate"><span class="pre">next()</span></code> method any more because having <code class="docutils literal notranslate"><span class="pre">__next__()</span></code> allows us to use the
<code class="docutils literal notranslate"><span class="pre">next()</span></code> built-in function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">SequenceOfNumbers</span><span class="p">(),</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;), (3, &#39;d&#39;), (4, &#39;e&#39;), (5, &#39;f&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">SequenceOfNumbers</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">101</span>
</pre></div>
</div>
<div class="section" id="the-next-function">
<h4>2.1.1. The next() function<a class="headerlink" href="#the-next-function" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">next()</span></code> built-in function will advance the iterable to its next element and return it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">word</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
<span class="go">&#39;h&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
<span class="go">&#39;e&#39;</span>
</pre></div>
</div>
<p>If the iterator does not have more elements to produce, the <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception is
raised:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; ...
&gt;&gt;&gt; next(word)
&#39;o&#39;
&gt;&gt;&gt; next(word)
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
</pre></div>
</div>
<p>This exception signals that the iteration is over and that there are no more elements to
consume.</p>
<p>If we wish to handle this case, besides catching the <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception, we could
provide this function with a default value in its second parameter. Should this be provided,
it will be the return value in lieu of throwing <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;default value&quot;</span><span class="p">)</span>
<span class="go">&#39;default value&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="using-a-generator">
<h4>2.1.2. Using a generator<a class="headerlink" href="#using-a-generator" title="Permalink to this headline">¶</a></h4>
<p>The previous code can be simplified significantly by simply using a generator. Generator
objects are iterators. This way, instead of creating a class, we can define a function that
<code class="docutils literal notranslate"><span class="pre">yield</span></code> the values as needed:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Remember that from our first definition, the <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword in the body of the function
makes it a generator. Because it is a generator, it’s perfectly fine to create an infinite loop
like this, because, when this generator function is called, it will run all the code until the
next <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement is reached. It will produce its value and suspend there:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
<span class="go">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">sequence</span><span class="p">(),</span> <span class="s2">&quot;abcdef&quot;</span><span class="p">))</span>
<span class="go">[(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;), (3, &#39;d&#39;), (4, &#39;e&#39;), (5, &#39;f&#39;)]</span>
</pre></div>
</div>
</div>
<div class="section" id="itertools">
<h4>2.1.3. Itertools<a class="headerlink" href="#itertools" title="Permalink to this headline">¶</a></h4>
<p>Working with iterables has the advantage that the code blends better with Python itself
because iteration is a key component of the language. Besides that, we can take full
advantage of the itertools module. Actually, the <code class="docutils literal notranslate"><span class="pre">sequence()</span></code> generator we
just created is fairly similar to <code class="docutils literal notranslate"><span class="pre">itertools.count()</span></code>. However, there is more we can do.</p>
<p>One of the nicest things about iterators, generators, and itertools, is that they are
composable objects that can be chained together.</p>
<p>For instance, getting back to our first example that processed purchases in order to get
some metrics, what if we want to do the same, but only for those values over a certain
threshold? The naive approach of solving this problem would be to place the condition
while iterating:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">purchase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">purchases</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">purchase</span> <span class="o">&gt;</span> <span class="mf">1000.0</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>This is not only non-Pythonic, but it’s also rigid (and rigidity is a trait that denotes bad
code). It doesn’t handle changes very well. What if the number changes now? Do we pass it
by parameter? What if we need more than one? What if the condition is different (less than,
for instance)? Do we pass a lambda?</p>
<p>These questions should not be answered by this object, whose sole responsibility is to
compute a set of well-defined metrics over a stream of purchases represented as numbers.
And, of course, the answer is no. It would be a huge mistake to make such a change (once
again, clean code is flexible, and we don’t want to make it rigid by coupling this object to
external factors). These requirements will have to be addressed elsewhere.</p>
<p>It’s better to keep this object independent of its clients. The less responsibility this class has,
the more useful it will be for more clients, hence enhancing its chances of being reused.</p>
<p>Instead of changing this code, we’re going to keep it as it is and assume that the new data is
filtered according to whatever requirements each customer of the class has.</p>
<p>For instance, if we wanted to process only the first 10 purchases that amount to more than
1,000, we would do the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">purchases</span> <span class="o">=</span> <span class="n">islice</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mf">1000.0</span><span class="p">,</span> <span class="n">purchases</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stats</span> <span class="o">=</span> <span class="n">PurchasesStats</span><span class="p">(</span><span class="n">purchases</span><span class="p">)</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>
</pre></div>
</div>
<p>There is no memory penalization for filtering this way because since they all are generators,
the evaluation is always lazy. This gives us the power of thinking as if we had filtered the
entire set at once and then passed it to the object, but without actually fitting everything in
memory.</p>
</div>
<div class="section" id="simplifying-code-through-iterators">
<h4>2.1.4. Simplifying code through iterators<a class="headerlink" href="#simplifying-code-through-iterators" title="Permalink to this headline">¶</a></h4>
<p>Now, we will briefly discuss some situations that can be improved with the help of
iterators, and occasionally the itertools module. After discussing each case, and its
proposed optimization, we will close each point with a corollary.</p>
<div class="section" id="repeated-iterations">
<h5>2.1.4.1. Repeated iterations<a class="headerlink" href="#repeated-iterations" title="Permalink to this headline">¶</a></h5>
<p>Now that we have seen more about iterators, and introduced the itertools module, we
can show you how one of the first examples of this chapter (the one for computing statistics
about some purchases), can be dramatically simplified:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_purchases</span><span class="p">(</span><span class="n">purchases</span><span class="p">):</span>
    <span class="n">min_iter</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">avg_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">tee</span><span class="p">(</span><span class="n">purchases</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_iter</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_iter</span><span class="p">),</span> <span class="n">median</span><span class="p">(</span><span class="n">avg_iter</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example, <code class="docutils literal notranslate"><span class="pre">itertools.tee</span></code> will split the original iterable into three new ones. We
will use each of these for the different kinds of iterations that we require, without needing
to repeat three different loops over purchases.</p>
<p>The reader can simply verify that if we pass an iterable object as the purchases parameter,
this one is traversed only once (thanks to the itertools.tee function),
which was our main requirement. It is also possible to verify how this version is equivalent
to our original implementation. In this case, there is no need to manually raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>
because passing an empty sequence to the <code class="docutils literal notranslate"><span class="pre">min()</span></code> function will do the same.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are thinking about running a loop over the same object more than
one time, stop and think if itertools.tee can be of any help.</p>
</div>
</div>
<div class="section" id="nested-loops">
<h5>2.1.4.2. Nested loops<a class="headerlink" href="#nested-loops" title="Permalink to this headline">¶</a></h5>
<p>In some situations, we need to iterate over more than one dimension, looking for a value,
and nested loops come as the first idea. When the value is found, we need to stop iterating,
but the <code class="docutils literal notranslate"><span class="pre">break</span></code> keyword doesn’t work entirely because we have to escape from two (or
more) for loops, not just one.</p>
<p>What would be the solution for this? A flag signaling escape? No. Raising an exception?
No, this would be the same as the flag, but even worse because we know that exceptions
are not to be used for control flow logic. Moving the code to a smaller function and return
it? Close, but not quite.</p>
<p>The answer is, whenever possible, flat the iteration to a single for loop.
This is the kind of code we would like to avoid:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search_nested_bad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">desired_value</span><span class="p">):</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{desired_value}</span><span class="s2"> not found&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;value </span><span class="si">%r</span><span class="s2"> found at [</span><span class="si">%i</span><span class="s2">, </span><span class="si">%i</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">desired_value</span><span class="p">,</span> <span class="o">*</span><span class="n">coords</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coords</span>
</pre></div>
</div>
<p>And here is a simplified version of it that does not rely on flags to signal termination, and
has a simpler, more compact structure of iteration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_iterate_array2d</span><span class="p">(</span><span class="n">array2d</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array2d</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">cell</span>

<span class="k">def</span> <span class="nf">search_nested</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">desired_value</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">coord</span> <span class="k">for</span> <span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_iterate_array2d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="n">desired_value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{desired_value}</span><span class="s2"> not found&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;value </span><span class="si">{desired_value}</span><span class="s2"> found at </span><span class="si">{coords}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coord</span>
</pre></div>
</div>
<p>It’s worth mentioning how the auxiliary generator that was created works as an abstraction
for the iteration that’s required. In this case, we just need to iterate over two dimensions,
but if we needed more, a different object could handle this without the client needing to
know about it. This is the essence of the iterator design pattern, which, in Python, is
transparent, since it supports iterator objects automatically, which is the topic covered in
the next section.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Try to simplify the iteration as much as possible with as many abstractions as are required, flatting the
loops whenever possible.</p>
</div>
</div>
</div>
</div>
<div class="section" id="the-iterator-pattern-in-python">
<h3>2.2. The iterator pattern in Python<a class="headerlink" href="#the-iterator-pattern-in-python" title="Permalink to this headline">¶</a></h3>
<p>Here, we will take a small detour from generators to understand iteration in Python more
deeply. Generators are a particular case of iterable objects, but iteration in Python goes
beyond generators, and being able to create good iterable objects will give us the chance to
create more efficient, compact, and readable code.</p>
<p>In the previous code listings, we have been seeing examples of iterable objects that are
also iterators, because they implement both the <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> and <code class="docutils literal notranslate"><span class="pre">__next__()</span></code> magic
methods. While this is fine in general, it’s not strictly required that they always have to
implement both methods, and here we’ll show the subtle differences between
an iterable object (one that implements <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>) and an iterator (that
implements <code class="docutils literal notranslate"><span class="pre">__next__</span></code>).</p>
<p>We also explore other topics related to iterations, such as sequences and container objects.</p>
<div class="section" id="the-interface-for-iteration">
<h4>2.2.1. The interface for iteration<a class="headerlink" href="#the-interface-for-iteration" title="Permalink to this headline">¶</a></h4>
<p>An iterable is an object that supports iteration, which, at a very high level, means that we
can run a <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">..</span> <span class="pre">in</span> <span class="pre">...</span></code> loop over it, and it will work without any issues. However, iterable does not mean
the same as iterator.</p>
<p>Generally speaking, an iterable is just something we can iterate, and it uses an iterator to do
so. This means that in the <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> magic method, we would like to return an iterator,
namely, an object with a <code class="docutils literal notranslate"><span class="pre">__next__()</span></code> method implemented.</p>
<p>An iterator is an object that only knows how to produce a series of values, one at a time,
when it’s being called by the already explored built-in <code class="docutils literal notranslate"><span class="pre">next()</span></code> function. While the iterator
is not called, it’s simply frozen, sitting idly by until it’s called again for the next value to
produce. In this sense, generators are iterators.</p>
<p>In the following code, we will see an example of an iterator object that is not iterable: it
only supports invoking its values, one at a time. Here, the name sequence refers just to a
series of consecutive numbers, not to the sequence concept in Python, which will we
explore later on:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SequenceIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span>
        <span class="k">return</span> <span class="n">value</span>
</pre></div>
</div>
<p>Notice that we can get the values of the sequence one at a time, but we can’t iterate over this
object (this is fortunate because it would otherwise result in an endless loop):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">si</span> <span class="o">=</span> <span class="n">SequenceIterator</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">SequenceIterator</span><span class="p">():</span> <span class="k">pass</span>
<span class="gp">...</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;SequenceIterator&#39; object is not iterable</span>
</pre></div>
</div>
<p>The error message is clear, as the object doesn’t implement <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code>.</p>
<p>Just for explanatory purposes, we can separate the iteration in another object (again, it
would be enough to make the object implement both <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> and <code class="docutils literal notranslate"><span class="pre">__next__</span></code>, but doing
so separately will help clarify the distinctive point we’re trying to make in this explanation).</p>
</div>
<div class="section" id="sequence-objects-as-iterables">
<h4>2.2.2. Sequence objects as iterables<a class="headerlink" href="#sequence-objects-as-iterables" title="Permalink to this headline">¶</a></h4>
<p>As we have just seen, if an object implements the <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> magic method, it means it
can be used in a for loop. While this is a great feature, it’s not the only possible form of
iteration we can achieve. When we write a for loop, Python will try to see if the object
we’re using implements <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>, and, if it does, it will use that to construct the iteration,
but if it doesn’t, there are fallback options.</p>
<p>If the object happens to be a sequence (meaning that it implements <code class="docutils literal notranslate"><span class="pre">__getitem__()</span></code>
and <code class="docutils literal notranslate"><span class="pre">__len__()</span></code> magic methods), it can also be iterated. If that is the case, the interpreter
will then provide values in sequence, until the <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> exception is raised, which,
analogous to the aforementioned <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code>, also signals the stop for the iteration.</p>
<p>With the sole purpose of illustrating such a behavior, we run the following experiment that
shows a sequence object that implements <code class="docutils literal notranslate"><span class="pre">map()</span></code> over a range of numbers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MappedRange</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Apply a transformation to a range of numbers.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformation</span> <span class="o">=</span> <span class="n">transformation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformation</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index </span><span class="si">{index}</span><span class="s2">: </span><span class="si">{result}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="p">)</span>
</pre></div>
</div>
<p>Keep in mind that this example is only designed to illustrate that an object such as this one
can be iterated with a regular for loop. There is a logging line placed in the <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>
method to explore what values are passed while the object is being iterated, as we can see
from the following test:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span> <span class="o">=</span> <span class="n">MappedRange</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Index 0: 10</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Index -1: 4</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">mr</span><span class="p">)</span>
<span class="go">Index 0: 10</span>
<span class="go">Index 1: 9</span>
<span class="go">Index 2: 8</span>
<span class="go">Index 3: 7</span>
<span class="go">Index 4: 6</span>
<span class="go">Index 5: 5</span>
<span class="go">Index 6: 4</span>
<span class="go">Index 7: 3</span>
<span class="go">Index 8: 2</span>
<span class="go">Index 9: 1</span>
<span class="go">Index 10: 0</span>
<span class="go">Index 11: 1</span>
<span class="go">Index 12: 2</span>
<span class="go">Index 13: 3</span>
<span class="go">Index 14: 4</span>
<span class="go">[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>As a word of caution, it’s important to highlight that while it is useful to know this, it’s also
a fallback mechanism for when the object doesn’t implement <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>, so most of the time
we’ll want to resort to these methods by thinking in creating proper sequences, and not just
objects we want to iterate over.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When thinking about designing an object for iteration, favor a proper
iterable object (with <code class="docutils literal notranslate"><span class="pre">__iter__</span></code>), rather than a sequence that can
coincidentally also be iterated.</p>
</div>
</div>
</div>
</div>
<div class="section" id="coroutines">
<h2>3. Coroutines<a class="headerlink" href="#coroutines" title="Permalink to this headline">¶</a></h2>
<p>As we already know, generator objects are iterables. They implement <code class="docutils literal notranslate"><span class="pre">__iter__()</span></code> and
<code class="docutils literal notranslate"><span class="pre">__next__()</span></code>. This is provided by Python automatically so that when we create a generator
object function, we get an object that can be iterated or advanced through the <code class="docutils literal notranslate"><span class="pre">next()</span></code>
function.</p>
<p>Besides this basic functionality, they have more methods so that they can work as
coroutines. Here, we will explore how generators evolved into coroutines to
support the basis of asynchronous programming before we go into more detail in the next
section, where we explore the new features of Python and the syntax that covers
programming asynchronously. The basic methods added to support
coroutines are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.close()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.throw(ex_type[,</span> <span class="pre">ex_value[,</span> <span class="pre">ex_traceback]])</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.send(value)</span></code></p></li>
</ul>
<div class="section" id="the-methods-of-the-generator-interface">
<h3>3.1. The methods of the generator interface<a class="headerlink" href="#the-methods-of-the-generator-interface" title="Permalink to this headline">¶</a></h3>
<p>In this section, we will explore what each of the aforementioned methods does, how it
works, and how it is expected to be used. By understanding how to use these methods, we
will be able to make use of simple coroutines.</p>
<p>Later on, we will explore more advanced uses of coroutines, and how to delegate to sub-
generators (coroutines) in order to refactor code, and how to orchestrate different
coroutines.</p>
<div class="section" id="close">
<h4>3.1.1. close()<a class="headerlink" href="#close" title="Permalink to this headline">¶</a></h4>
<p>When calling this method, the generator will receive the <code class="docutils literal notranslate"><span class="pre">GeneratorExit</span></code> exception. If it’s
not handled, then the generator will finish without producing any more values, and its
iteration will stop.</p>
<p>This exception can be used to handle a finishing status. In general, if our coroutine does
some sort of resource management, we want to catch this exception and use that control
block to release all resources being held by the coroutine. In general, it is similar to using a
context manager or placing the code in the finally block of an exception control, but
handling this exception specifically makes it more explicit.</p>
<p>In the following example, we have a coroutine that makes use of a database handler object
that holds a connection to a database, and runs queries over it, streaming data by pages of a
fixed length (instead of reading everything that is available at once):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">stream_db_records</span><span class="p">(</span><span class="n">db_handler</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">db_handler</span><span class="o">.</span><span class="n">read_n_records</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
        <span class="n">db_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>At each call to the generator, it will return 10 rows obtained from the database handler, but
when we decide to explicitly finish the iteration and call <code class="docutils literal notranslate"><span class="pre">close()</span></code>, we also want to close the
connection to the database:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamer</span> <span class="o">=</span> <span class="n">stream_db_records</span><span class="p">(</span><span class="n">DBHandler</span><span class="p">(</span><span class="s2">&quot;testdb&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">streamer</span><span class="p">)</span>
<span class="go">[(0, &#39;row 0&#39;), (1, &#39;row 1&#39;), (2, &#39;row 2&#39;), (3, &#39;row 3&#39;), ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">streamer</span><span class="p">)</span>
<span class="go">[(0, &#39;row 0&#39;), (1, &#39;row 1&#39;), (2, &#39;row 2&#39;), (3, &#39;row 3&#39;), ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="go">INFO:...:closing connection to database &#39;testdb&#39;</span>
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">close()</span></code> method on generators to perform finishing-up tasks
when needed.</p>
</div>
<div class="section" id="throw-ex-type-ex-value-ex-traceback">
<h4>3.1.2. throw(ex_type[, ex_value[, ex_traceback]])<a class="headerlink" href="#throw-ex-type-ex-value-ex-traceback" title="Permalink to this headline">¶</a></h4>
<p>This method will throw the exception at the line where the generator is currently
suspended. If the generator handles the exception that was sent, the code in that
particular except clause will be called, otherwise, the exception will propagate to the
caller.</p>
<p>Here, we are modifying the previous example slightly to show the difference when we use
this method for an exception that is handled by the coroutine, and when it’s not:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">stream_data</span><span class="p">(</span><span class="n">db_handler</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">db_handler</span><span class="o">.</span><span class="n">read_n_records</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">CustomException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;controlled error </span><span class="si">{e}</span><span class="s2">, continuing&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unhandled error </span><span class="si">{e}</span><span class="s2">, stopping&quot;</span><span class="p">)</span>
            <span class="n">db_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>Now, it is a part of the control flow to receive a <code class="docutils literal notranslate"><span class="pre">CustomException</span></code>, and, in such a case, the
generator will log an informative message (of course, we can adapt this according to our
business logic on each case), and move on to the next <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement, which is the line
where the coroutine reads from the database and returns that data.</p>
<p>This particular example handles all exceptions, but if the last block (<code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">Exception:</span></code>)
wasn’t there, the result would be that the generator is raised at the line where the generator
is paused (again, the <code class="docutils literal notranslate"><span class="pre">yield</span></code>), and it will propagate from there to the caller:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">streamer</span> <span class="o">=</span> <span class="n">stream_data</span><span class="p">(</span><span class="n">DBHandler</span><span class="p">(</span><span class="s2">&quot;testdb&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">streamer</span><span class="p">)</span>
<span class="go">[(0, &#39;row 0&#39;), (1, &#39;row 1&#39;), (2, &#39;row 2&#39;), (3, &#39;row 3&#39;), (4, &#39;row 4&#39;), ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">streamer</span><span class="p">)</span>
<span class="go">[(0, &#39;row 0&#39;), (1, &#39;row 1&#39;), (2, &#39;row 2&#39;), (3, &#39;row 3&#39;), (4, &#39;row 4&#39;), ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamer</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">CustomException</span><span class="p">)</span>
<span class="go">WARNING:controlled error CustomException(), continuing</span>
<span class="go">[(0, &#39;row 0&#39;), (1, &#39;row 1&#39;), (2, &#39;row 2&#39;), (3, &#39;row 3&#39;), (4, &#39;row 4&#39;), ...]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">streamer</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">)</span>
<span class="go">ERROR:unhandled error RuntimeError(), stopping</span>
<span class="go">INFO:closing connection to database &#39;testdb&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">StopIteration</span>
</pre></div>
</div>
<p>When our exception from the domain was received, the generator continued. However,
when it received another exception that was not expected, the default block caught where
we closed the connection to the database and finished the iteration, which resulted in the
generator being stopped. As we can see from the <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> that was raised, this
generator can’t be iterated further.</p>
</div>
<div class="section" id="send-value">
<h4>3.1.3. send(value)<a class="headerlink" href="#send-value" title="Permalink to this headline">¶</a></h4>
<p>In the previous example, we created a simple generator that reads rows from a database,
and when we wished to finish its iteration, this generator released the resources linked to
the database. This is a good example of using one of the methods that generators provide
(<code class="docutils literal notranslate"><span class="pre">close</span></code>), but there is more we can do.</p>
<p>An obvious of such a generator is that it was reading a fixed number of rows from the
database.</p>
<p>We would like to parametrize that number so that we can change it throughout
different calls. Unfortunately, the <code class="docutils literal notranslate"><span class="pre">next()</span></code> function does not provide us with options for
that. But luckily, we have <code class="docutils literal notranslate"><span class="pre">send()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">stream_db_records</span><span class="p">(</span><span class="n">db_handler</span><span class="p">):</span>
    <span class="n">retrieved_data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">previous_page_size</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">page_size</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">retrieved_data</span>
            <span class="k">if</span> <span class="n">page_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">page_size</span> <span class="o">=</span> <span class="n">previous_page_size</span>

            <span class="n">previous_page_size</span> <span class="o">=</span> <span class="n">page_size</span>
            <span class="n">retrieved_data</span> <span class="o">=</span> <span class="n">db_handler</span><span class="o">.</span><span class="n">read_n_records</span><span class="p">(</span><span class="n">page_size</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
        <span class="n">db_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The idea is that we have now made the coroutine able to receive values from the caller by
means of the <code class="docutils literal notranslate"><span class="pre">send()</span></code> method. This method is the one that actually distinguishes a
generator from a coroutine because when it’s used, it means that the <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword will
appear on the right-hand side of the statement, and its return value will be assigned to
something else.</p>
<p>In coroutines, we generally find the <code class="docutils literal notranslate"><span class="pre">yield</span></code> keyword to be used in the following form:
<code class="docutils literal notranslate"><span class="pre">receive</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">produced</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">yield</span></code>, in this case, will do two things. It will send <code class="docutils literal notranslate"><span class="pre">produced</span></code> back to the caller, which
will pick it up on the next round of iteration (after calling <code class="docutils literal notranslate"><span class="pre">next()</span></code>, for example), and it will
suspend there. At a later point, the caller will want to send a value back to the coroutine by
using the <code class="docutils literal notranslate"><span class="pre">send()</span></code> method. This value will become the result of the <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement,
assigned in this case to the variable named <code class="docutils literal notranslate"><span class="pre">receive</span></code>.</p>
<p>Sending values to the coroutine only works when this one is suspended at a <code class="docutils literal notranslate"><span class="pre">yield</span></code>
statement, waiting for something to produce. For this to happen, the coroutine will have to
be advanced to that status. The only way to do this is by calling <code class="docutils literal notranslate"><span class="pre">next()</span></code> on it. This means
that before sending anything to the coroutine, this has to be advanced at least once via the
<code class="docutils literal notranslate"><span class="pre">next()</span></code> method. Failure to do so will result in an exception:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">coro</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">can&#39;t send non-None value to a just-started generator</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Always remember to advance a coroutine by calling <code class="docutils literal notranslate"><span class="pre">next()</span></code> before sending any values to it.</p>
</div>
<p>Back to our example. We are changing the way elements are produced or streamed to make
it able to receive the length of the records it expects to read from the database.</p>
<p>The first time we call <code class="docutils literal notranslate"><span class="pre">next()</span></code>, the generator will advance up to the line containing <code class="docutils literal notranslate"><span class="pre">yield</span></code>; it
will provide a value to the caller (<code class="docutils literal notranslate"><span class="pre">None</span></code>, as set in the variable), and it will suspend there).</p>
<p>From here, we have two options. If we choose to advance the generator by calling <code class="docutils literal notranslate"><span class="pre">next()</span></code>,
the default value of 10 will be used, and it will go on with this as usual. This is because
<code class="docutils literal notranslate"><span class="pre">next()</span></code> is technically the same as <code class="docutils literal notranslate"><span class="pre">send(None)</span></code>, but this is covered in the if statement that
will handle the value that we previously set.</p>
<p>If, on the other hand, we decide to provide an explicit value via <code class="docutils literal notranslate"><span class="pre">send(&lt;value&gt;)</span></code>, this one
will become the result of the <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement, which will be assigned to the variable
containing the length of the page to use, which, in turn, will be used to read from the
database.</p>
<p>Successive calls will have this logic, but the important point is that now we can
dynamically change the length of the data to read in the middle of the iteration, at any
point.</p>
<p>Now that we understand how the previous code works, most Pythonistas would expect a
simplified version of it (after all, Python is also about brevity and clean and compact code):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">stream_db_records</span><span class="p">(</span><span class="n">db_handler</span><span class="p">):</span>
    <span class="n">retrieved_data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">page_size</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">page_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">retrieved_data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">page_size</span>
            <span class="n">retrieved_data</span> <span class="o">=</span> <span class="n">db_handler</span><span class="o">.</span><span class="n">read_n_records</span><span class="p">(</span><span class="n">page_size</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
        <span class="n">db_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This version is not only more compact, but it also illustrates the idea better. The parenthesis
around the <code class="docutils literal notranslate"><span class="pre">yield</span></code> makes it clearer that it’s a statement (think of it as if it were a function
call), and that we are using the result of it to compare it against the previous value.</p>
<p>This works as we expect it does, but we always have to remember to advance the coroutine
before sending any data to it. If we forget to call the first <code class="docutils literal notranslate"><span class="pre">next()</span></code>, we’ll get a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.
This call could be ignored for our purposes because it doesn’t return anything we’ll use.</p>
<p>It would be good if we could use the coroutine directly, right after it is created without
having to remember to call <code class="docutils literal notranslate"><span class="pre">next()</span></code> the first time, every time we are going to use it. Some
authors devised an interesting decorator to achieve this. The idea of this
decorator is to advance the coroutine, so the following definition works automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@prepare_coroutine</span>
<span class="k">def</span> <span class="nf">stream_db_records</span><span class="p">(</span><span class="n">db_handler</span><span class="p">):</span>
    <span class="n">retrieved_data</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">page_size</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">page_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">retrieved_data</span><span class="p">)</span> <span class="ow">or</span> <span class="n">page_size</span>
            <span class="n">retrieved_data</span> <span class="o">=</span> <span class="n">db_handler</span><span class="o">.</span><span class="n">read_n_records</span><span class="p">(</span><span class="n">page_size</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
    <span class="n">db_handler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">streamer</span> <span class="o">=</span> <span class="n">stream_db_records</span><span class="p">(</span><span class="n">DBHandler</span><span class="p">(</span><span class="s2">&quot;testdb&quot;</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">streamer</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="mi">5</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="more-advanced-coroutines">
<h3>3.2. More advanced coroutines<a class="headerlink" href="#more-advanced-coroutines" title="Permalink to this headline">¶</a></h3>
<p>So far, we have a better understanding of coroutines, and we are able to create simple ones
to handle small tasks. We can say that these coroutines are, in fact, just more advanced
generators (and that would be right, coroutines are just fancy generators), but, if we
actually want to start supporting more complex scenarios, we usually have to go for a
design that handles many coroutines concurrently, and that requires more features.</p>
<p>When handling many coroutines, we find new problems. As the control flow of our
application becomes more complex, we want to pass values up and down the stack (as well
as exceptions), be able to capture values from sub-coroutines we might call at any level, and
finally schedule multiple coroutines to run toward a common goal.</p>
<p>To make things simpler, generators had to be extended once again. This is addressed by changing the semantic
of generators so that they are able to return values, and introducing the new yield from construction.</p>
<div class="section" id="returning-values-in-coroutines">
<h4>3.2.1. Returning values in coroutines<a class="headerlink" href="#returning-values-in-coroutines" title="Permalink to this headline">¶</a></h4>
<p>As introduced at the beginning, the iteration is a mechanism that calls
<code class="docutils literal notranslate"><span class="pre">next()</span></code> on an iterable object many times until a <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception is raised.</p>
<p>So far, we have been exploring the iterative nature of generators: we produce values one at
a time, and, in general, we only care about each value as it’s being produced at every step of
the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. This is a very logical way of thinking about generators, but coroutines have a
different idea; even though they are technically generators, they weren’t conceived with the
idea of iteration in mind, but with the goal of suspending the execution of a code until it’s
resumed later on.</p>
<p>This is an interesting challenge; when we design a coroutine, we usually care more about
suspending the state rather than iterating (and iterating a coroutine would be an odd case).
The challenge lies in that it is easy to mix them both. This is because of a technical
implementation detail; the support for coroutines in Python was built upon generators.</p>
<p>If we want to use coroutines to process some information and suspend its execution, it
would make sense to think of them as lightweight threads (or green threads, as they are
called in other platforms). In such a case, it would make sense if they could return values,
much like calling any other regular function.</p>
<p>But let’s remember that generators are not regular functions, so in a generator, the
construction <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">generator()</span></code> will do nothing other than create a generator object.
What would be the semantics for making a generator return a value? It will have to be after
the iteration is done.</p>
<p>When a generator returns a value, its iteration is immediately stopped (it can’t be iterated
any further). To preserve the semantics, the <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception is still raised, and
the value to be returned is stored inside the exception object. It’s the responsibility of the
caller to catch it.</p>
<p>In the following example, we are creating a simple generator that produces two values
and then returns a third. Notice how we have to catch the exception in order to get this
value, and how it’s stored precisely inside the exception under the attribute named <code class="docutils literal notranslate"><span class="pre">value</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">yield</span> <span class="mi">2</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="mi">3</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">value</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">next</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&gt;&gt;&gt;&gt;&gt;&gt; returned value </span><span class="si">{e.value}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;&gt;&gt;&gt; returned value 3</span>
</pre></div>
</div>
</div>
<div class="section" id="delegating-into-smaller-coroutines-the-yield-from-syntax">
<h4>3.2.2. Delegating into smaller coroutines: the yield from syntax<a class="headerlink" href="#delegating-into-smaller-coroutines-the-yield-from-syntax" title="Permalink to this headline">¶</a></h4>
<p>The previous feature is interesting in the sense that it opens up a lot of new possibilities
with coroutines (generators), now that they can return values. But this feature, by itself,
would not be so useful without proper syntax support, because catching the returned value
this way is a bit cumbersome.</p>
<p>This is one of the main features of the yield from syntax. Among other things (that we’ll
review in detail), it can collect the value returned by a sub-generator. Remember that we
said that returning data in a generator was nice, but that, unfortunately, writing statements
as <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">generator()</span></code> wouldn’t work. Well, writing it as <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">from</span>
<span class="pre">generator()</span></code> would.</p>
<div class="section" id="the-simplest-use-of-yield-from">
<h5>3.2.2.1. The simplest use of yield from<a class="headerlink" href="#the-simplest-use-of-yield-from" title="Permalink to this headline">¶</a></h5>
<p>In its most basic form, the new <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> syntax can be used to chain generators from
nested for loops into a single one, which will end up with a single string of all the values in
a continuous stream.</p>
<p>The canonical example is about creating a function similar to <code class="docutils literal notranslate"><span class="pre">itertools.chain()</span></code> from
the standard library. This is a very nice function because it allows you to pass any number
of iterables and will return them all together in one stream.</p>
<p>The naive implementation might look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">it</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">value</span>
</pre></div>
</div>
<p>It receives a variable number of iterables, traverses through all of them, and since each
value is iterable, it supports a <code class="docutils literal notranslate"><span class="pre">for...</span> <span class="pre">in..</span></code> construction, so we have another for loop
to get every value inside each particular iterable, which is produced by the caller function.
This might be helpful in multiple cases, such as chaining generators together or trying to
iterate things that it wouldn’t normally be possible to compare in one go (such as lists with
tuples, and so on).</p>
<p>However, the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> syntax allows us to go further and avoid the nested loop
because it’s able to produce the values from a sub-generator directly. In this case, we could
simplify the code like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">chain</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">iterables</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">it</span>
</pre></div>
</div>
<p>Notice that for both implementations, the behavior of the generator is exactly the same:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;world&quot;</span><span class="p">],</span> <span class="p">(</span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span> <span class="s2">&quot; of &quot;</span><span class="p">,</span> <span class="s2">&quot;values.&quot;</span><span class="p">)))</span>
<span class="go">[&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;world&#39;, &#39;tuple&#39;, &#39; of &#39;, &#39;values.&#39;]</span>
</pre></div>
</div>
<p>This means that we can use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> over any other iterable, and it will work as if the
top-level generator (the one the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> is using) were generating those values itself.</p>
<p>This works with any iterable, and even generator expressions aren’t the exception. Now
that we’re familiar with its syntax, let’s see how we could write a simple generator function
that will produce all the powers of a number (for instance, if provided with
<code class="docutils literal notranslate"><span class="pre">all_powers(2,</span> <span class="pre">3)</span></code>, it will have to produce 2^0, 2^1,… 2^3 ):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">all_powers</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">pow</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">pow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>While this simplifies the syntax a bit, saving one line of a for statement isn’t a big
advantage, and it wouldn’t justify adding such a change to the language.</p>
<p>Indeed, this is actually just a side effect and the real raison d’être of the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>
construction is what we are going to explore in the following two sections.</p>
</div>
<div class="section" id="capturing-the-value-returned-by-a-sub-generator">
<h5>3.2.2.2. Capturing the value returned by a sub-generator<a class="headerlink" href="#capturing-the-value-returned-by-a-sub-generator" title="Permalink to this headline">¶</a></h5>
<p>In the following example, we have a generator that calls another two nested generators,
producing values in a sequence. Each one of these nested generators returns a value, and
we will see how the top-level generator is able to effectively capture the return value since
it’s calling the internal generators through <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2"> started at </span><span class="si">{start}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">yield from</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{name}</span><span class="s2"> finished at </span><span class="si">{end}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">end</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">step1</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">sequence</span><span class="p">(</span><span class="s2">&quot;first&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">step2</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">sequence</span><span class="p">(</span><span class="s2">&quot;second&quot;</span><span class="p">,</span> <span class="n">step1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">step1</span> <span class="o">+</span> <span class="n">step2</span>
</pre></div>
</div>
<p>This is a possible execution of the code in main while it’s being iterated:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; g = main()
&gt;&gt;&gt; next(g)
INFO:generators_yieldfrom_2:first started at 0
0
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
2
&gt;&gt;&gt; next(g)
3
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
INFO:generators_yieldfrom_2:first finished at 5
INFO:generators_yieldfrom_2:second started at 5
5
&gt;&gt;&gt; next(g)
6
&gt;&gt;&gt; next(g)
7
&gt;&gt;&gt; next(g)
8
&gt;&gt;&gt; next(g)
9
&gt;&gt;&gt; next(g)
INFO:generators_yieldfrom_2:second finished at 10
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration: 15
</pre></div>
</div>
<p>The first line of main delegates into the internal generator, and produces the values,
extracting them directly from it. This is nothing new, as we have already seen. Notice,
though, how the <code class="docutils literal notranslate"><span class="pre">sequence()</span></code> generator function returns the end value, which is assigned
in the first line to the variable named <code class="docutils literal notranslate"><span class="pre">step1</span></code>, and how this value is correctly used at the
start of the following instance of that generator.</p>
<p>In the end, this other generator also returns the second <code class="docutils literal notranslate"><span class="pre">end</span></code> value, and the main
generator, in turn, returns the sum of them, which is the value we see once the
iteration has stopped.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>We can use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> to capture the last value of a coroutine after it has finished its processing.</p>
</div>
</div>
<div class="section" id="sending-and-receiving-data-to-and-from-a-sub-generator">
<h5>3.2.2.3. Sending and receiving data to and from a sub-generator<a class="headerlink" href="#sending-and-receiving-data-to-and-from-a-sub-generator" title="Permalink to this headline">¶</a></h5>
<p>Now, we will see the other nice feature of the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> syntax, which is probably what
gives it its full power. As we have already introduced when we explored generators acting
as coroutines, we know that we can send values and throw exceptions at them, and, in such
cases, the coroutine will either receive the value for its internal processing, or it will have to
handle the exception accordingly.</p>
<p>If we now have a coroutine that delegates into other ones (such as in the previous example),
we would also like to preserve this logic. Having to do so manually would be quite
complex if we didn’t have this handled by <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> automatically.</p>
<p>In order to illustrate this, let’s keep the same top-level generator (main) unmodified with
respect to the previous example (calling other internal generators), but let’s modify the
internal generators to make them able to receive values and handle exceptions. The code is
probably not idiomatic, only for the purposes of showing how this mechanism works:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> started at </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">received</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">value</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> received </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">received</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">except</span> <span class="n">CustomException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is handling </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">received</span> <span class="o">=</span> <span class="k">yield</span> <span class="s2">&quot;OK&quot;</span>

    <span class="k">return</span> <span class="n">end</span>
</pre></div>
</div>
<p>Now, we will call the main coroutine, not only by iterating it, but also by passing values
and throwing exceptions at it to see how they are handled inside sequence :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">main</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">INFO: first started at 0</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="go">INFO: first received None</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&quot;value for 1&quot;</span><span class="p">)</span>
<span class="go">INFO: first received &#39;value for 1&#39;</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">CustomException</span><span class="p">(</span><span class="s2">&quot;controlled error&quot;</span><span class="p">))</span>
<span class="go">INFO: first is handling controlled error</span>
<span class="go">&#39;OK&#39;</span>
<span class="gp">... </span><span class="c1"># advance more times</span>
<span class="go">INFO:second started at 5</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="n">CustomException</span><span class="p">(</span><span class="s2">&quot;exception at second generator&quot;</span><span class="p">))</span>
<span class="go">INFO: second is handling exception at second generator</span>
<span class="go">&#39;OK&#39;</span>
</pre></div>
</div>
<p>This example is showing us a lot of different things. Notice how we never send values
to <code class="docutils literal notranslate"><span class="pre">sequence</span></code>, but only to main, and even so, the code that is receiving those values is the
nested generators. Even though we never explicitly send anything to <code class="docutils literal notranslate"><span class="pre">sequence</span></code>, it’s
receiving the data as it’s being passed along by yield from .</p>
<p>The main coroutine calls two other coroutines internally, producing their values, and it will
be suspended at a particular point in time in any of those. When it’s stopped at the first one,
we can see the logs telling us that it is that instance of the coroutine that received the value
we sent. The same happens when we throw an exception to it. When the first coroutine
finishes, it returns the value that was assigned in the variable named <code class="docutils literal notranslate"><span class="pre">step1</span></code>, and passed as
input for the second coroutine, which will do the same (it will handle the <code class="docutils literal notranslate"><span class="pre">send()</span></code>
and <code class="docutils literal notranslate"><span class="pre">throw()</span></code> calls, accordingly).</p>
<p>The same happens for the values that each coroutine produces. When we are at any given
step, the return from calling <code class="docutils literal notranslate"><span class="pre">send()</span></code> corresponds to the value that the subcoroutine (the
one that main is currently suspended at) has produced. When we throw an exception that is
being handled, the sequence coroutine produces the value OK, which is propagated to the
called (<code class="docutils literal notranslate"><span class="pre">main</span></code>), and which in turn will end up at main’s caller.</p>
</div>
</div>
</div>
</div>
<div class="section" id="asynchronous-programming">
<h2>4. Asynchronous programming<a class="headerlink" href="#asynchronous-programming" title="Permalink to this headline">¶</a></h2>
<p>With the constructions we have seen so far, we are able to create asynchronous programs in
Python. This means that we can create programs that have many coroutines, schedule them
to work in a particular order, and switch between them when they’re suspended after a
<code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> has been called on each of them.</p>
<p>The main advantage that we can take out of this is the possibility of parallelizing I/O
operations in a non-blocking way. What we would need is a low-level generator (usually
implemented by a third-party library) that knows how to handle the actual I/O while the
coroutine is suspended. The idea is for the coroutine to effect suspension so that our
program can handle another task in the meantime. The way the application would retrieve
the control back is by means of the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> statement, which will suspend and
produce a value to the caller (as in the examples we saw previously when we used this
syntax to alter the control flow of the program).</p>
<p>This is roughly the way asynchronous programming had been working in Python for quite
a few years, until it was decided that better syntactic support was needed.</p>
<p>The fact that coroutines and generators are technically the same causes some confusion.
Syntactically (and technically), they are the same, but semantically, they are different. We
create generators when we want to achieve efficient iteration. We typically create
coroutines with the goal of running non-blocking I/O operations.</p>
<p>While this difference is clear, the dynamic nature of Python would still allow developers to
mix these different type of objects, ending up with a runtime error at a very late stage of the
program. Remember that in the simplest and most basic form of the <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> syntax,
we used this construction over iterables (we created a sort of chain function applied over
strings, lists, and so on). None of these objects were coroutines, and it still worked. Then,
we saw that we can have multiple coroutines, use <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code> to send the value (or
exceptions), and get some results back. These are clearly two very different use cases,
however, if we write something along the lines of the following statement:
<code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">yield</span> <span class="pre">from</span> <span class="pre">iterable_or_awaitable()</span></code></p>
<p>It’s not clear what <code class="docutils literal notranslate"><span class="pre">iterable_or_awaitable</span> <span class="pre">returns</span></code>. It can be a simple iterable such as a
string, and it might still be syntactically correct. Or, it might be an actual coroutine. The cost
of this mistake will be paid much later.</p>
<p>For this reason, the typing system in Python had to be extended. Before Python 3.5,
coroutines were just generators with a &#64;coroutine decorator applied, and they were to be
called with the yield from syntax. Now, there is a specific type of object, that is, a
coroutine.</p>
<p>This change heralded, syntax changes as well. The <code class="docutils literal notranslate"><span class="pre">await</span></code> and <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> syntax were
introduced. The former is intended to be used instead of <code class="docutils literal notranslate"><span class="pre">yield</span> <span class="pre">from</span></code>, and it only works
with awaitable objects (which coroutines conveniently happen to be). Trying to
call <code class="docutils literal notranslate"><span class="pre">await</span></code> with something that doesn’t respect the interface of an awaitable will raise an
exception. The <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">def</span></code> is the new way of defining coroutines, replacing the
aforementioned decorator, and this actually creates an object that, when called, will return
an instance of a coroutine.</p>
<p>Without going into all the details and possibilities of asynchronous programming in
Python, we can say that despite the new syntax and the new types, this is not doing
anything fundamentally different from concepts we have covered.</p>
<p>The idea of programming asynchronously in Python is that there is an event loop
(typically <code class="docutils literal notranslate"><span class="pre">asyncio</span></code> because it’s the one that is included in the standard library, but there
are many others that will work just the same) that manages a series of coroutines. These
coroutines belong to the event loop, which is going to call them according to its scheduling
mechanism. When each one of these runs, it will call our code (according to the logic we
have defined inside the coroutine we programmed), and when we want to get control back
to the event loop, we call <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">&lt;coroutine&gt;</span></code>, which will process a task asynchronously.
The event loop will resume and another coroutine will take place while that operation is left
running.</p>
<p>In practice, there are more particularities and edge cases that are beyond the scope. It is, however, worth
mentioning that these concepts are related to the ideas introduced in this chapter and that this arena is
another place where generators demonstrate being a core concept of the language, as there are many things
constructed on top of them.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../8_unit_testing/index.html" class="btn btn-neutral float-right" title="Unit testing and refactoring" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../6_descriptors/index.html" class="btn btn-neutral float-left" title="Getting more out of our objects with descriptors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>