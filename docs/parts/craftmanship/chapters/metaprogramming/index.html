

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Metaprogramming &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Naming" href="../naming/index.html" />
    <link rel="prev" title="Above the class level" href="../above_class_level/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                12/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Craftmanship</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../solid_principles/index.html">SOLID</a></li>
<li class="toctree-l2"><a class="reference internal" href="../decorators/index.html">Decorators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../descriptors/index.html">Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generators/index.html">Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../above_class_level/index.html">Above the class level</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Metaprogramming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-is-metaprogramming">1. What is metaprogramming</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decorators">2. Decorators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-decorators">2.1. Class decorators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#using-new-for-overriding-instantiation">4. Using __new__() for overriding instantiation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#metaclasses">5. Metaclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-general-syntax">5.1. The general syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metaclass-usage">5.2. Metaclass usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metaclass-pitfalls">5.3. Metaclass pitfalls</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#code-generation">6. Code generation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exec-eval-and-compile">6.1. exec, eval and compile</a></li>
<li class="toctree-l4"><a class="reference internal" href="#abstract-syntax-tree-ast">6.2. Abstract syntax tree (AST)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#projects-that-use-code-generation-patterns">6.3. Projects that use code generation patterns</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../naming/index.html">Naming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../structures_algorithms/index.html">Data structures and algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimization/index.html">Code optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../technical_architecture/index.html">Technical architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../low_level/index.html">Low level Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distribution/index.html">Code distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references/index.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Craftmanship</a> &raquo;</li>
        
      <li>Metaprogramming</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/parts/craftmanship/chapters/metaprogramming/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="../naming/index.html" class="btn btn-neutral float-right" title="Naming" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../above_class_level/index.html" class="btn btn-neutral float-left" title="Above the class level" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="metaprogramming">
<h1>Metaprogramming<a class="headerlink" href="#metaprogramming" title="Permalink to this headline">¶</a></h1>
<p>Metaprogramming is one of the most complex and powerful approaches to programming
in Python. Metaprogramming tools and techniques have evolved with Python; so, before
we dive into this topic, it is important for you to know all the elements of modern Python
syntax well.</p>
<div class="section" id="what-is-metaprogramming">
<h2>1. What is metaprogramming<a class="headerlink" href="#what-is-metaprogramming" title="Permalink to this headline">¶</a></h2>
<p>Maybe there is a good academic definition of metaprogramming that we can cite here, but
this is more about good software craftsmanship than about computer science
theory. This is why we will use the following simple definition:</p>
<p><em>“Metaprogramming is a technique of writing computer programs that can treat themselves as data, so they can introspect, generate, and/or modify itself while running.”</em></p>
<p>Using this definition, we can distinguish between two major approaches to
metaprogramming in Python.</p>
<p>The first approach concentrates on the language’s ability to introspect its basic elements,
such as functions, classes, or types, and to create or modify them on the fly. Python really
provides a lot of tools in this area. This feature of the Python language is used by IDEs
(such as PyCharm) to provide real-time code analysis and name suggestions. The easiest
possible metaprogramming tools in Python that utilized language introspection are
decorators that allow for adding extra functionality to the existing functions, methods, or
classes. Next are special methods of classes that allow you to interfere with class instance
process creation. The most powerful are metaclasses, which allow programmers to even
completely redesign Python’s implementation of object-oriented programming.</p>
<p>The second approach allows programmers to work directly with code, either in its raw
(plain text) format or in more programmatically accessible abstract syntax tree (AST) form.
This second approach is, of course, more complicated and difficult to work with but allows
for really extraordinary things, such as extending Python’s language syntax or even
creating your own <strong>domain-specific language (DSL)</strong>.</p>
</div>
<div class="section" id="decorators">
<h2>2. Decorators<a class="headerlink" href="#decorators" title="Permalink to this headline">¶</a></h2>
<p>The decorator syntax was already explained, as a syntactic sugar for the following simple pattern:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorated_function</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="n">decorated_function</span> <span class="o">=</span> <span class="n">some_decorator</span><span class="p">(</span><span class="n">decorated_function</span><span class="p">)</span>
</pre></div>
</div>
<p>This verbose form of function decoration clearly shows what the decorator does. It takes a
function object and modifies it at runtime. As a result, a new function (or anything else) is
created based on the previous function object with the same name. This decoration may be
a complex operation that performs some code introspection or decorated function to give
different results depending on how the original function was implemented. All this means
is that decorators can be considered as a metaprogramming tool.</p>
<p>This is good news. The basics of decorators are relatively easy to grasp and in most cases
make code shorter, easier to read, and also cheaper to maintain. Other metaprogramming
tools that are available in Python are more difficult to understand and master. Also, they
might not make the code simple at all.</p>
<div class="section" id="class-decorators">
<h3>2.1. Class decorators<a class="headerlink" href="#class-decorators" title="Permalink to this headline">¶</a></h3>
<p>One of the lesser known syntax features of Python are the class decorators. Their syntax
and implementation is exactly the same as function decorators. The only difference is that they are
expected to return a class instead of the function object. Here is an example class decorator
that modifies the <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> method to return the printable object representation, which
is shortened to some arbitrary number of characters:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">short_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()[:</span><span class="mi">8</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">cls</span>

<span class="nd">@short_repr</span>
<span class="k">class</span> <span class="nc">ClassWithRelativelyLongName</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The following is what you will see in the output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ClassWithRelativelyLongName</span><span class="p">()</span>
<span class="go">&lt;ClassWi</span>
</pre></div>
</div>
<p>Of course, the preceding snippet is not an example of good code by any means. Still, it
shows how multiple language features that are explained in the previous chapter can be
used together, for example:</p>
<ul class="simple">
<li><p>Not only instances but also class objects can be modified at runtime</p></li>
<li><p>Functions are descriptors too, so they can be added to the class at runtime because the actual method binding is performed on the attribute lookup as part of the descriptor protocol</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">super()</span></code> call can be used outside of a class definition scope as long as proper arguments are provided</p></li>
<li><p>Finally, class decorators can be used on class definitions</p></li>
</ul>
<p>The other aspects of writing function decorators apply to the class decorators as well. Most
importantly, they can use closures and be parametrized. Taking advantage of these facts,
the previous example can be rewritten into the following more readable and maintainable
form:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parametrized_short_repr</span><span class="p">(</span><span class="n">max_width</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parametrized decorator that shortens representation&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">parametrized</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inner wrapper function that is actual decorator&quot;&quot;&quot;</span>

        <span class="k">class</span> <span class="nc">ShortlyRepresented</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Subclass that provides decorated behavior&quot;&quot;&quot;</span>
            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()[:</span><span class="n">max_width</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ShortlyRepresented</span>

    <span class="k">return</span> <span class="n">parametrized</span>
</pre></div>
</div>
<p>The major drawback of using closures in class decorators this way is that the resulting
objects are no longer instances of the class that was decorated but instances of the subclass
that was created dynamically in the decorator function. Among others, this will affect the
class’s <code class="docutils literal notranslate"><span class="pre">__name__</span></code> and <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> attributes, as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@parametrized_short_repr</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ClassWithLittleBitLongerLongName</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Such usage of class decorators will result in the following changes to the class metadata:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ClassWithLittleBitLongerLongName</span><span class="p">()</span><span class="o">.</span><span class="vm">__class__</span>
<span class="go">&lt;class &#39;ShortlyRepresented&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ClassWithLittleBitLongerLongName</span><span class="p">()</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="go">&#39;Subclass that provides decorated behavior&#39;</span>
</pre></div>
</div>
<p>Unfortunately, this cannot be fixed as simply as we explained before. In class
decorators, you can’t simply use the additional <code class="docutils literal notranslate"><span class="pre">wraps</span></code> decorator to preserve the original
class type and metadata. This makes use of the class decorators in this form limited in some
circumstances. They can, for instance, break results of automated documentation
generation tools.</p>
<p>Still, despite this single caveat, class decorators are a simple and lightweight alternative to
the popular mixin class pattern. Mixin in Python is a class that is not meant to be
instantiated, but is instead used to provide some reusable API or functionality to other
existing classes. Mixin classes are almost always added using multiple inheritance. Their
usage usually takes the following form:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SomeConcreteClass</span><span class="p">(</span><span class="n">MixinClass</span><span class="p">,</span> <span class="n">SomeBaseClass</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Mixins classes form a useful design pattern that is utilized in many libraries and
frameworks. To name one, Django is an example framework that uses them extensively.
While useful and popular, mixins can cause some trouble if not designed well, because, in
most cases, they require the developer to rely on multiple inheritance. As we stated earlier,
Python handles multiple inheritance relatively well, thanks to its clear MRO
implementation. Anyway, try to avoid subclassing multiple classes if you can. Multiple
inheritance makes code more complex and hard to reason about. This is why class
decorators may be a good replacement for mixin classes.</p>
</div>
</div>
<div class="section" id="using-new-for-overriding-instantiation">
<h2>4. Using __new__() for overriding instantiation<a class="headerlink" href="#using-new-for-overriding-instantiation" title="Permalink to this headline">¶</a></h2>
<p>The special method <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> is a static method that’s responsible for creating class
instances. It is special-cased, so there is no need to declare it as static using
the <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> decorator. This <code class="docutils literal notranslate"><span class="pre">__new__(cls,</span> <span class="pre">[,...])</span></code> method is called prior to
the <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> initialization method. Typically, the implementation of
overridden <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> invokes its superclass version using <code class="docutils literal notranslate"><span class="pre">super().__new__()</span></code> with
suitable arguments and modifies the instance before returning it.</p>
<p>The following is an example class with the overridden <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> method implementation
in order to count the number of class instances:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InstanceCountingClass</span><span class="p">:</span>

    <span class="n">instances_created</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;__new__() called with:&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">number</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances_created</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">instances_created</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;__init__() called with:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span>
</pre></div>
</div>
<p>Here is the log of the example interactive session that shows how
our InstanceCountingClass implementation works:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">instance_counting</span> <span class="kn">import</span> <span class="n">InstanceCountingClass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instance1</span> <span class="o">=</span> <span class="n">InstanceCountingClass</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
<span class="go">__new__() called with: &lt;class &#39;__main__.InstanceCountingClass&#39;&gt; (&#39;abc&#39;,) {}</span>
<span class="go">__init__() called with: &lt;__main__.InstanceCountingClass object at</span>
<span class="go">0x101259e10&gt; abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instance2</span> <span class="o">=</span> <span class="n">InstanceCountingClass</span><span class="p">(</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
<span class="go">__new__() called with: &lt;class &#39;__main__.InstanceCountingClass&#39;&gt; (&#39;xyz&#39;,) {}</span>
<span class="go">__init__() called with: &lt;__main__.InstanceCountingClass object at</span>
<span class="go">0x101259dd8&gt; xyz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instance1</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">instance1</span><span class="o">.</span><span class="n">instances_created</span>
<span class="go">(0, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instance2</span><span class="o">.</span><span class="n">number</span><span class="p">,</span> <span class="n">instance2</span><span class="o">.</span><span class="n">instances_created</span>
<span class="go">(1, 2)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> method should usually return an instance of the featured class, but it is
also possible for it to return other class instances. If this does happen (a different class
instance is returned), then the call to the <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method is skipped. This fact is useful
when there is a need to modify creation/initialization behavior of immutable class instances
like some of Python’s built-in types, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NonZero</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skipped_value</span><span class="p">):</span>
        <span class="c1"># implementation of __init__ could be skipped in this case</span>
        <span class="c1"># but it is left to present how it may be not called</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;__init__() called&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
</pre></div>
</div>
<p>Let’s review these in the following interactive session:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">NonZero</span><span class="p">(</span><span class="o">-</span><span class="mi">12</span><span class="p">))</span>
<span class="go">__init__() called</span>
<span class="go">&lt;class &#39;__main__.NonZero&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">NonZero</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">&lt;class &#39;NoneType&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">NonZero</span><span class="p">(</span><span class="o">-</span><span class="mf">3.123</span><span class="p">)</span>
<span class="go">__init__() called</span>
<span class="go">-3</span>
</pre></div>
</div>
<p>So, when should we use <code class="docutils literal notranslate"><span class="pre">__new__()</span></code>? The answer is simple: only when <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> is not
enough. One such case was already mentioned, that is, subclassing immutable built-in
Python types such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>, and so on. This is because there was no
way to modify such an immutable object instance in the <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method once it was
created.</p>
<p>Some programmers can argue that <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> may be useful for performing important
object initialization that may be missed if the user forgets to use
the <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code> call in the overridden initialization method. While it sounds
reasonable, this has a major drawback. With such an approach, it becomes harder for the
programmer to explicitly skip previous initialization steps if this is the already desired
behavior. It also breaks an unspoken rule of all initializations performed in <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>.</p>
<p>Because <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> is not constrained to return the same class instance, it can be easily
abused. Irresponsible usage of this method might do a lot of harm to code readability, so it
should always be used carefully and backed with extensive documentation. Generally, it is
better to search for other solutions that may be available for the given problem, instead of
affecting object creation in a way that will break a basic programmers’ expectations. Even
overridden initialization of immutable types can be replaced with more predictable and
well-established design patterns like the Factory Method.</p>
<p>There is at least one aspect of Python programming where extensive usage of
the <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> method is well justified. These are metaclasses.</p>
</div>
<div class="section" id="metaclasses">
<h2>5. Metaclasses<a class="headerlink" href="#metaclasses" title="Permalink to this headline">¶</a></h2>
<p>Metaclass is a Python feature that is considered by many as one of the most difficult things
to understand in this language and thus avoided by a great number of developers. In
reality, it is not as complicated as it sounds once you understand a few basic concepts. As a
reward, knowing how to use metaclasses grants you the ability to do things that are not
possible without them.</p>
<p>Metaclass is a type (class) that defines other types (classes). The most important thing to
know in order to understand how they work is that classes that define object instances are
objects too. So, if they are objects, then they have an associated class. The basic type of
every class definition is simply the built-in <code class="docutils literal notranslate"><span class="pre">type</span></code> class. Here is a simple diagram that should
make this clear:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../../../_images/metaclasses_diagram_1.jpg"><img alt="../../../../_images/metaclasses_diagram_1.jpg" src="../../../../_images/metaclasses_diagram_1.jpg" style="width: 50%;" /></a>
</div>
<p>In Python, it is possible to substitute the metaclass for a class object with our own type.
Usually, the new metaclass is still the subclass of the <code class="docutils literal notranslate"><span class="pre">type</span></code> class because
not doing so would make the resulting classes highly incompatible with other classes in
terms of inheritance:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../../../_images/metaclasses_diagram_2.jpg"><img alt="../../../../_images/metaclasses_diagram_2.jpg" src="../../../../_images/metaclasses_diagram_2.jpg" style="width: 40%;" /></a>
</div>
<div class="section" id="the-general-syntax">
<h3>5.1. The general syntax<a class="headerlink" href="#the-general-syntax" title="Permalink to this headline">¶</a></h3>
<p>The call to the built-in <code class="docutils literal notranslate"><span class="pre">type()</span></code> class can be used as a dynamic equivalent of the class
statement. The following is an example of a class definition with the <code class="docutils literal notranslate"><span class="pre">type()</span></code> call:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="n">MyClass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;MyClass&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">})</span>
</pre></div>
</div>
<p>This is equivalent to the explicit definition of the class with the <code class="docutils literal notranslate"><span class="pre">class</span></code> keyword:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Every class that’s created with the <code class="docutils literal notranslate"><span class="pre">class</span></code> statement implicitly uses <code class="docutils literal notranslate"><span class="pre">type</span></code> as its metaclass. This
default behavior can be changed by providing the <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> keyword argument to the
class statement, as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassWithAMetaclass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The value that’s provided as a <code class="docutils literal notranslate"><span class="pre">metaclass</span></code> argument is usually another class object, but it
can be any other callable that accepts the same arguments as the <code class="docutils literal notranslate"><span class="pre">type</span></code> class and is expected
to return another class object. The call signature is <code class="docutils literal notranslate"><span class="pre">type(name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code> and
the meaning of the arguments are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: This is the name of the class that will be stored in the <code class="docutils literal notranslate"><span class="pre">__name__</span></code> attribute</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bases</span></code>: This is the list of parent classes that will become the <code class="docutils literal notranslate"><span class="pre">__bases__</span></code> attribute and will be used to construct the MRO of a newly created class</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace</span></code>: This is a namespace (mapping) with definitions for the class body that will become the <code class="docutils literal notranslate"><span class="pre">__dict__</span></code> attribute</p></li>
</ul>
<p>One way of thinking about metaclasses is the <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> method, but at a higher level of
class definition.</p>
<p>Despite the fact that functions that explicitly call <code class="docutils literal notranslate"><span class="pre">type()</span></code> can be used in place of
metaclasses, the usual approach is to use a different class that inherits from type for this
purpose. The common template for a metaclass is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Metaclass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="fm">__prepare__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__prepare__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">bases</span></code>, and <code class="docutils literal notranslate"><span class="pre">namespace</span></code> arguments have the same meaning as in the <code class="docutils literal notranslate"><span class="pre">type()</span></code> call
we explained earlier, but each of these four methods can have the following different
purposes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__new__(mcs,</span> <span class="pre">name,</span> <span class="pre">bases,</span> <span class="pre">namespace)</span></code>: This is responsible for the actual creation of the class object in the same way as it does for ordinary classes. The first positional argument is a metaclass object. In the preceding example, it would simply be a <code class="docutils literal notranslate"><span class="pre">Metaclass</span></code>. Note that <code class="docutils literal notranslate"><span class="pre">mcs</span></code> is the popular naming convention for this argument.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__prepare__(mcs,</span> <span class="pre">name,</span> <span class="pre">bases,</span> <span class="pre">**kwargs)</span></code>: This creates an empty namespace object. By default, it returns an empty <code class="docutils literal notranslate"><span class="pre">dict</span></code>, but it can be overridden to return any other mapping type. Note that it does not accept <code class="docutils literal notranslate"><span class="pre">namespace</span></code> as an argument because, before calling it, the namespace does not exist.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__init__(cls,</span> <span class="pre">name,</span> <span class="pre">bases,</span> <span class="pre">namespace,</span> <span class="pre">**kwargs)</span></code>: This is not seen popularly in metaclass implementations but has the same meaning as in ordinary classes. It can perform additional class object initialization once it is created with <code class="docutils literal notranslate"><span class="pre">__new__()</span></code>. The first positional argument is now named <code class="docutils literal notranslate"><span class="pre">cls</span></code> by convention to mark that this is already a created class object (metaclass instance) and not a metaclass object. When <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> was called, the class was already constructed and so this method can do less things than the <code class="docutils literal notranslate"><span class="pre">__new__()</span></code> method. Implementing such a method is very similar to using class decorators, but the main difference is that <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> will be called for every subclass, while class decorators are not called for subclasses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__call__(cls,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>: This is called when an instance of a metaclass is called. The instance of a metaclass is a class object; it is invoked when you create new instances of a class. This can be used to override the default way of how class instances are created and initialized.</p></li>
</ul>
<p>Each of the preceding methods can accept additional extra keyword arguments, all of
which are represented by <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>. These arguments can be passed to the metaclass object
using extra keyword arguments in the class definition in the form of the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Klass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Metaclass</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>This amount of information can be overwhelming at the beginning without proper
examples, so let’s trace the creation of metaclasses, classes, and instances with
some <code class="docutils literal notranslate"><span class="pre">print()</span></code> calls:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RevealingMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="s2">&quot;__new__ called&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="fm">__prepare__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="s2">&quot;__prepare__ called&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__prepare__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__init__ called&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__call__ called&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">RevealingMeta</span></code> as a metaclass to create a new class definition will give the
following output in the Python interactive session:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RevealingClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">RevealingMeta</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__new__ called&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__init__ called&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">&lt;class &#39;RevealingMeta&#39;&gt; __prepare__ called</span>
<span class="go">&lt;class &#39;RevealingMeta&#39;&gt; __new__ called</span>
<span class="go">&lt;class &#39;RevealingClass&#39;&gt; __init__ called</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">instance</span> <span class="o">=</span> <span class="n">RevealingClass</span><span class="p">()</span>
<span class="go">&lt;class &#39;RevealingClass&#39;&gt; __call__ called &lt;class &#39;RevealingClass&#39;&gt; __new__</span>
<span class="go">called &lt;RevealingClass object at 0x1032b9fd0&gt; __init__ called</span>
</pre></div>
</div>
</div>
<div class="section" id="metaclass-usage">
<h3>5.2. Metaclass usage<a class="headerlink" href="#metaclass-usage" title="Permalink to this headline">¶</a></h3>
<p>Metaclasses, once mastered, are a powerful feature, but always complicate the code.
Metaclasses also do not compose well and you’ll quickly run into problems if you try to mix
multiple metaclasses through inheritance.</p>
<p>For simple things, like changing the read/write attributes or adding new ones, metaclasses
can be avoided in favor of simpler solutions, such as properties, descriptors, or class
decorators.</p>
<p>But there are situations where things cannot be easily done without them. For instance, it is
hard to imagine Django’s ORM implementation built without extensive use of metaclasses.
It could be possible, but it is rather unlikely that the resulting solution would be similarly
easy to use. Frameworks are the place where metaclasses really shine. They usually have a
lot of complex internal code that is not easy to understand and follow, but eventually allow
other programmers to write more condensed and readable code that operates on a higher
level of abstraction.</p>
</div>
<div class="section" id="metaclass-pitfalls">
<h3>5.3. Metaclass pitfalls<a class="headerlink" href="#metaclass-pitfalls" title="Permalink to this headline">¶</a></h3>
<p>Like some other advanced Python features, the metaclasses are very elastic and can be
easily abused. While the call signature of the class is rather strict, Python does not enforce
the type of the return parameter. It can be anything as long as it accepts incoming
arguments on calls and has the required attributes whenever it is needed.</p>
<p>One such object that can be <em>anything-anywhere</em> is the instance of the <code class="docutils literal notranslate"><span class="pre">Mock</span></code> class that’s
provided in the <code class="docutils literal notranslate"><span class="pre">unittest.mock</span></code> module. <code class="docutils literal notranslate"><span class="pre">Mock</span></code> is not a metaclass and also does not inherit
from the <code class="docutils literal notranslate"><span class="pre">type</span></code> class. It also does not return the class object on instantiating. Still, it can be
included as a metaclass keyword argument in the class definition, and this will not raise
any syntax errors. Using <code class="docutils literal notranslate"><span class="pre">Mock</span></code> as a metaclass is, of course, complete nonsense, but let’s
consider the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">unittest.mock</span> <span class="kn">import</span> <span class="n">Mock</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Nonsense</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Mock</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nonsense</span>
<span class="go">&lt;Mock spec=&#39;str&#39; id=&#39;4327214664&#39;&gt;</span>
<span class="go"># pointless, but illustrative</span>
</pre></div>
</div>
<p>It’s not hard to predict that any attempt to instantiate our Nonsense pseudo-class will fail.
What is really interesting is the following exception and traceback you’ll get trying to do so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; Nonsense()
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
File
&quot;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/unittest/mock.py&quot;, line 917, in __call__
    return _mock_self._mock_call(*args, **kwargs)
File
&quot;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/unittest/mock.py&quot;, line 976, in _mock_call
    result = next(effect)
StopIteration
</pre></div>
</div>
<p>Does the <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception give you any clue that there may be a problem with
our class definition on the metaclass level? Obviously not. This example illustrates how
hard it may be to debug metaclass code if you don’t know where to look for errors.</p>
</div>
</div>
<div class="section" id="code-generation">
<h2>6. Code generation<a class="headerlink" href="#code-generation" title="Permalink to this headline">¶</a></h2>
<p>As we already mentioned, the dynamic code generation is the most difficult approach to
metaprogramming. There are tools in Python that allow you to generate and execute code
or even do some modifications to the already compiled code objects.</p>
<p>Various projects such as <strong>Hy</strong> show that even whole languages can be
reimplemented in Python using code generation techniques. This proves that the
possibilities are practically limitless. Knowing how vast this topic is and how badly it is
riddled with various pitfalls, I won’t even try to give detailed suggestions on how to create
code this way, or to provide useful code samples.</p>
<p>Anyway, knowing what is possible may be useful for you if you plan to study this field
deeper by yourself. So, treat this section only as a short summary of possible starting points
for further learning.</p>
<div class="section" id="exec-eval-and-compile">
<h3>6.1. exec, eval and compile<a class="headerlink" href="#exec-eval-and-compile" title="Permalink to this headline">¶</a></h3>
<p>Python provides the following three built-in functions to manually execute, evaluate, and
compile arbitrary Python code:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">exec(object,</span> <span class="pre">globals,</span> <span class="pre">locals)</span></code>: This allows you to dynamically execute the Python code. <code class="docutils literal notranslate"><span class="pre">object</span></code> should be a string or code object (see the <code class="docutils literal notranslate"><span class="pre">compile()</span></code> function) representing a single statement or sequence of multiple statements. The <code class="docutils literal notranslate"><span class="pre">globals</span></code> and <code class="docutils literal notranslate"><span class="pre">locals</span></code> arguments provide global and local namespaces for the executed code and are optional. If they are not provided, then the code is executed in the current scope. If provided, <code class="docutils literal notranslate"><span class="pre">globals</span></code> must be a dictionary, while <code class="docutils literal notranslate"><span class="pre">locals</span></code> might be any mapping object; it always returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">eval(expression,</span> <span class="pre">globals,</span> <span class="pre">locals)</span></code>: This is used to evaluate the given expression by returning its value. It is similar to <code class="docutils literal notranslate"><span class="pre">exec()</span></code>, but it expects <code class="docutils literal notranslate"><span class="pre">expression</span></code> to be a single Python expression and not a sequence of statements. It returns the value of the evaluated expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compile(source,</span> <span class="pre">filename,</span> <span class="pre">mode)</span></code>: This compiles the source into the code object or AST object. The source code is provided as a string value in the <code class="docutils literal notranslate"><span class="pre">source</span></code> argument. The filename should be the file from which the code was read. If it has no file associated (for example, because it was created dynamically), then <code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code> is the value that is commonly used. Mode should be either <code class="docutils literal notranslate"><span class="pre">exec</span></code> (sequence of statements), <code class="docutils literal notranslate"><span class="pre">eval</span></code> (single expression), or <code class="docutils literal notranslate"><span class="pre">single</span></code> (a single interactive statement, such as in a Python interactive session).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">exec()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> functions are the easiest to start with when trying to dynamically
generate code because they can operate on strings. If you already know how to program in
Python, then you may already know how to correctly generate working source code
programmatically.</p>
<p>The most useful in the context of metaprogramming is obviously <code class="docutils literal notranslate"><span class="pre">exec()</span></code> because it allows
you to execute any sequence of Python statements. The word <em>any</em> should be alarming for
you. Even <code class="docutils literal notranslate"><span class="pre">eval()</span></code>, which allows only evaluation of expressions in the hands of a skillful
programmer (when fed with the user input), can lead to serious security holes. Note that
crashing the Python interpreter is the scenario you should be least afraid of. Introducing
vulnerability to remote execution exploits due to irresponsible use
of <code class="docutils literal notranslate"><span class="pre">exec()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> can cost you your image as a professional developer, or even your
job.</p>
<p>Even if used with a trusted input, there is a list of little details
about <code class="docutils literal notranslate"><span class="pre">exec()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> that is too long to be included here, but might affect how your
application works in ways you would not expect. Armin Ronacher has a good article that
lists the most important of them, titled “Be careful with exec and eval” in Python (refer
to <a class="reference external" href="http://lucumr.pocoo.org/2011/2/1/exec-in-python/">http://lucumr.pocoo.org/2011/2/1/exec-in-python/</a> ).</p>
<p>Despite all these frightening warnings, there are natural situations where the usage
of <code class="docutils literal notranslate"><span class="pre">exec()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> is really justified. Still, in the case of even the tiniest doubt, you
should not use them and try to find a different solution.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The signature of the <code class="docutils literal notranslate"><span class="pre">eval()</span></code> function might make you think that if you
provide empty <code class="docutils literal notranslate"><span class="pre">globals</span></code> and <code class="docutils literal notranslate"><span class="pre">locals</span></code> namespaces and wrap it with
proper <code class="docutils literal notranslate"><span class="pre">try</span></code> … <code class="docutils literal notranslate"><span class="pre">except</span></code> statements, then it will be reasonably safe. There
could be nothing more wrong. Ned Batcheler has written a very good
article in which he shows how to cause an interpreter segmentation fault
in the <code class="docutils literal notranslate"><span class="pre">eval()</span></code> call, even with erased access to all Python built-ins
(see <a class="reference external" href="http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html">http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html</a> ).
This is single proof that both <code class="docutils literal notranslate"><span class="pre">exec()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> should never
be used with untrusted input.</p>
</div>
</div>
<div class="section" id="abstract-syntax-tree-ast">
<h3>6.2. Abstract syntax tree (AST)<a class="headerlink" href="#abstract-syntax-tree-ast" title="Permalink to this headline">¶</a></h3>
<p>The Python syntax is converted into AST before it is compiled into byte code. This is a tree
representation of the abstract syntactic structure of the source code. Processing of Python
grammar is available thanks to the built-in <code class="docutils literal notranslate"><span class="pre">ast</span></code> module. Raw ASTs of Python code can be
created using the <code class="docutils literal notranslate"><span class="pre">compile()</span></code> function with the <code class="docutils literal notranslate"><span class="pre">ast.PyCF_ONLY_AST</span></code> flag, or by using
the <code class="docutils literal notranslate"><span class="pre">ast.parse()</span></code> helper. Direct translation in reverse is not that simple and there is no
function provided in the standard library that can do so. Some projects, such as PyPy, do
such things though.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ast</span></code> module provides some helper functions that allow you to work with the AST, for
example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;def hello_world(): print(&quot;hello world!&quot;)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span>
<span class="go">&lt;_ast.Module object at 0x00000000038E9588&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">&quot;Module(</span>
<span class="go">    body=[</span>
<span class="go">        FunctionDef(</span>
<span class="go">            name=&#39;hello_world&#39;,</span>
<span class="go">            args=arguments(</span>
<span class="go">                args=[],</span>
<span class="go">                vararg=None,</span>
<span class="go">                kwonlyargs=[],</span>
<span class="go">                kw_defaults=[],</span>
<span class="go">                kwarg=None,</span>
<span class="go">                defaults=[]</span>
<span class="go">            ),</span>
<span class="go">            body=[</span>
<span class="go">                Expr(</span>
<span class="go">                    value=Call(</span>
<span class="go">                        func=Name(id=&#39;print&#39;, ctx=Load()),</span>
<span class="go">                        args=[Str(s=&#39;hello world!&#39;)],</span>
<span class="go">                        keywords=[]</span>
<span class="go">                    )</span>
<span class="go">                )</span>
<span class="go">            ],</span>
<span class="go">            decorator_list=[],</span>
<span class="go">            returns=None</span>
<span class="go">        )</span>
<span class="go">    ]</span>
<span class="go">)&quot;</span>
</pre></div>
</div>
<p>The output of <code class="docutils literal notranslate"><span class="pre">ast.dump()</span></code> in the preceding example was reformatted to increase the
readability and better show the tree-like structure of the AST. It is important to know that
the AST can be modified before being passed to <code class="docutils literal notranslate"><span class="pre">compile()</span></code>. This gives you many new
possibilities. For instance, new syntax nodes can be used for additional instrumentation,
such as test coverage measurement. It is also possible to modify the existing code tree in
order to add new semantics to the existing syntax. Such a technique is used by the MacroPy
project (<a class="reference external" href="https://github.com/lihaoyi/macropy">https://github.com/lihaoyi/macropy</a>)
to add syntactic macros to Python using the already existing syntax:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../../../_images/macropy_diagram.jpg"><img alt="../../../../_images/macropy_diagram.jpg" src="../../../../_images/macropy_diagram.jpg" style="width: 50%;" /></a>
</div>
<p>AST can also be created in a purely artificial manner, and there is no need to parse any
source at all. This gives Python programmers the ability to create Python bytecode for
custom domain-specific languages, or even completely implement other programming
languages on top of Python VMs.</p>
<div class="section" id="import-hooks">
<h4>6.2.1. Import hooks<a class="headerlink" href="#import-hooks" title="Permalink to this headline">¶</a></h4>
<p>Taking advantage of MacroPy’s ability to modify original ASTs would be as easy as using
the <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">macropy.activate</span></code> statement if it could somehow override the Python
import behavior. Fortunately, Python provides a way to intercept imports using the
following two kinds of import hooks:</p>
<ul class="simple">
<li><p><strong>Meta hooks</strong>: These are called before any other <code class="docutils literal notranslate"><span class="pre">import</span></code> processing has occurred. Using meta hooks, you can override the way in which <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> is processed for even frozen and built-in modules. To add a new meta hook, a new <strong>meta path finder</strong> object must be added to the <code class="docutils literal notranslate"><span class="pre">sys.meta_path</span></code> list.</p></li>
<li><p><strong>Import path hooks</strong>: These are called as part of <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> processing. They are used if the path item associated with the given hook is encountered. The import path hooks are added by extending the <code class="docutils literal notranslate"><span class="pre">sys.path_hooks</span></code> list with a new <strong>path finder</strong> object.</p></li>
</ul>
<p>The details of implementing both path finders and meta path finders are extensively
implemented in the official Python documentation
(see <a class="reference external" href="https://docs.python.org/3/reference/import.html">https://docs.python.org/3/reference/import.html</a> ).
The official documentation should be your primary resource if you want to interact with imports on that level.
This is so because import machinery in Python is rather complex and any attempt to summarize it
in a few paragraphs would inevitably fail. Here, we just noted that such things are possible.</p>
</div>
</div>
<div class="section" id="projects-that-use-code-generation-patterns">
<h3>6.3. Projects that use code generation patterns<a class="headerlink" href="#projects-that-use-code-generation-patterns" title="Permalink to this headline">¶</a></h3>
<p>It is hard to find a really usable implementation of the library that relies on code generation
patterns that is not only an experiment or simple proof of concept. The reasons for that
situation are fairly obvious:</p>
<ul class="simple">
<li><p>Deserved fear of the <code class="docutils literal notranslate"><span class="pre">exec()</span></code> and <code class="docutils literal notranslate"><span class="pre">eval()</span></code> functions because, if used irresponsibly, they can cause real disasters</p></li>
<li><p>Successful code generation is very difficult to develop and maintain because it requires a deep understanding of the language and exceptional programming skills in general</p></li>
</ul>
<p>Despite these difficulties, there are some projects that successfully take this approach either
to improve performance or achieve things that would be impossible by other means.</p>
<div class="section" id="falcon-s-compiled-router">
<h4>6.3.1. Falcon’s compiled router<a class="headerlink" href="#falcon-s-compiled-router" title="Permalink to this headline">¶</a></h4>
<p>Falcon ( <a class="reference external" href="http://falconframework.org/">http://falconframework.org/</a> ) is a minimalist Python WSGI web
framework for building fast and lightweight APIs. It strongly encourages the REST architectural style that
is currently very popular around the web. It is a good alternative to other rather heavy
frameworks, such as Django or Pyramid. It is also a strong competitor to other micro-
frameworks that aim for simplicity, such as Flask, Bottle, or web2py.</p>
<p>One of its features is it’s very simple routing mechanism. It is not as complex as the routing
provided by Django <code class="docutils literal notranslate"><span class="pre">urlconf</span></code> and does not provide as many features, but in most cases is
just enough for any API that follows the REST architectural design. What is most
interesting about Falcon’s routing is the internal construction of that router. Falcon’s router
is implemented using the code generated from the list of routes, and code changes every
time a new route is registered. This is the effort that’s needed to make routing fast.</p>
<p>Consider this very short API example, taken from Falcon’s web documentation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">falcon</span>
<span class="kn">import</span> <span class="nn">json</span>


<span class="k">class</span> <span class="nc">QuoteResource</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">on_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">resp</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handles GET requests&quot;&quot;&quot;</span>

        <span class="n">quote</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;quote&#39;</span><span class="p">:</span> <span class="s1">&#39;I</span><span class="se">\&#39;</span><span class="s1">ve always been more interested in &#39;</span>
                     <span class="s1">&#39;the future than in the past.&#39;</span><span class="p">,</span>
            <span class="s1">&#39;author&#39;</span><span class="p">:</span> <span class="s1">&#39;Grace Hopper&#39;</span>
        <span class="p">}</span>

        <span class="n">resp</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">quote</span><span class="p">)</span>

    <span class="n">api</span> <span class="o">=</span> <span class="n">falcon</span><span class="o">.</span><span class="n">API</span><span class="p">()</span>
    <span class="n">api</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;/quote&#39;</span><span class="p">,</span> <span class="n">QuoteResource</span><span class="p">())</span>
</pre></div>
</div>
<p>In short, the highlighted call to the <code class="docutils literal notranslate"><span class="pre">api.add_route()</span></code> method updates dynamically the
whole generated code tree for Falcon’s request router. It also compiles it using
the <code class="docutils literal notranslate"><span class="pre">compile()</span></code> function and generates the new route-finding function using <code class="docutils literal notranslate"><span class="pre">eval()</span></code>. Let’s
take a closer look at the following <code class="docutils literal notranslate"><span class="pre">__code__</span></code> attribute of
the <code class="docutils literal notranslate"><span class="pre">api._router._find()</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">api</span><span class="o">.</span><span class="n">_router</span><span class="o">.</span><span class="n">_find</span><span class="o">.</span><span class="vm">__code__</span>
<span class="go">&lt;code object find at 0x00000000033C29C0, file &quot;&lt;string&gt;&quot;, line 1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">api</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;/none&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">api</span><span class="o">.</span><span class="n">_router</span><span class="o">.</span><span class="n">_find</span><span class="o">.</span><span class="vm">__code__</span>
<span class="go">&lt;code object find at 0x00000000033C2810, file &quot;&lt;string&gt;&quot;, line 1&gt;</span>
</pre></div>
</div>
<p>This transcript shows that the code of this function was generated from the string and not
from the real source code file (the “<code class="docutils literal notranslate"><span class="pre">&lt;string&gt;</span></code>” file). It also shows that the actual code
object changes with every call to the <code class="docutils literal notranslate"><span class="pre">api.add_route()</span></code> method (the object’s address in
memory changes).</p>
</div>
<div class="section" id="hy">
<h4>6.3.2. Hy<a class="headerlink" href="#hy" title="Permalink to this headline">¶</a></h4>
<p>Hy (<a class="reference external" href="http://docs.hylang.org/">http://docs.hylang.org/</a>) is the dialect of Lisp, and is written entirely in
Python. Many similar projects that implement other code in Python usually try only to tokenize the
plain form of code that’s provided either as a file-like object or string and interpret it as a
series of explicit Python calls. Unlike others, Hy can be considered as a language that runs
fully in the Python runtime environment, just like Python does. Code written in Hy can use
the existing built-in modules and external packages and vice-versa. Code written with Hy
can be imported back into Python.</p>
<p>To embed Lisp in Python, Hy translates Lisp code directly into Python AST. Import
interoperability is achieved using the import hook that is registered once the Hy module is
imported into Python. Every module with the <code class="docutils literal notranslate"><span class="pre">.hy</span></code> extension is treated as the Hy module
and can be imported like the ordinary Python module. The following is a <em>hello world</em>
program written in this Lisp dialect:</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="c1">;; hyllo.hy</span>
<span class="p">(</span><span class="nv">defn</span> <span class="nv">hello</span> <span class="nv">[]</span> <span class="p">(</span><span class="nb">print</span> <span class="s">&quot;hello world&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>It can be imported and executed with the following Python code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hyllo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hyllo</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span>
<span class="go">hello world</span>
</pre></div>
</div>
<p>If we dig deeper and try to disassemble <code class="docutils literal notranslate"><span class="pre">hyllo.hello</span></code> using the built-in <code class="docutils literal notranslate"><span class="pre">dis</span></code> module, we
will notice that the byte code of the Hy function does not differ significantly from its pure
Python counterpart, as shown in the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">hyllo</span><span class="o">.</span><span class="n">hello</span><span class="p">)</span>
<span class="go">2           0 LOAD_GLOBAL   0 (print)</span>
<span class="go">            3 LOAD_CONST    1 (&#39;hello world!&#39;)</span>
<span class="go">            6 CALL_FUNCTION 1 (1 positional, 0 keyword pair)</span>
<span class="go">            9 RETURN_VALUE</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;hello world!&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="go">1           0 LOAD_GLOBAL   0 (print)</span>
<span class="go">            3 LOAD_CONST    1 (&#39;hello world!&#39;)</span>
<span class="go">            6 CALL_FUNCTION 1 (1 positional, 0 keyword pair)</span>
<span class="go">            9 POP_TOP       10 LOAD_CONST</span>
<span class="go">            0 (None)        13 RETURN_VALUE</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../naming/index.html" class="btn btn-neutral float-right" title="Naming" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../above_class_level/index.html" class="btn btn-neutral float-left" title="Above the class level" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>