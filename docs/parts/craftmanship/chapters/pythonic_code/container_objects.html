

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6. Container objects &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                05/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Craftmanship</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimization/index.html">Code optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../technical_architecture/index.html">Technical architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../low_level/index.html">Low level Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distribution/index.html">Code distribution</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
      <li>6. Container objects</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/parts/craftmanship/chapters/pythonic_code/container_objects.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="container-objects">
<h1>6. Container objects<a class="headerlink" href="#container-objects" title="Permalink to this headline">¶</a></h1>
<p>Python provides a good selection of built-in data containers that allow you to efficiently
solve many problems if you choose them wisely. Types that you should already know of
are those that have dedicated literals:</p>
<ul class="simple">
<li><p>Lists</p></li>
<li><p>Tuples</p></li>
<li><p>Dictionaries</p></li>
<li><p>Sets</p></li>
</ul>
<p>Python is, of course, not limited to these four containers, and it extends the list of possible
choices through its standard library. In many cases, solutions to some problems may be as
simple as making a good choice for the data structure to hold your data.</p>
<div class="section" id="lists-and-tuples">
<h2>6.1. Lists and tuples<a class="headerlink" href="#lists-and-tuples" title="Permalink to this headline">¶</a></h2>
<p>Two of the most basic collection types in Python are lists and tuples, and they both
represent sequences of objects. The basic difference between them should be obvious for
anyone who has spent more than a few hours with Python; lists are dynamic, so they can
change their size, while tuples are immutable (cannot be modified after they are created).</p>
<p>Lists and tuples in Python have various optimizations that make allocations/deallocations
of small objects fast. They are also the recommended datatypes for structures where the
position of the element is information by itself. For example, a tuple may be a good choice
for storing a pair of (x, y) coordinates. Implementation details regarding tuples are not
interesting. The only important thing about them in the scope of this chapter is
that tuple is immutable and thus hashable. A detailed explanation of this section will be
covered later in the Dictionaries section. More interesting than tuples is its dynamic
counterpart: lists. In the next section, we will discuss how it really works, and how to deal
with it efficiently.</p>
<div class="section" id="implementation-details">
<h3>6.1.1. Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h3>
<p>Many programmers easily confuse Python’s <code class="docutils literal notranslate"><span class="pre">list</span></code> type with the concept of linked lists
which are found often in standard libraries of other languages, such as C, C++, or Java. In
fact, CPython lists are not lists at all. In CPython, lists are implemented as variable length
arrays. This should be also true for other implementations, such as Jython and IronPython,
although such implementation details are often not documented in these projects. The
reasons for such confusion is clear. This datatype is named <code class="docutils literal notranslate"><span class="pre">list</span></code> and also has an interface
that could be expected from any linked list implementation.</p>
<p>Why it is important and what does it mean? Lists are one of the most popular data
structures, and the way in which they are used greatly affects every application’s
performance. CPython is the most popular and used implementation, so knowing its
internal implementation details is crucial.</p>
<p>Lists in Python are contiguous arrays of references to other objects. The pointer to this array
and the length is stored in the list’s head structure. This means that every time an item is
added or removed, the array of references needs to be resized (reallocated). Fortunately, in
Python, these arrays are created with exponential over allocation, so not every operation
requires an actual resize of the underlying array. This is how the amortized cost of
appending and popping elements can be low in terms of complexity. Unfortunately, some
other operations that are considered cheap in ordinary linked lists have relatively high
computational complexity in Python:</p>
<ul class="simple">
<li><p>Inserting an item at an arbitrary place using the <code class="docutils literal notranslate"><span class="pre">list.insert</span></code> method has complexity O(n).</p></li>
<li><p>Deleting an item using <code class="docutils literal notranslate"><span class="pre">list.delete</span></code> or using the del operator har has complexity O(n)</p></li>
</ul>
<p>At least retrieving or setting an element using an index is an operation where cost is
independent of the list’s size, and the complexity of these operations is always O(1).</p>
<p>Let’s define <code class="docutils literal notranslate"><span class="pre">n</span></code> as the length of a list. Here is a full table of average time complexities for
most of the list operations:
====================================  ==========
Operation                             Complexity
====================================  ==========
Copy                                  O(n)
Append                                O(1)
Insert                                O(n)
Get item                              O(1)
Set item                              O(1)
Delete item                           O(n)
Iteration                             O(n)
Get slice of length <code class="docutils literal notranslate"><span class="pre">k</span></code>             O(k)
Del slice                             O(n)
Set slice of length <code class="docutils literal notranslate"><span class="pre">k</span></code>             O(k+n)
Extend                                O(k)
Multiply by <code class="docutils literal notranslate"><span class="pre">k</span></code>                     O(nk)
Test existence (<code class="docutils literal notranslate"><span class="pre">element</span> <span class="pre">in</span> <span class="pre">list</span></code>)  O(n)
<code class="docutils literal notranslate"><span class="pre">min()/max()</span></code>                       O(n)
Get length                            O(1)
====================================  ==========</p>
<p>For situations where a real linked list or doubly linked list is required, Python provides
a <code class="docutils literal notranslate"><span class="pre">deque</span></code> type in the <code class="docutils literal notranslate"><span class="pre">collections</span></code> built-in module. This is a data structure that allows us to
append and pop elements at each side with O(1) complexity. This is a generalization of
stacks and queues, and should work fine anywhere where a doubly linked list is required.</p>
</div>
<div class="section" id="list-comprehensions">
<h3>6.1.2. List comprehensions<a class="headerlink" href="#list-comprehensions" title="Permalink to this headline">¶</a></h3>
<p>As you probably know, writing a piece of code such as this can be tedious:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">evens</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">evens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evens</span>
<span class="go">[0, 2, 4, 6, 8]</span>
</pre></div>
</div>
<p>This may work for C, but it actually makes things slower for Python for the following
reasons:</p>
<ul class="simple">
<li><p>It makes the interpreter work on each loop to determine what part of the sequence has to be changed</p></li>
<li><p>It makes you keep a counter to track what element has to be processed</p></li>
<li><p>It requires additional function lookups to be performed at every iteration because <code class="docutils literal notranslate"><span class="pre">append()</span></code> is a list’s method</p></li>
</ul>
<p>A list comprehension is a better pattern for these kind of situations. It allows us to define a
list by using a single line of code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[0, 2, 4, 6, 8]</span>
</pre></div>
</div>
<p>This form of writing is much shorter and involves fewer elements. In a bigger program, this
means less bugs and code that is easier to understand. This is the reason why many
experienced Python programmers will consider such forms as being more readable.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>There is a myth among some Python programmers that list
comprehensions can be a workaround for the fact that the internal array
representing the list object must be resized with every few additions.
Some say that the array will be allocated once in just the right size.
Unfortunately, this isn’t true.</p>
<p>The interpreter, during evaluation of the comprehension, can’t know how
big the resulting container will be, and it can’t preallocate the final size of
the array for it. Due to this, the internal array is reallocated in the same
pattern as it would be in the for loop. Still, in many cases, list creation
using comprehensions is both cleaner and faster than using ordinary
loops.</p>
</div>
</div>
<div class="section" id="other-idioms">
<h3>6.1.3. Other idioms<a class="headerlink" href="#other-idioms" title="Permalink to this headline">¶</a></h3>
<p>Another typical example of a Python idiom is the use of <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code>. This built-in
function provides a convenient way to get an index when a sequence is iterated inside of a
loop. Consider the following piece of code as an example of tracking the element index
without the <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="go">0 one</span>
<span class="go">1 two</span>
<span class="go">2 three</span>
</pre></div>
</div>
<p>This can be replaced with the following code, which is shorter and definitely cleaner:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">0 one</span>
<span class="go">1 two</span>
<span class="go">2 three</span>
</pre></div>
</div>
<p>If you need to aggregate elements of multiple lists (or any other iterables) in the one-by-one
fashion, you can use the built-in <code class="docutils literal notranslate"><span class="pre">zip()</span></code>. This is a very common pattern for uniform iteration
over two same-sized iterables:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, 4)</span>
<span class="go">(2, 5)</span>
<span class="go">(3, 6)</span>
</pre></div>
</div>
<p>Note that the results of <code class="docutils literal notranslate"><span class="pre">zip()</span></code> can be reversed by another <code class="docutils literal notranslate"><span class="pre">zip()</span></code> call:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, 2, 3)</span>
<span class="go">(4, 5, 6)</span>
</pre></div>
</div>
<p>One important thing you need to remember about the <code class="docutils literal notranslate"><span class="pre">zip()</span></code> function is that it expects
input iterables to be the same size. If you provide arguments of different lengths, then it
will trim the output to the shortest argument, as shown in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">(1, 1)</span>
<span class="go">(2, 2)</span>
</pre></div>
</div>
<p>Another popular syntax element is sequence unpacking. It is not limited to lists and tuples,
and will work with any sequence type (even strings and byte sequences). It allows us to
unpack a sequence of elements into another set of variables as long as there are as many
variables on the left-hand side of the assignment operator as the number of elements in the
sequence. If you paid attention to the code snippets, then you might have already noticed
this idiom when we were discussing the <code class="docutils literal notranslate"><span class="pre">enumerate()</span></code> function.</p>
<p>The following is a dedicated example of that syntax element:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span> <span class="o">=</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first</span>
<span class="go">&#39;foo&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">second</span>
<span class="go">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">third</span>
<span class="go">100</span>
</pre></div>
</div>
<p>Unpacking also allows us to capture multiple elements in a single variable using starred
expressions as long as it can be interpreted unambiguously. Unpacking can also be
performed on nested sequences. This can come in handy, especially when iterating on some
complex data structures built out of multiple sequences. Here are some examples of more
complex sequence unpacking:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">second</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rest</span>
<span class="go">[2, 3]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">first</span><span class="p">,</span> <span class="o">*</span><span class="n">inner</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">first</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inner</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">last</span>
<span class="go">3</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="go">(1, 2, 3, 4)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="dictionaries">
<h2>6.2. Dictionaries<a class="headerlink" href="#dictionaries" title="Permalink to this headline">¶</a></h2>
<p>Dictionaries are one of most versatile data structures in Python. The <code class="docutils literal notranslate"><span class="pre">dict</span></code> type allows you
to map a set of unique keys to values, as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39; one&#39;</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39; two&#39;</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="s1">&#39; three&#39;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Dictionary literals are a very basic thing, and you should already know about them. Python
allows programmers to also create a new dictionary using comprehensions, similar to the
list comprehensions mentioned earlier. Here is a very simple example that maps numbers
in a range from 0 to 99 to their squares:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">squares</span> <span class="o">=</span> <span class="p">{</span><span class="n">number</span><span class="p">:</span> <span class="n">number</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)}</span>
</pre></div>
</div>
<p>What is important is that the same benefits of using list comprehensions apply to dictionary
comprehensions. So, in many cases, they are more efficient, shorter, and cleaner. For more
complex code, when many <code class="docutils literal notranslate"><span class="pre">if</span></code> statements or function calls are required to create a
dictionary, the simple <code class="docutils literal notranslate"><span class="pre">for</span></code> loop may be a better choice, especially if it improves readability.</p>
<p>For Python programmers new to Python 3, there is one important note about iterating over
dictionary elements. The <code class="docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="docutils literal notranslate"><span class="pre">values()</span></code>, and <code class="docutils literal notranslate"><span class="pre">items()</span></code> dictionary methods are no
longer return lists. Also, their counterparts, <code class="docutils literal notranslate"><span class="pre">iterkeys()</span></code>, <code class="docutils literal notranslate"><span class="pre">itervalues()</span></code>,
and <code class="docutils literal notranslate"><span class="pre">iteritems()</span></code>, which returned iterators instead, are missing in Python 3. Now,
the <code class="docutils literal notranslate"><span class="pre">keys()</span></code>, <code class="docutils literal notranslate"><span class="pre">values()</span></code>, and <code class="docutils literal notranslate"><span class="pre">items()</span></code> methods return special view objects:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">keys()</span></code>: This returns the dict_keys object which provides a view on all keys of the dictionary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">values()</span></code>: This returns the dict_values object which provides a view on all values of the dictionary</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">items()</span></code>: This returns the dict_items object, providing views on all (key, value) two-tuples of the dictionary</p></li>
</ul>
<p>View objects provide a view on the dictionary content in a dynamic way so that every time
the dictionary changes, the views will reflect these changes, as shown in this example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">person</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;last_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Doe&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">person</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">items</span>
<span class="go">dict_items([(&#39;name&#39;, &#39;John&#39;), (&#39;last_name&#39;, &#39;Doe&#39;), (&#39;age&#39;, 42)])</span>
</pre></div>
</div>
<p>View objects join the behavior of lists returned by the implementation of old methods with
iterators that have been returned by their ´´iter´´ counterparts. Views do not need to
redundantly store all values in memory (like lists do), but are still allowed to access their
length (using the ´´len()´´ function) and testing for membership (using the ´´in´´ keyword).
Views are, of course, iterable.</p>
<p>The last important thing about views is that both view objects returned by
the <code class="docutils literal notranslate"><span class="pre">keys()</span></code> and <code class="docutils literal notranslate"><span class="pre">values()</span></code> methods ensure the same order of keys and values. In Python 2,
you could not modify the dictionary content between these two calls if you wanted to
ensure the same order of retrieved keys and values. <code class="docutils literal notranslate"><span class="pre">dict_keys</span></code> and <code class="docutils literal notranslate"><span class="pre">dict_values</span></code> are now
dynamic, so even if the content of the dictionary changes between
the <code class="docutils literal notranslate"><span class="pre">keys()</span></code> and <code class="docutils literal notranslate"><span class="pre">values()</span></code> calls, the order of iteration is consistent between these two
views.</p>
<div class="section" id="id1">
<h3>6.2.1. Implementation details<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>CPython uses hash tables with pseudo-random probing as an underlying data structure for
dictionaries. It seems like a very deep implementation detail, but it is very unlikely to
change in the near future, so it is also a very interesting fact for the Python programmer.</p>
<p>Due to this implementation detail, only objects that are hashable can be used as a
dictionary key. An object is hashable if it has a hash value that never changes during its
lifetime, and can be compared to different objects. Every Python built-in type that is
immutable is also hashable. Mutable types, such as list, dictionaries, and sets, are not
hashable, and so they cannot be used as dictionary keys. Protocol that defines if a type is
hashable consists of two methods:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">__hash__</span></code>: This provides the hash value (as an integer) that is needed by the internal <code class="docutils literal notranslate"><span class="pre">dict</span></code> implementation. For objects that are instances of user-defined classes, it is derived from their <code class="docutils literal notranslate"><span class="pre">id()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">__eq__</span></code>: This compares if two objects have the same value. All objects that are instances of user-defined classes compare as unequal by default, except for themselves.</p></li>
</ul>
<p>Two objects that are compared as equal must have the same hash value. The reverse does
not need to be true. This means that collisions of hashes are possible: two objects with the
same hash may not be equal. It is allowed, and every Python implementation must be able
to resolve hash collisions. CPython uses open addressing to resolve them. The
probability of collisions greatly affects dictionary performance, and, if it is high, the
dictionary will not benefit from its internal optimizations.</p>
<p>While three basic operations, adding, getting, and deleting an item, have an average time
complexity equal to O(1), their amortized worst case complexities are a lot higher. It is O(n),
where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the current dictionary size. Additionally, if user-defined class objects are used as
dictionary keys and they are hashed improperly (with a high risk of collisions), this will
have a huge negative impact on the dictionary’s performance. The full table of CPython’s
time complexities for dictionaries is as follows:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 30%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Average complexity</p></th>
<th class="head"><p>Amortized worst case complexity</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Get item</p></td>
<td><p>O(1)</p></td>
<td><p>O(n)</p></td>
</tr>
<tr class="row-odd"><td><p>Set item</p></td>
<td><p>O(1)</p></td>
<td><p>O(n)</p></td>
</tr>
<tr class="row-even"><td><p>Delete item</p></td>
<td><p>O(1)</p></td>
<td><p>O(n)</p></td>
</tr>
<tr class="row-odd"><td><p>Copy</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
</tr>
<tr class="row-even"><td><p>Iteration</p></td>
<td><p>O(n)</p></td>
<td><p>O(n)</p></td>
</tr>
</tbody>
</table>
<p>It is also important to know that the <code class="docutils literal notranslate"><span class="pre">n</span></code> number in worst case complexities for copying and
iterating the dictionary is the maximum size that the dictionary ever achieved, rather than
the size at the time of operation. In other words, iterating over the dictionary that once was
huge but greatly shrunk in time may take a surprisingly long time. In some cases, it may be
better to create a new dictionary object from a dictionary that needs to be shrunk if it has to
be iterated often instead of just removing elements from it.</p>
</div>
<div class="section" id="weaknesses-and-alternatives">
<h3>6.2.2. Weaknesses and alternatives<a class="headerlink" href="#weaknesses-and-alternatives" title="Permalink to this headline">¶</a></h3>
<p>For a very long time, one of the most common pitfalls regarding dictionaries was expecting
that they preserve the order of elements in which new keys were added. The situation has
changed a bit in Python 3.6, and the problem was finally solved in Python 3.7 on the level
of language specification.</p>
<p>But, before we dig deeper into the situation of Python 3.6 and later releases, we need to
make a small detour and examine the problem as if we were still stuck in the past, when the
only Python releases available were older than 3.6. In the past, you could have a situation
where the consecutive dictionary keys also had hashes that were consecutive values too.
And, for a very long time, this was the only situation when you could expect that you
would iterate over dictionary elements in the same order as they were added to the
dictionary. The easiest way to present this is by using integer numbers, as hashes of integer
numbers are the same as their value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">number</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">dict_keys([0, 1, 2, 3, 4])</span>
</pre></div>
</div>
<p>Using other datatypes that hash differently could show that the order is not preserved.
Here is an example that was executed in CPython 3.5:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">):</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)}</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">dict_keys([&#39;1&#39;, &#39;2&#39;, &#39;4&#39;, &#39;0&#39;, &#39;3&#39;])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">):</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))}</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">dict_keys([&#39;2&#39;, &#39;3&#39;, &#39;1&#39;, &#39;4&#39;, &#39;0&#39;])</span>
</pre></div>
</div>
<p>As shown in the preceding code, for CPython 3.5 (and also earlier versions), the resulting
order is both dependent on the hashing of the object and also on the order in which the
elements were added. This is definitely not what can be relied on, because it can vary with
different Python implementations.</p>
<p>So, what about Python 3.6 and later releases? Starting from Python 3.6, the CPython
interpreter uses a new compact dictionary representation that has a noticeably smaller
memory footprint and also preserves order as a side effect of that new implementation. In
Python 3.6, the order preserving nature of dictionaries was only an implementation detail,
but in Python 3.7, it has been officially declared in the Python language specification. So,
starting from Python 3.7, you can finally rely on the item insertion order of dictionaries.</p>
<p>In parallel to the CPython implementation of dictionaries, Python 3.6 introduced another
change in the syntax that is related to the order of items in dictionaries. As defined in the
PEP 486 “Preserving the order of <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> in a function” document, the order of keyword
arguments collected using the <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> syntax must be the same as presented in function
call. This behavior can be clearly presented with the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">fun</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fun</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">{&#39;c&#39;: 1, &#39;b&#39;: 2, &#39;a&#39;: 3}</span>
</pre></div>
</div>
<p>However the preceding changes can be used effectively only in the newest releases of
Python. So, what should you do if you have a library that must work on older versions of
Python too, and some parts of its code requires order-preserving dictionaries? The best
option is to be clear about your expectations regarding dictionary ordering and use a type
that explicitly preserves the order of elements.</p>
<p>Fortunately, the Python standard library provides an ordered dictionary type
called <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> in the <code class="docutils literal notranslate"><span class="pre">collections</span></code> module. The constructor of this type accepts
<code class="docutils literal notranslate"><span class="pre">iterable</span></code> as the initialization argument. Each element of that argument should be a pair of a
dictionary key and value, as in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">OrderedDict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">number</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">odict_keys([&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;])</span>
</pre></div>
</div>
<p>It also has some additional features, such as popping items from both ends using
the <code class="docutils literal notranslate"><span class="pre">popitem()</span></code> method, or moving the specified element to one of the ends using
the`` move_to_end()`` method. A full reference on that collection is available in the Python
documentation (refer to
<a class="reference external" href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>). Even if
you target only Python in version 3.7 or newer, which guarantees the preservation of the
item insertion order, the <code class="docutils literal notranslate"><span class="pre">OrderedDict</span> <span class="pre">type</span></code> is still useful. It allows you to make your
intention clear. If you define your variable with <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code> instead of a plain dict, it
becomes obvious that, in this particular case, the order of inserted items is important.</p>
<p>The last interesting note is that, in very old code bases, you can find <code class="docutils literal notranslate"><span class="pre">dict</span></code> as a primitive set
implementation that ensures uniqueness of elements. While this will give proper results,
you should avoid such use of that type unless you target Python versions lower than 2.3.
Using dictionaries in this way is wasteful in terms of resources. Python has a builtin <code class="docutils literal notranslate"><span class="pre">set</span></code>
type that serves this purpose. In fact, it has very similar internal implementation to
dictionaries in CPython, but offers some additional features, as well as specific set-related
optimizations.</p>
</div>
</div>
<div class="section" id="sets">
<h2>6.3. Sets<a class="headerlink" href="#sets" title="Permalink to this headline">¶</a></h2>
<p>Sets are a very robust data structure that are mostly useful in situations where the order of
elements is not as important as their uniqueness. They are also useful if you need to
efficiently check efficiency if the element is contained in a collection. Sets in Python are
generalizations of mathematic sets, and are provided as built-in types in two flavors:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">set()</span></code>: This is a mutable, non-ordered, finite collection of unique, immutable (hashable) objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frozenset()</span></code>: This is an immutable, hashable, non-ordered collection of unique, immutable (hashable) objects</p></li>
</ul>
<p>The immutability of <code class="docutils literal notranslate"><span class="pre">frozenset()</span></code> objects makes it possible for them to be included as
dictionary keys and also other <code class="docutils literal notranslate"><span class="pre">set()</span></code> and <code class="docutils literal notranslate"><span class="pre">frozenset()</span></code> elements. A plain
mutable <code class="docutils literal notranslate"><span class="pre">set()</span></code> object cannot be used within another <code class="docutils literal notranslate"><span class="pre">set()</span></code> or <code class="docutils literal notranslate"><span class="pre">frozenset()</span></code>. Attempting
to do so will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> exception, as in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">([</span><span class="nb">set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">set</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="gr"> File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;set&#39;</span>
</pre></div>
</div>
<p>On the other hand, the following <code class="docutils literal notranslate"><span class="pre">set</span></code> initializations are completely correct, and do not raise
exceptions:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">([</span><span class="nb">frozenset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">frozenset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])])</span>
<span class="go">{frozenset({1, 2, 3}), frozenset({2, 3, 4})}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">frozenset</span><span class="p">([</span><span class="nb">frozenset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">frozenset</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])])</span>
<span class="go">frozenset({frozenset({1, 2, 3}), frozenset({2, 3, 4})})</span>
</pre></div>
</div>
<p>Mutable sets can be created in three ways:</p>
<ul class="simple">
<li><p>Using a <code class="docutils literal notranslate"><span class="pre">set()</span></code> call that accepts optional iterables as the initialization argument, such as <code class="docutils literal notranslate"><span class="pre">set([0,</span> <span class="pre">1,</span> <span class="pre">2])</span></code></p></li>
<li><p>Using a set comprehension such as <code class="docutils literal notranslate"><span class="pre">{element</span> <span class="pre">for</span> <span class="pre">element</span> <span class="pre">in</span> <span class="pre">range(3)}</span></code></p></li>
<li><p>Using set literals such as <code class="docutils literal notranslate"><span class="pre">{1,</span> <span class="pre">2,</span> <span class="pre">3}</span></code></p></li>
</ul>
<p>Note that using literals and comprehensions for sets requires extra caution, because they
are very similar in form to dictionary literals and comprehensions. Also, there is no literal
for empty set objects: empty curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> are reserved for empty dictionary literals.</p>
<div class="section" id="id2">
<h3>6.3.1. Implementation details<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Sets in CPython are very similar to dictionaries. As a matter of fact, they are implemented
like dictionaries with dummy values, where only keys are actual collection elements. Sets
also exploit this lack of values in mapping for additional optimizations.</p>
<p>Thanks to this, sets allow very fast additions, deletions, and checks for element existence
with the average time complexity equal to O(1). Still, since the implementation of sets in
CPython relies on a similar hash table structure, the worst case complexity for these
operations is still O(n), where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the current size of a set.</p>
<p>Other implementation details also apply. The item to be included in a set must be hashable,
and, if instances of user-defined classes in the set are hashed poorly, this will have a
negative impact on their performance.</p>
<p>Despite their conceptual similarity to dictionaries, sets in Python 3.7 do not preserve the
order of elements in specification, or as a detail of CPython implementation.
Let’s take a look at the supplemental data types and containers.</p>
</div>
</div>
<div class="section" id="supplemental-data-types-and-containers">
<h2>6.4. Supplemental data types and containers<a class="headerlink" href="#supplemental-data-types-and-containers" title="Permalink to this headline">¶</a></h2>
<p>In the previous subsections, we concentrated mostly on those data types that have
dedicated literals in the Python syntax. These were also the types that are implemented at
the interpreter-level. However, Python’s standard library offers a great collection of
supplemental data types that can be effectively used in places where the basic built-in types
show their shortcomings, or places where the nature of the data requires specialized
handling (for example, in the presentation of time and dates).</p>
<p>The most common are data containers that are found in the collections, and we have
already briefly mentioned two of them: <code class="docutils literal notranslate"><span class="pre">deque</span></code> and <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>. However, the landscape
of data structures available for Python programmers is enormous and almost every module
of the Python standard library defines some specialized types for handling the data of
different problem domains.</p>
<div class="section" id="specialized-data-containers-from-the-collections-module">
<h3>6.4.1. Specialized data containers from the collections module<a class="headerlink" href="#specialized-data-containers-from-the-collections-module" title="Permalink to this headline">¶</a></h3>
<p>Every data structure has its shortcomings. There is no single collection that can suit every
problem, and four basic types of them (tuple, list, set, and dictionary) is still not a wide
range of choices. These are the most basic and important collections that have a dedicated
literal syntax. Fortunately, Python provides far more options in its standard library through
the <code class="docutils literal notranslate"><span class="pre">collections</span></code> built-in module. Here are the most important universal data containers
provided by this module:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">namedtuple()</span></code>: This is a factory function for creating tuple subclasses whose indexes can be accessed as named attributes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deque</span></code>: This is a double-ended queue, a list-like generalization of stacks and queues with fast appends and pops on both ends</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ChainMap</span></code>: This is a dictionary-like class to create a single view of multiple mappings</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Counter</span></code>: This is a dictionary subclass for counting hashable objects</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>: This is a dictionary subclass that preserves the order that the entries were added in</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultdict</span></code>: This is a dictionary subclass that can supply missing values using a user-defined factory function</p></li>
</ul>
</div>
<div class="section" id="symbolic-enumeration-with-the-enum-module">
<h3>6.4.2. Symbolic enumeration with the enum module<a class="headerlink" href="#symbolic-enumeration-with-the-enum-module" title="Permalink to this headline">¶</a></h3>
<p>One of the special handy types found in the Python standard is the <code class="docutils literal notranslate"><span class="pre">Enum</span></code> class from the
<code class="docutils literal notranslate"><span class="pre">enum</span></code> module. This is a base class that allows you to define symbolic enumerations, similar
in concept to the enumerated types found in many other programming languages (C, C++,
C#, Java, and many more) that are often denoted with the <code class="docutils literal notranslate"><span class="pre">enum</span></code> keyword.</p>
<p>In order to define your own enumeration in Python, you will need to subclass the <code class="docutils literal notranslate"><span class="pre">Enum</span></code>
class and define all enumeration members as class attributes. The following is an example
of a simple Python <code class="docutils literal notranslate"><span class="pre">enum</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="k">class</span> <span class="nc">Weekday</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">MONDAY</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">TUESDAY</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">WEDNESDAY</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">THURSDAY</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">FRIDAY</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">SATURDAY</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">SUNDAY</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div>
</div>
<p>The Python documentation defines the following nomenclature for <code class="docutils literal notranslate"><span class="pre">enum</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">enumeration</span></code> or <code class="docutils literal notranslate"><span class="pre">enum</span></code>: This is the subclass of <code class="docutils literal notranslate"><span class="pre">Enum</span></code> base class. Here, it would be <code class="docutils literal notranslate"><span class="pre">Weekday</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">member</span></code>: This is the attribute you define in the Enum subclass. Here, it would be <code class="docutils literal notranslate"><span class="pre">Weekday.MONDAY</span></code>, <code class="docutils literal notranslate"><span class="pre">Weekday.TUESDAY</span></code>, and so on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code>: This is the name of the <code class="docutils literal notranslate"><span class="pre">Enum</span></code> subclass attribute that defines the member. Here, it would be <code class="docutils literal notranslate"><span class="pre">MONDAY</span></code> for <code class="docutils literal notranslate"><span class="pre">Weekday.MONDAY</span></code>, <code class="docutils literal notranslate"><span class="pre">TUESDAY</span></code> for <code class="docutils literal notranslate"><span class="pre">Weekday.TUESDAY</span></code>, and so on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value</span></code>: This is the value assigned to the Enum subclass attribute that defines the <code class="docutils literal notranslate"><span class="pre">member</span></code>. Here, for <code class="docutils literal notranslate"><span class="pre">Weekday.MONDAY</span></code> it would be one, for <code class="docutils literal notranslate"><span class="pre">Weekday.TUESDAY</span></code> it would be two, and so on.</p></li>
</ul>
<p>You can use any type as the <code class="docutils literal notranslate"><span class="pre">enum</span></code> member value. If the member value is not important in
your code, you can even use the <code class="docutils literal notranslate"><span class="pre">auto()</span></code> type, which will be replaced with automatically
generated values. Here is the previous example rewritten with the use of <code class="docutils literal notranslate"><span class="pre">auto</span></code> in it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>


<span class="k">class</span> <span class="nc">Weekday</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
     <span class="n">MONDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">TUESDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">WEDNESDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">THURSDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">FRIDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">SATURDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">SUNDAY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
</pre></div>
</div>
<p>Enumerations in Python are really useful in every place where some variable can take a
finite number of values/choices. For instance, they can be used to define statues of objects,
as shown in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>


<span class="k">class</span> <span class="nc">OrderStatus</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
     <span class="n">PENDING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">PROCESSING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">PROCESSED</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Order</span><span class="p">:</span>
     <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">OrderStatus</span><span class="o">.</span><span class="n">PENDING</span>

     <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">OrderStatus</span><span class="o">.</span><span class="n">PROCESSED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t process order that has been already processed&quot;</span><span class="p">)</span>

         <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">OrderStatus</span><span class="o">.</span><span class="n">PROCESSING</span>
         <span class="o">...</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">OrderStatus</span><span class="o">.</span><span class="n">PROCESSED</span>
</pre></div>
</div>
<p>Another use case for enumerations is storing selections of non-exclusive choices. This is
something that is often implemented using bit flags and bit masks in languages where bit
manipulation of numbers is very common, like C. In Python, this can be done in a more
expressive and convenient way using <code class="docutils literal notranslate"><span class="pre">FlagEnum</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Flag</span><span class="p">,</span> <span class="n">auto</span>


<span class="k">class</span> <span class="nc">Side</span><span class="p">(</span><span class="n">Flag</span><span class="p">):</span>
     <span class="n">GUACAMOLE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">TORTILLA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">FRIES</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">BEER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
     <span class="n">POTATO_SALAD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
</pre></div>
</div>
<p>You can combine such flags using bitwise operations (the <code class="docutils literal notranslate"><span class="pre">|</span></code> and <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operators) and test for
flag membership with the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword. Here are some examples for a <code class="docutils literal notranslate"><span class="pre">Side</span></code> enumeration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mexican_sides</span> <span class="o">=</span> <span class="n">Side</span><span class="o">.</span><span class="n">GUACAMOLE</span> <span class="o">|</span> <span class="n">Side</span><span class="o">.</span><span class="n">BEER</span> <span class="o">|</span> <span class="n">Side</span><span class="o">.</span><span class="n">TORTILLA</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bavarian_sides</span> <span class="o">=</span> <span class="n">Side</span><span class="o">.</span><span class="n">BEER</span> <span class="o">|</span> <span class="n">Side</span><span class="o">.</span><span class="n">POTATO_SALAD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_sides</span> <span class="o">=</span> <span class="n">mexican_sides</span> <span class="o">&amp;</span> <span class="n">bavarian_sides</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Side</span><span class="o">.</span><span class="n">GUACAMOLE</span> <span class="ow">in</span> <span class="n">mexican_sides</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Side</span><span class="o">.</span><span class="n">TORTILLA</span> <span class="ow">in</span> <span class="n">bavarian_sides</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_sides</span>
<span class="go">&lt;Side.BEER: 8&gt;</span>
</pre></div>
</div>
<p>Symbolic enumerations share some similarity with dictionaries and named tuples because
they all map names/keys to values. The main difference is that the <code class="docutils literal notranslate"><span class="pre">Enum</span></code> definition is
immutable and global. It should be used whenever there is a closed set of possible values
that can’t change dynamically during program runtime, and especially if that set should be
defined only once and globally. Dictionaries and named tuples are data containers. You can
create as many instances of them as you like.</p>
</div>
</div>
<div class="section" id="custom-containers">
<h2>6.5. Custom containers<a class="headerlink" href="#custom-containers" title="Permalink to this headline">¶</a></h2>
<p>Containers are objects that implement a <code class="docutils literal notranslate"><span class="pre">__contains__</span></code> method (that usually returns a Boolean value). This method is
called in the presence of the <code class="docutils literal notranslate"><span class="pre">in</span></code> keyword of Python. Something like <code class="docutils literal notranslate"><span class="pre">element</span> <span class="pre">in</span> <span class="pre">container</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">container.__contains__(element)</span></code>.</p>
<p>You can imagine how much more readable and Pythonic the code can be when this method is properly implemented.</p>
<p>Let’s say we have to mark some points on a map of a game that has two-dimensional coordinates. We might expect to find a
function like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mark_coordinate</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">coord</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">coord</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">MARKED</span>
</pre></div>
</div>
<p>Now, the part that checks the condition of the first if statement seems convoluted; it doesn’t reveal the intention of
the code, it’s not expressive, and worst of all it calls for code duplication (every part of the code where we need to
check the boundaries before proceeding will have to repeat that if statement).</p>
<p>What if the map itself (called grid on the code) could answer this question? Even better, what if the map could delegate
this action to an even smaller (and hence more cohesive) object? Therefore, we can ask the map if it contains a
coordinate, and the map itself can have information about its limit, and ask this object the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Boundaries</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>

<span class="k">class</span> <span class="nc">Grid</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">Boundaries</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">coord</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">limits</span>
</pre></div>
</div>
<p>This code alone is a much better implementation. First, it is doing a simple composition and it’s using delegation to
solve the problem. Both objects are really cohesive, having the minimal possible logic; the methods are short, and the
logic speaks for itself: <code class="docutils literal notranslate"><span class="pre">coord</span> <span class="pre">in</span> <span class="pre">self.limits</span></code> is pretty much a declaration of the problem to solve, expressing the
intention of the code.</p>
<p>From the outside, we can also see the benefits. It’s almost as if Python is solving the problem for us:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mark_coordinate</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">coord</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
        <span class="n">grid</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span> <span class="o">=</span> <span class="n">MARKED</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>