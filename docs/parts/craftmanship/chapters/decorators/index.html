

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Decorators &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="Descriptors" href="../descriptors/index.html" />
    <link rel="prev" title="SOLID" href="../solid_principles/index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                05/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Craftmanship</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../pythonic_code/index.html">Pythonic code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../general_traits/index.html">General traits of good code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../solid_principles/index.html">SOLID</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Decorators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#what-are-decorators">1. What are decorators?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-are-decorators-in-python">1.1. What are decorators in Python?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#decorate-functions">1.2. Decorate functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#decorate-classes">1.2. Decorate classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-types-of-decorator">1.3. Other types of decorator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#passing-arguments-to-decorators">1.4. Passing arguments to decorators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#good-uses-for-decorators">1.5. Good uses for decorators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#effective-decorators-avoid-common-mistakes">2. Effective decorators: avoid common mistakes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#preserving-data-about-the-original-wrapped-object">2.1. Preserving data about the original wrapped object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealing-with-side-effects-in-decorators">2.2. Dealing with side-effects in decorators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-decorators-that-will-always-work">2.3. Creating decorators that will always work</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-dry-principle-with-decorators">3. The DRY principle with decorators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decorators-and-separation-of-concerns">4. Decorators and separation of concerns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#analyzing-good-decorators">5. Analyzing good decorators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../descriptors/index.html">Descriptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../generators/index.html">Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../metaprogramming/index.html">Metaprogramming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../naming/index.html">Naming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimization/index.html">Code optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../technical_architecture/index.html">Technical architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../low_level/index.html">Low level Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../distribution/index.html">Code distribution</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Craftmanship</a> &raquo;</li>
        
      <li>Decorators</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/parts/craftmanship/chapters/decorators/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="../descriptors/index.html" class="btn btn-neutral float-right" title="Descriptors" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../solid_principles/index.html" class="btn btn-neutral float-left" title="SOLID" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="decorators">
<h1>Decorators<a class="headerlink" href="#decorators" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-are-decorators">
<h2>1. What are decorators?<a class="headerlink" href="#what-are-decorators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-are-decorators-in-python">
<h3>1.1. What are decorators in Python?<a class="headerlink" href="#what-are-decorators-in-python" title="Permalink to this headline">¶</a></h3>
<p>Decorators were introduced in Python a long time ago as a mechanism to
simplify the way functions and methods are defined when they have to be modified after
their original definition.</p>
<p>One of the original motivations for this was because functions such as <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> and
<code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> were used to transform the original definition of the method, but they
required an extra line, modifying the original definition of the function.</p>
<p>More generally speaking, every time we had to apply a transformation to a function, we
had to call it with the modifier function, and then reassign it to the same name the
function was originally defined with.</p>
<p>For instance, if we have a function called original, and then we have a function that
changes the behavior of original on top of it, called modifier, we have to write
something like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
<span class="o">...</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">modifier</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice how we change the function and reassign it to the same name. This is confusing,
error-prone (imagine that someone forgets to reassign the function, or does reassign that
but not in the line immediately after the function definition, but much farther away), and
cumbersome. For this reason, some syntax support was added to the language.</p>
<p>The previous example could be rewritten like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@modifier</span>
<span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
<span class="o">...</span>
</pre></div>
</div>
<p>This means that decorators are just syntax sugar for calling whatever is after the decorator
as a first parameter of the decorator itself, and the result would be whatever the decorator
returns.</p>
<p>In line with the Python terminology, and our example, modifier is what we call
the decorator, and original is the decorated function, often also called a <strong>wrapped object</strong>.</p>
<p>While the functionality was originally thought for methods and functions, the actual syntax
allows any kind of object to be decorated, so we are going to explore decorators applied to
functions, methods, generators, and classes.</p>
<p>One final note is that, while the name of a decorator is correct (after all, the decorator is in
fact, making changes, extending, or working on top of the wrapped function), it is not to be
confused with the decorator design pattern.</p>
</div>
<div class="section" id="decorate-functions">
<h3>1.2. Decorate functions<a class="headerlink" href="#decorate-functions" title="Permalink to this headline">¶</a></h3>
<p>Functions are probably the simplest representation of a Python object that can be decorated.
We can use decorators on functions to apply all sorts of logic to them—we can validate
parameters, check preconditions, change the behavior entirely, modify its signature, cache
results (create a memorized version of the original function), and more.</p>
<p>As an example, we will create a basic decorator that implements a retry mechanism,
controlling a particular domain-level exception and retrying a certain number of times:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ControlledException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A generic exception on the program&#39;s domain.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">retry</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">last_raised</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">RETRIES_LIMIT</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">RETRIES_LIMIT</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">operation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ControlledException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;retrying </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
                <span class="n">last_raised</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">raise</span> <span class="n">last_raised</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>The use of <code class="docutils literal notranslate"><span class="pre">&#64;wraps</span></code> can be ignored for now. The use of <code class="docutils literal notranslate"><span class="pre">_</span></code> in the for loop, means that
the number is assigned to a variable we are not interested in at the moment, because it’s not
used inside the for loop (it’s a common idiom in Python to name <code class="docutils literal notranslate"><span class="pre">_</span></code> values that are ignored).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">retry</span></code> decorator doesn’t take any parameters, so it can be easily applied to any
function, as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@retry</span>
<span class="k">def</span> <span class="nf">run_operation</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Run a particular task, simulating some failures on its execution.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>As explained at the beginning, the definition of <code class="docutils literal notranslate"><span class="pre">&#64;retry</span></code> on top of <code class="docutils literal notranslate"><span class="pre">run_operation</span></code> is just
syntactic sugar that Python provides to actually execute <code class="docutils literal notranslate"><span class="pre">run_operation</span> <span class="pre">=</span> <span class="pre">retry(run_operation)</span></code>.</p>
<p>In this limited example, we can see how decorators can be used to create a generic retry
operation that, under certain conditions (in this case, represented as exceptions that could
be related to timeouts, for example), will allow calling the decorated code multiple times.</p>
</div>
<div class="section" id="decorate-classes">
<h3>1.2. Decorate classes<a class="headerlink" href="#decorate-classes" title="Permalink to this headline">¶</a></h3>
<p>Classes can also be decorated with the same as can be applied to syntax
functions. The only difference is that when writing the code for this decorator, we have to
take into consideration that we are receiving a class, not a function.</p>
<p>Some practitioners might argue that decorating a class is something rather convoluted and
that such a scenario might jeopardize readability because we would be declaring some
attributes and methods in the class, but behind the scenes, the decorator might be applying
changes that would render a completely different class.</p>
<p>This assessment is true, but only if this technique is heavily abused. Objectively, this is no
different from decorating functions; after all, classes are just another type of object in the
Python ecosystem, as functions are. For now, we’ll
explore the benefits of decorators that apply particularly to classes:</p>
<ul class="simple">
<li><p>All the benefits of reusing code and the DRY principle. A valid case of a class decorator would be to enforce that multiple classes conform to a certain interface or criteria (by making this checks only once in the decorator that is going to be applied to those many classes).</p></li>
<li><p>We could create smaller or simpler classes that will be enhanced later on by decorators</p></li>
<li><p>The transformation logic we need to apply to a certain class will be much easier to maintain if we use a decorator, as opposed to more complicated (and often rightfully discouraged) approaches such as metaclasses</p></li>
</ul>
<p>Among all possible applications of decorators, we will explore a simple example to give an
idea of the sorts of things they can be useful for. Keep in mind that this is not the only
application type for class decorators, but also that the code we show you could have many
other multiple solutions as well, all with their pros and cons, but we chose decorators with
the purpose of illustrating their usefulness.</p>
<p>Recalling our event systems for the monitoring platform, we now need to transform the
data for each event and send it to an external system. However, each type of event might
have its own particularities when selecting how to send its data.</p>
<p>In particular, the <code class="docutils literal notranslate"><span class="pre">event</span></code> for a login might contain sensitive information such as credentials
that we want to hide. Other fields such as <code class="docutils literal notranslate"><span class="pre">timestamp</span></code> might also require some
transformations since we want to show them in a particular format. A first attempt at
complying with these requirements would be as simple as having a class that maps to each
particular <code class="docutils literal notranslate"><span class="pre">event</span></code> and knows how to serialize it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LoginEventSerializer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">event</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
            <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="s2">&quot;**redacted**&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ip&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">ip</span><span class="p">,</span>
            <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">timestamp</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M&quot;</span><span class="p">)</span>
        <span class="p">}</span>

<span class="k">class</span> <span class="nc">LoginEvent</span><span class="p">:</span>
    <span class="n">SERIALIZER</span> <span class="o">=</span> <span class="n">LoginEventSerializer</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="n">password</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">SERIALIZER</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">serialize</span><span class="p">()</span>
</pre></div>
</div>
<p>Here, we declare a class that is going to map directly with the login event, containing the
logic for it: hide the password field, and format the timestamp as required.</p>
<p>While this works and might look like a good option to start with, as time passes and we
want to extend our system, we will find some issues:</p>
<ul class="simple">
<li><p><strong>Too many classes</strong>: As the number of events grows, the number of serialization classes will grow in the same order of magnitude, because they are mapped one to one.</p></li>
<li><p><strong>The solution is not flexible enough</strong>: If we need to reuse parts of the components (for example, we need to hide the password in another type of event that also has it), we will have to extract this into a function, but also call it repeatedly from multiple classes, meaning that we are not reusing that much code after all.</p></li>
<li><p><strong>Boilerplate</strong>: The <code class="docutils literal notranslate"><span class="pre">serialize()</span></code> method will have to be present in all event classes, calling the same code. Although we can extract this into another class (creating a mixin), it does not seem like a good use of inheritance.</p></li>
</ul>
<p>An alternative solution is to be able to dynamically construct an object that, given a set of
filters (transformation functions) and an event instance, is able to serialize it by applying
the filters to its fields. We then only need to define the functions to transform each type of
field, and the serializer is created by composing many of these functions.</p>
<p>Once we have this object, we can decorate the class in order to add the <code class="docutils literal notranslate"><span class="pre">serialize()</span></code>
method, which will just call these Serialization objects with itself:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hide_field</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s2">&quot;**redacted**&quot;</span>

<span class="k">def</span> <span class="nf">format_time</span><span class="p">(</span><span class="n">field_timestamp</span><span class="p">:</span> <span class="n">datetime</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">field_timestamp</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2"> %H:%M&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show_original</span><span class="p">(</span><span class="n">event_field</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">event_field</span>

<span class="k">class</span> <span class="nc">EventSerializer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">serialization_fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serialization_fields</span> <span class="o">=</span> <span class="n">serialization_fields</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">field</span><span class="p">:</span> <span class="n">transformation</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">field</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">transformation</span> <span class="ow">in</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">serialization_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
<span class="k">class</span> <span class="nc">Serialization</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">transformations</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">EventSerializer</span><span class="p">(</span><span class="n">transformations</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_class</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">serialize_method</span><span class="p">(</span><span class="n">event_instance</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">serialize</span><span class="p">(</span><span class="n">event_instance</span><span class="p">)</span>

        <span class="n">event_class</span><span class="o">.</span><span class="n">serialize</span> <span class="o">=</span> <span class="n">serialize_method</span>
    <span class="k">return</span> <span class="n">event_class</span>

<span class="nd">@Serialization</span><span class="p">(</span>
    <span class="n">username</span><span class="o">=</span><span class="n">show_original</span><span class="p">,</span>
    <span class="n">password</span><span class="o">=</span><span class="n">hide_field</span><span class="p">,</span>
    <span class="n">ip</span><span class="o">=</span><span class="n">show_original</span><span class="p">,</span>
    <span class="n">timestamp</span><span class="o">=</span><span class="n">format_time</span>
<span class="p">)</span>
<span class="k">class</span> <span class="nc">LoginEvent</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="n">password</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">ip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
</pre></div>
</div>
<p>Notice how the decorator makes it easier for the user to know how each field is going to be
treated without having to look into the code of another class. Just by reading the arguments
passed to the class decorator, we know that the username and IP address will be left
unmodified, the password will be hidden, and the timestamp will be formatted.</p>
<p>Now, the code of the class does not need the <code class="docutils literal notranslate"><span class="pre">serialize()</span></code> method defined, nor does it
need to extend from a mixin that implements it, since the decorator will add it. In fact, this
is probably the only part that justifies the creation of the class decorator, because otherwise,
the <code class="docutils literal notranslate"><span class="pre">Serialization</span></code> object could have been a class attribute of <code class="docutils literal notranslate"><span class="pre">LoginEvent</span></code>, but the fact
that it is altering the class by adding a new method to it makes it impossible.</p>
<p>Moreover, we could have another class decorator that, just by defining the attributes of the
class, implements the logic of the init method, but this is beyond the scope of this
example. This is what libraries such as <code class="docutils literal notranslate"><span class="pre">attrs</span></code> do, and a similar functionality is
proposed in for the Standard library.</p>
<p>By using this class decorator, the previous example could be
rewritten in a more compact way, without the boilerplate code of the <code class="docutils literal notranslate"><span class="pre">init</span></code>, as shown here:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="nd">@Serialization</span><span class="p">(</span>
    <span class="n">username</span><span class="o">=</span><span class="n">show_original</span><span class="p">,</span>
    <span class="n">password</span><span class="o">=</span><span class="n">hide_field</span><span class="p">,</span>
    <span class="n">ip</span><span class="o">=</span><span class="n">show_original</span><span class="p">,</span>
    <span class="n">timestamp</span><span class="o">=</span><span class="n">format_time</span>
<span class="p">)</span>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">LoginEvent</span><span class="p">:</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">password</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">ip</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="n">datetime</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> is a decorator that is used to add generated special methods to classes.
It examines the class to find fields. A field is defined as class variable that has a type annotation.
Nothing in <code class="docutils literal notranslate"><span class="pre">dataclass()</span></code> examines the type specified in the variable annotation.</p>
</div>
<div class="section" id="other-types-of-decorator">
<h3>1.3. Other types of decorator<a class="headerlink" href="#other-types-of-decorator" title="Permalink to this headline">¶</a></h3>
<p>Now that we know what the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> syntax for decorators actually means, we can conclude that
it isn’t just functions, methods, or classes that can be decorated; actually, anything that can
be defined, such as generators, coroutines, and even objects that have already been
decorated, can be decorated, meaning that decorators can be stacked.</p>
<p>The previous example showed how decorators can be chained. We first defined the class,
and then applied <code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code> to it, which converted it into a data class, acting as a
container for those attributes. After that, the <code class="docutils literal notranslate"><span class="pre">&#64;Serialization</span></code> will apply the logic to that
class, resulting in a new class with the new <code class="docutils literal notranslate"><span class="pre">serialize()</span></code> method added to it.
Another good use of decorators is for generators that are supposed to be used as
coroutines. The main idea is that, before sending any data to a newly created generator,
the latter has to be advanced up to their next <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement by calling <code class="docutils literal notranslate"><span class="pre">next()</span></code> on it. This
is a manual process that every user will have to remember and hence is error-prone. We
could easily create a decorator that takes a generator as a parameter, calls <code class="docutils literal notranslate"><span class="pre">next()</span></code> to it, and
then returns the generator.</p>
</div>
<div class="section" id="passing-arguments-to-decorators">
<h3>1.4. Passing arguments to decorators<a class="headerlink" href="#passing-arguments-to-decorators" title="Permalink to this headline">¶</a></h3>
<p>At this point, we already regard decorators as a powerful tool in Python. However, they
could be even more powerful if we could just pass parameters to them so that their logic is
abstracted even more.</p>
<p>There are several ways of implementing decorators that can take arguments, but we will go
over the most common ones. The first one is to create decorators as nested functions with a
new level of indirection, making everything in the decorator fall one level deeper. The
second approach is to use a class for the decorator.</p>
<p>In general, the second approach favors readability more, because it is easier to think in
terms of an object than three or more nested functions working with closures. However, for
completeness, we will explore both, and the reader can decide what is best for the problem
at hand.</p>
<div class="section" id="decorators-with-nested-functions">
<h4>1.4.1. Decorators with nested functions<a class="headerlink" href="#decorators-with-nested-functions" title="Permalink to this headline">¶</a></h4>
<p>Roughly speaking, the general idea of a decorator is to create a function that returns a
function (often called a higher-order function). The internal function defined in the body of
the decorator is going to be the one actually being called.</p>
<p>Now, if we wish to pass parameters to it, we then need another level of indirection. The
first one will take the parameters, and inside that function, we will define a new function,
which will be the decorator, which in turn will define yet another new function, namely the
one to be returned as a result of the decoration process. This means that we will have at
least three levels of nested functions.</p>
<p>Don’t worry if this didn’t seem clear so far. After reviewing the examples that are about to
come, everything will become clear.</p>
<p>One of the first examples we saw of decorators implemented the retry functionality over
some functions. This is a good idea, except it has a problem; our implementation did not
allow us to specify the numbers of retries, and instead, this was a fixed number inside the
decorator.</p>
<p>Now, we want to be able to indicate how many retries each instance is going to have, and
perhaps we could even add a default value to this parameter. In order to do this, we need
another level of nested functions—first for the parameters, and then for the decorator itself.
This is because we are now going to have something in the form of the following:
<code class="docutils literal notranslate"><span class="pre">&#64;retry(arg1,</span> <span class="pre">arg2,...</span> <span class="pre">)</span></code>. And that has to return a decorator because the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> syntax will apply the result
of that computation to the object to be decorated. Semantically, it would translate to something
like the following: <code class="docutils literal notranslate"><span class="pre">&lt;original_function&gt;</span> <span class="pre">=</span> <span class="pre">retry(arg1,</span> <span class="pre">arg2,</span> <span class="pre">....)(&lt;original_function&gt;)</span></code></p>
<p>Besides the number of desired retries, we can also indicate the types of exception we wish
to control. The new version of the code supporting the new requirements might look like
this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RETRIES_LIMIT</span> <span class="o">=</span> <span class="mi">3</span>

<span class="k">def</span> <span class="nf">with_retry</span><span class="p">(</span><span class="n">retries_limit</span><span class="o">=</span><span class="n">RETRIES_LIMIT</span><span class="p">,</span> <span class="n">allowed_exceptions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">allowed_exceptions</span> <span class="o">=</span> <span class="n">allowed_exceptions</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ControlledException</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">retry</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">last_raised</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retries_limit</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">operation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">allowed_exceptions</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;retrying </span><span class="si">%s</span><span class="s2"> due to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="n">last_raised</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">raise</span> <span class="n">last_raised</span>
        <span class="k">return</span> <span class="n">wrapped</span>
    <span class="k">return</span> <span class="n">retry</span>
</pre></div>
</div>
<p>Here are some examples of how this decorator can be applied to functions, showing the
different options it accepts:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@with_retry</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">run_operation</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="nd">@with_retry</span><span class="p">(</span><span class="n">retries_limit</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">run_with_custom_retries_limit</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="nd">@with_retry</span><span class="p">(</span><span class="n">allowed_exceptions</span><span class="o">=</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">run_with_custom_exceptions</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="nd">@with_retry</span><span class="p">(</span>
    <span class="n">retries_limit</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">allowed_exceptions</span><span class="o">=</span><span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">run_with_custom_parameters</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="decorator-objects">
<h4>1.4.2. Decorator objects<a class="headerlink" href="#decorator-objects" title="Permalink to this headline">¶</a></h4>
<p>The previous example requires three levels of nested functions. The first it is going to be a
function that receives the parameters of the decorator we want to use. Inside this function,
the rest of the functions are closures that use these parameters along with the logic of the
decorator.</p>
<p>A cleaner implementation of this would be to use a class to define the decorator. In this
case, we can pass the parameters in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method, and then implement the logic of
the decorator on the magic method named <code class="docutils literal notranslate"><span class="pre">__call__</span></code>.</p>
<p>The code for the decorator will look like it does in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WithRetry</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">retries_limit</span><span class="o">=</span><span class="n">RETRIES_LIMIT</span><span class="p">,</span>
        <span class="n">allowed_exceptions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retries_limit</span> <span class="o">=</span> <span class="n">retries_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allowed_exceptions</span> <span class="o">=</span> <span class="n">allowed_exceptions</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ControlledException</span><span class="p">,)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">last_raised</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">retries_limit</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">operation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_exceptions</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;retrying </span><span class="si">%s</span><span class="s2"> due to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="n">last_raised</span> <span class="o">=</span> <span class="n">e</span>

            <span class="k">raise</span> <span class="n">last_raised</span>

        <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>And this decorator can be applied pretty much like the previous one, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@WithRetry</span><span class="p">(</span><span class="n">retries_limit</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">run_with_custom_retries_limit</span><span class="p">(</span><span class="n">task</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>It is important to note how the Python syntax takes effect here. First, we create the object, so
before the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operation is applied, the object is created with its parameters passed to it. This
will create a new object and initialize it with these parameters, as defined in the <code class="docutils literal notranslate"><span class="pre">init</span></code>
method. After this, the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operation is invoked, so this object will wrap the function named
<code class="docutils literal notranslate"><span class="pre">run_with_custom_retries_limit</span></code>, meaning that it will be passed to the call magic
method.</p>
<p>Inside this <code class="docutils literal notranslate"><span class="pre">call</span></code> magic method, we defined the logic of the decorator as we normally
do: we wrap the original function, returning a new one with the logic we want instead.</p>
</div>
</div>
<div class="section" id="good-uses-for-decorators">
<h3>1.5. Good uses for decorators<a class="headerlink" href="#good-uses-for-decorators" title="Permalink to this headline">¶</a></h3>
<p>In this section, we will take a look at some common patterns that make good use of
decorators. These are common situations for when decorators are a good choice.</p>
<p>From all the countless applications decorators can be used for, we will enumerate a few, the
most common or relevant:</p>
<ul class="simple">
<li><p><strong>Transforming parameters</strong>: Changing the signature of a function to expose a nicer API, while encapsulating details on how the parameters are treated and transformed underneath.</p></li>
<li><p><strong>Tracing code</strong>: Logging the execution of a function with its parameters.</p></li>
<li><p><strong>Validate parameters</strong>.</p></li>
<li><p><strong>Implement retry operations</strong>.</p></li>
<li><p><strong>Simplify classes by moving some (repetitive) logic into decorators</strong>.</p></li>
</ul>
<div class="section" id="transforming-parameters">
<h4>1.5.1. Transforming parameters<a class="headerlink" href="#transforming-parameters" title="Permalink to this headline">¶</a></h4>
<p>We have mentioned before that decorators can be used to validate parameters (and even
enforce some preconditions or postconditions under the idea of DbC), so from this you
probably have got the idea that it is somehow common to use decorators when dealing
with or manipulating parameters.</p>
<p>In particular, there are some cases on which we find ourselves repeatedly creating similar
objects, or applying similar transformations that we would wish to abstract away. Most of
the time, we can achieve this by simply using a decorator.</p>
</div>
<div class="section" id="tracing-code">
<h4>1.5.2. Tracing code<a class="headerlink" href="#tracing-code" title="Permalink to this headline">¶</a></h4>
<p>When talking about <strong>tracing</strong> in this section, we will refer to something more general that has
to do with dealing with the execution of a function that we wish to monitor. This could
refer to scenarios in which we want to:</p>
<ul class="simple">
<li><p>Actually trace the execution of a function (for example, by logging the lines it executes)</p></li>
<li><p>Monitor some metrics over a function (such as CPU usage or memory footprint)</p></li>
<li><p>Measure the running time of a function</p></li>
<li><p>Log when a function was called, and the parameters that were passed to it</p></li>
</ul>
</div>
</div>
</div>
<div class="section" id="effective-decorators-avoid-common-mistakes">
<h2>2. Effective decorators: avoid common mistakes<a class="headerlink" href="#effective-decorators-avoid-common-mistakes" title="Permalink to this headline">¶</a></h2>
<p>While decorators are a great feature of Python, they are not exempt from issues if used
incorrectly. In this section, we will see some common issues to avoid in order to create
effective decorators.</p>
<div class="section" id="preserving-data-about-the-original-wrapped-object">
<h3>2.1. Preserving data about the original wrapped object<a class="headerlink" href="#preserving-data-about-the-original-wrapped-object" title="Permalink to this headline">¶</a></h3>
<p>One of the most common problems when applying a decorator to a function is that some of
the properties or attributes of the original function are not maintained, leading to
undesired, and hard-to-track, side-effects.</p>
<p>To illustrate this we show a decorator that is in charge of logging when the function is
about to run:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trace_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;running </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now, let’s imagine we have a function with this decorator applied to it. We might initially
think that nothing of that function is modified with respect to its original definition:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@trace_decorator</span>
<span class="k">def</span> <span class="nf">process_account</span><span class="p">(</span><span class="n">account_id</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Process an account by Id.&quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;processing account </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">account_id</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>But maybe there are changes.</p>
<p>The decorator is not supposed to alter anything from the original function, but, as it turns
out since it contains a flaw it’s actually modifying its name and docstring, among other
properties.</p>
<p>Let’s try to get help for this function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">process_account</span><span class="p">)</span>
<span class="go">Help on function wrapped in module decorator_wraps_1:</span>
<span class="go">wrapped(*args, **kwargs)</span>
</pre></div>
</div>
<p>And let’s check how it’s called:
.. code-block:: python</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">process_account</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;trace_decorator.&lt;locals&gt;.wrapped&#39;</span>
</pre></div>
</div>
<p>We can see that, since the decorator is actually changing the original function for a new one
(called <code class="docutils literal notranslate"><span class="pre">wrapped</span></code>), what we actually see are the properties of this function instead of those
from the original function.</p>
<p>If we apply a decorator like this one to multiple functions, all with different names, they
will all end up being called wrapped, which is a major concern (for example, if we want to
log or trace the function, this will make debugging even harder).</p>
<p>Another problem is that, in case we placed docstrings with tests on these functions, they
will be overridden by those of the decorator. As a result, the docstrings with the test we
want will not run when we call our code with the <code class="docutils literal notranslate"><span class="pre">doctest</span></code> module.</p>
<p>The fix is simple, though. We just have to apply the wraps decorator in the internal
function (<code class="docutils literal notranslate"><span class="pre">wrapped</span></code>), telling it that it is actually wrapping function :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trace_decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;running </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now, if we check the properties, we will obtain what we expected in the first place.
Check help for the function, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Help</span> <span class="n">on</span> <span class="n">function</span> <span class="n">process_account</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">decorator_wraps_2</span><span class="p">:</span>
<span class="go">process_account(account_id)</span>
<span class="go">Process an account by Id.</span>
</pre></div>
</div>
<p>And verify that its qualified name is correct, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">process_account</span><span class="o">.</span><span class="vm">__qualname__</span>
<span class="go">&#39;process_account&#39;</span>
</pre></div>
</div>
<p>Most importantly, we recovered the unit tests we might have had on the docstrings! By
using the wraps decorator, we can also access the original, unmodified function under the
<code class="docutils literal notranslate"><span class="pre">__wrapped__</span></code> attribute. Although it should not be used in production, it might come in
handy in some unit tests when we want to check the unmodified version of the function.</p>
<p>In general, for simple decorators, the way we would use <code class="docutils literal notranslate"><span class="pre">functools.wraps</span></code> would
typically follow the general formula or structure:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">original_function</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">original_function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">decorated_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># modifications done by the decorator ...</span>
        <span class="k">return</span> <span class="n">original_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">return</span> <span class="n">decorated_function</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Always use <code class="docutils literal notranslate"><span class="pre">functools.wraps</span></code> applied over the wrapped function, when creating a decorator, as shown in the preceding formula.</p>
</div>
</div>
<div class="section" id="dealing-with-side-effects-in-decorators">
<h3>2.2. Dealing with side-effects in decorators<a class="headerlink" href="#dealing-with-side-effects-in-decorators" title="Permalink to this headline">¶</a></h3>
<p>In this section, we will learn that it is advisable to avoid side-effects in the body of the
decorator. There are cases where this might be acceptable, but the bottom line is that, if in
case of doubt, decide against it, for the reasons that are explained ahead. Everything that
the decorator needs to do aside from the function that it’s decorating should be placed in
the innermost function definition, or there will be problems when it comes to importing.</p>
<p>Nonetheless, sometimes these side-effects are required (or even desired) to run at import
time, and the obverse applies.</p>
<p>We will see examples of both, and where each one applies. If in doubt, err on the side of
caution, and delay all side-effects until the very latest, right after the <code class="docutils literal notranslate"><span class="pre">wrapped</span></code> function is
going to be called.</p>
<p>Next, we will see when it’s not a good idea to place extra logic outside the <code class="docutils literal notranslate"><span class="pre">wrapped</span></code>
function.</p>
<div class="section" id="incorrect-handling-of-side-effects-in-a-decorator">
<h4>2.2.1. Incorrect handling of side-effects in a decorator<a class="headerlink" href="#incorrect-handling-of-side-effects-in-a-decorator" title="Permalink to this headline">¶</a></h4>
<p>Let’s imagine the case of a decorator that was created with the goal of logging when a
function started running and then logging its running time:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">traced_function_wrong</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;started execution of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;function </span><span class="si">%s</span><span class="s2"> took </span><span class="si">%.2f</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="n">function</span><span class="p">,</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now we will apply the decorator to a regular function, thinking that it will work just fine:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@traced_function_wrong</span>
<span class="k">def</span> <span class="nf">process_with_delay</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">callback</span><span class="p">()</span>
</pre></div>
</div>
<p>This decorator has a subtle, yet critical bug in it.
First, let’s import the function, call it several times, and see what happens:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decorator_side_effects_1</span> <span class="kn">import</span> <span class="n">process_with_delay</span>
<span class="go">INFO:started execution of &lt;function process_with_delay at 0x...&gt;</span>
</pre></div>
</div>
<p>Just by importing the function, we will notice that something’s amiss. The logging line
should not be there, because the function was not invoked.</p>
<p>Now, what happens if we run the function, and see how long it takes to run? Actually, we
would expect that calling the same function multiple times will give similar results:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">INFO:function &lt;function process_with_delay at 0x&gt; took 8.67s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">INFO:function &lt;function process_with_delay at 0x&gt; took 13.39s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">main</span><span class="p">()</span>
<span class="gp">...</span>
<span class="go">INFO:function &lt;function process_with_delay at 0x&gt; took 17.01s</span>
</pre></div>
</div>
<p>Every time we run the same function, it takes longer! At this point, you have probably
already noticed the (now obvious) error.</p>
<p>Remember the syntax for decorators. <code class="docutils literal notranslate"><span class="pre">&#64;traced_function_wrong</span></code> actually means the
following: <code class="docutils literal notranslate"><span class="pre">process_with_delay</span> <span class="pre">=</span> <span class="pre">traced_function_wrong(process_with_delay)</span></code>. And this will run when the
module is imported. Therefore, the time that is set in the
function will be the one at the time the module was imported. Successive calls will compute
the time difference from the running time until that original starting time. It will also log at
the wrong moment, and not when the function is actually called.</p>
<p>Luckily, the fix is also very simple: we just have to move the code inside the wrapped
function in order to delay its execution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">traced_function</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;started execution of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;function </span><span class="si">%s</span><span class="s2"> took </span><span class="si">%.2f</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>With this new version, the previous problems are resolved.</p>
<p>If the actions of the decorator had been different, the results could have been much more
disastrous. For instance, if it requires that you log events and send them to an external
service, it will certainly fail unless the configuration has been run right before this has been
imported, which we cannot guarantee. Even if we could, it would be bad practice. The
same applies if the decorator has any other sort of side-effect, such as reading from a file,
parsing a configuration, and many more.</p>
</div>
<div class="section" id="requiring-decorators-with-side-effects">
<h4>2.2.2. Requiring decorators with side-effects<a class="headerlink" href="#requiring-decorators-with-side-effects" title="Permalink to this headline">¶</a></h4>
<p>Sometimes, side-effects on decorators are necessary, and we should not delay their
execution until the very last possible time, because that’s part of the mechanism which is
required for them to work.</p>
<p>One common scenario for when we don’t want to delay the side-effect of decorators is
when we need to register objects to a public registry that will be available in the module.</p>
<p>For instance, going back to our previous event system example, we now want to only
make some events available in the module, but not all of them. In the hierarchy of events,
we might want to have some intermediate classes that are not actual events we want to
process on the system, but some of their derivative classes instead.</p>
<p>Instead of flagging each class based on whether it’s going to be processed or not, we could
explicitly register each class through a decorator.</p>
<p>In this case, we have a class for all events that relate to the activities of a user. However, this
is just an intermediate table for the types of event we actually want, namely
<code class="docutils literal notranslate"><span class="pre">UserLoginEvent</span></code> and <code class="docutils literal notranslate"><span class="pre">UserLogoutEvent</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">EVENTS_REGISTRY</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">register_event</span><span class="p">(</span><span class="n">event_cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Place the class for the event into the registry to make it</span>
<span class="sd">    accessible in</span>
<span class="sd">    the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EVENTS_REGISTRY</span><span class="p">[</span><span class="n">event_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_cls</span>
    <span class="k">return</span> <span class="n">event_cls</span>

<span class="k">class</span> <span class="nc">Event</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A base event object&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">UserEvent</span><span class="p">:</span>
    <span class="n">TYPE</span> <span class="o">=</span> <span class="s2">&quot;user&quot;</span>

<span class="nd">@register_event</span>
<span class="k">class</span> <span class="nc">UserLoginEvent</span><span class="p">(</span><span class="n">UserEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents the event of a user when it has just accessed the</span>
<span class="sd">    system.&quot;&quot;&quot;</span>

<span class="nd">@register_event</span>
<span class="k">class</span> <span class="nc">UserLogoutEvent</span><span class="p">(</span><span class="n">UserEvent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Event triggered right after a user abandoned the system.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>When we look at the preceding code, it seems that <code class="docutils literal notranslate"><span class="pre">EVENTS_REGISTRY</span></code> is empty, but after
importing something from this module, it will get populated with all of the classes that are
under the register_event decorator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decorator_side_effects_2</span> <span class="kn">import</span> <span class="n">EVENTS_REGISTRY</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">EVENTS_REGISTRY</span>
<span class="go">{&#39;UserLoginEvent&#39;: decorator_side_effects_2.UserLoginEvent,</span>
<span class="go">&#39;UserLogoutEvent&#39;: decorator_side_effects_2.UserLogoutEvent}</span>
</pre></div>
</div>
<p>This might seem like it’s hard to read, or even misleading, because <code class="docutils literal notranslate"><span class="pre">EVENTS_REGISTRY</span></code> will
have its final value at runtime, right after the module was imported, and we cannot easily
predict its value by just looking at the code.</p>
<p>While that is true, in some cases this pattern is justified. In fact, many web frameworks or
well-known libraries use this to work and expose objects or make them available.</p>
<p>It is also true that in this case, the decorator is not changing the wrapped object, nor altering
the way it works in any way. However, the important note here is that, if we were to do
some modifications and define an internal function that modifies the wrapped object, we
would still probably want the code that registers the resulting object outside it.</p>
<p>Notice the use of the word outside. It does not necessarily mean before, it’s just not part of
the same closure; but it’s in the outer scope, so it’s not delayed until runtime.</p>
</div>
</div>
<div class="section" id="creating-decorators-that-will-always-work">
<h3>2.3. Creating decorators that will always work<a class="headerlink" href="#creating-decorators-that-will-always-work" title="Permalink to this headline">¶</a></h3>
<p>There are several different scenarios to which decorators might apply. It can also be the
case that we need to use the same decorator for objects that fall into these different multiple
scenarios, for instance, if we want to reuse our decorator and apply it to a function, a class,
a method, or a static method.</p>
<p>If we create the decorator, just thinking about supporting only the first type of object we
want to decorate, we might notice that the same decorator does not work equally well on a
different type of object. The typical example is where we create a decorator to be used on a
function, and then we want to apply it to a method of a class, only to realize that it does not
work. A similar scenario might occur if we designed our decorator for a method, and then
we want it to also apply for static methods or class methods.</p>
<p>When designing decorators, we typically think about reusing code, so we will want to use
that decorator for functions and methods as well.</p>
<p>Defining our decorators with the signature <code class="docutils literal notranslate"><span class="pre">*args</span></code>, and <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>, will make them work in
all cases, because it’s the most generic kind of signature that we can have. However,
sometimes we might want not to use this, and instead define the decorator wrapping
function according to the signature of the original function, mainly because of two reasons:</p>
<ul class="simple">
<li><p>It will be more readable since it resembles the original function.</p></li>
<li><p>It actually needs to do something with the arguments, so receiving <code class="docutils literal notranslate"><span class="pre">*args</span></code> and <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> wouldn’t be convenient.</p></li>
</ul>
<p>Consider the case on which we have many functions in our code base that require a
particular object to be created from a parameter. For instance, we pass a string, and
initialize a driver object with it, repeatedly. Then we think we can remove the duplication
by using a decorator that will take care of converting this parameter accordingly.</p>
<p>In the next example, we pretend that <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code> is an object that knows how to connect and
run operations on a database, but it needs a connection string. The methods we have in our
code, are designed to receive a string with the information of the database and require to
create an instance of <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code> always. The idea of the decorator is that it’s going to take
place of this conversion automatically: the function will continue to receive a string, but
the decorator will create a <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code> and pass it to the function, so internally we can
assume that we receive the object we need directly.</p>
<p>An example of using this in a function is shown in the next listing:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBDriver</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbstring</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dbstring</span> <span class="o">=</span> <span class="n">dbstring</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;query </span><span class="si">{query}</span><span class="s2"> at </span><span class="si">{self.dbstring}</span><span class="s2">&quot;</span>

<span class="k">def</span> <span class="nf">inject_db_driver</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This decorator converts the parameter by creating a ``DBDriver``</span>
<span class="sd">    instance from the database dsn string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="n">dbstring</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">DBDriver</span><span class="p">(</span><span class="n">dbstring</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">wrapped</span>

<span class="nd">@inject_db_driver</span>
<span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="n">driver</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">driver</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;test_function&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s easy to verify that if we pass a string to the function, we get the result done by an
instance of <code class="docutils literal notranslate"><span class="pre">DBDriver</span></code>, so the decorator works as expected:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;test_OK&quot;</span><span class="p">)</span>
<span class="go">&#39;query test_function at test_OK&#39;</span>
</pre></div>
</div>
<p>But now, we want to reuse this same decorator in a class method, where we find the same
problem:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataHandler</span><span class="p">:</span>
    <span class="nd">@inject_db_driver</span>
    <span class="k">def</span> <span class="nf">run_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">driver</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">driver</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>We try to use this decorator, only to realize that it doesn’t work:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">DataHandler</span><span class="p">()</span><span class="o">.</span><span class="n">run_query</span><span class="p">(</span><span class="s2">&quot;test_fails&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">wrapped() takes 1 positional argument but 2 were given</span>
</pre></div>
</div>
<p>What is the problem? The method in the class is defined with an extra argument: <code class="docutils literal notranslate"><span class="pre">self</span></code>. Methods are just a
particular kind of function that receives self (the object they’re defined upon) as the first parameter.</p>
<p>Therefore, in this case, the decorator (designed to work with only one parameter, named
<code class="docutils literal notranslate"><span class="pre">dbstring</span></code>), will interpret that self is said parameter, and call the method passing the
string in the place of self, and nothing in the place for the second parameter, namely the
string we are passing.</p>
<p>To fix this issue, we need to create a decorator that will work equally for methods and
functions, and we do so by defining this as a decorator object, that also implements the
protocol descriptor.</p>
<p>The solution is to implement the decorator as a class object and make this object a
description, by implementing the <code class="docutils literal notranslate"><span class="pre">__get__</span></code> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>

<span class="k">class</span> <span class="nc">inject_db_driver</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert a string to a DBDriver instance and pass this to the</span>
<span class="sd">    wrapped function.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbstring</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">DBDriver</span><span class="p">(</span><span class="n">dbstring</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">instance</span><span class="p">))</span>
</pre></div>
</div>
<p>For now, we can say that what this decorator does is
actually rebinding the callable it’s decorating to a method, meaning that it will bind the
function to the object, and then recreate the decorator with this new callable.</p>
<p>For functions, it still works, because it won’t call the <code class="docutils literal notranslate"><span class="pre">__get__</span></code> method at all.</p>
</div>
</div>
<div class="section" id="the-dry-principle-with-decorators">
<h2>3. The DRY principle with decorators<a class="headerlink" href="#the-dry-principle-with-decorators" title="Permalink to this headline">¶</a></h2>
<p>We have seen how decorators allow us to abstract away certain logic into a separate
component. The main advantage of this is that we can then apply the decorator multiple
times into different objects in order to reuse code. This follows the <strong>Don’t Repeat Yourself
(DRY)</strong> principle since we define certain knowledge once and only once.</p>
<p>The retry mechanism implemented in the previous sections is a good example of a
decorator that can be applied multiple times to reuse code. Instead of making each
particular function include its retry logic, we create a decorator and apply it several times.
This makes sense once we have made sure that the decorator can work with methods and
functions equally.</p>
<p>The class decorator that defined how events are to be represented also complies with the
DRY principle in the sense that it defines one specific place for the logic for serializing an
event, without needing to duplicate code scattered among different classes. Since we expect
to reuse this decorator and apply it to many classes, its development (and complexity) pay
off.</p>
<p>This last remark is important to bear in mind when trying to use decorators in order to
reuse code: we have to be absolutely sure that we will actually be saving code.</p>
<p>Any decorator (especially if it is not carefully designed) adds another level of indirection to
the code, and hence more complexity. Readers of the code might want to follow the path of
the decorator to fully understand the logic of the function (although these considerations
are addressed in the following section), so keep in mind that this complexity has to pay off.
If there is not going to be too much reuse, then do not go for a decorator and opt for a
simpler option (maybe just a separate function or another small class is enough).</p>
<p>But how do we know what too much reuse is? Is there a rule to determine when to refactor
existing code into a decorator? There is nothing specific to decorators in Python, but we
could apply a general rule of thumb in software engineering that states that a
component should be tried out at least three times before considering creating a generic
abstraction in the sort of a reusable component.</p>
<p>The bottom line is that reusing code through decorators is acceptable, but only when you
take into account the following considerations:</p>
<ul class="simple">
<li><p>Do not create the decorator in the first place from scratch. Wait until the pattern emerges and the abstraction for the decorator becomes clear, and then refactor.</p></li>
<li><p>Consider that the decorator has to be applied several times (at least three times) before implementing it.</p></li>
<li><p>Keep the code in the decorators to a minimum.</p></li>
</ul>
</div>
<div class="section" id="decorators-and-separation-of-concerns">
<h2>4. Decorators and separation of concerns<a class="headerlink" href="#decorators-and-separation-of-concerns" title="Permalink to this headline">¶</a></h2>
<p>The last point on the previous list is so important that it deserves a section of its own. We
have already explored the idea of reusing code and noticed that a key element of reusing
code is having components that are cohesive. This means that they should have the
minimum level of responsibility: do one thing, one thing only, and do it well. The smaller
our components, the more reusable, and the more they can be applied in a different context
without carrying extra behavior that will cause coupling and dependencies, which will
make the software rigid.</p>
<p>To show you what this means, let’s reprise one of the decorators that we used in a previous
example. We created a decorator that traced the execution of certain functions with code
similar to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">traced_function</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;started execution of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;function </span><span class="si">%s</span><span class="s2"> took </span><span class="si">%.2f</span><span class="s2">s&quot;</span><span class="p">,</span>
            <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Now, this decorator, while it works, has a problem: it is doing more than one thing. It logs
that a particular function was just invoked, and also logs how much time it took to run.
Every time we use this decorator, we are carrying these two responsibilities, even if we only
wanted one of them.</p>
<p>This should be broken down into smaller decorators, each one with a more specific and
limited responsibility:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">log_execution</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;started execution of </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>

<span class="k">def</span> <span class="nf">measure_time</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;function </span><span class="si">%s</span><span class="s2"> took </span><span class="si">%.2f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
        <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">wrapped</span>
</pre></div>
</div>
<p>Notice that the same functionality that we had previously can be achieved by simply combining both of them:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@measure_time</span>
<span class="nd">@log_execution</span>
<span class="k">def</span> <span class="nf">operation</span><span class="p">():</span>
    <span class="o">....</span>
</pre></div>
</div>
<p>Notice how the order in which the decorators are applied is also important.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Do not place more than one responsibility in a decorator. The SRP applies to decorators as well.</p>
</div>
</div>
<div class="section" id="analyzing-good-decorators">
<h2>5. Analyzing good decorators<a class="headerlink" href="#analyzing-good-decorators" title="Permalink to this headline">¶</a></h2>
<p>As a closing note for this chapter, let’s review some examples of good decorators and how
they are used both in Python itself, as well as in popular libraries. The idea is to get
guidelines on how good decorators are created.</p>
<p>Before jumping into examples, let’s first identify traits that good decorators should have:</p>
<ul class="simple">
<li><p><strong>Encapsulation, or separation of concerns</strong>: A good decorator should effectively separate different responsibilities between what it does and what it is decorating. It cannot be a leaky abstraction, meaning that a client of the decorator should only invoke it in black box mode, without knowing how it is actually implementing its logic.</p></li>
<li><p><strong>Orthogonality</strong>: What the decorator does should be independent, and as decoupled as possible from the object it is decorating.</p></li>
<li><p><strong>Reusability</strong>: It is desirable that the decorator can be applied to multiple types, and not that it just appears on one instance of one function, because that means that it could just have been a function instead. It has to be generic enough.</p></li>
</ul>
<p>A nice example of decorators can be found in the Celery project, where a task is defined by
applying the decorator of the task from the application to a function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">task</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="o">....</span>
</pre></div>
</div>
<p>One of the reasons why this is a good decorator is because it is very good at
something: encapsulation. The user of the library only needs to define the function body
and the decorator will convert that into a task automatically. The <code class="docutils literal notranslate"><span class="pre">&#64;app.task</span></code> decorator
surely wraps a lot of logic and code, but none of that is relevant to the body of
<code class="docutils literal notranslate"><span class="pre">mytask()</span></code> . It is complete encapsulation and separation of concerns—nobody will have to
take a look at what that decorator does, so it is a correct abstraction that does not leak any
details.</p>
<p>Another common use of decorators is in web frameworks (Pyramid, Flask, and Sanic, just
to name a few), on which the handlers for views are registered to the URLs through
decorators:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@route</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;GET&quot;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">view_handler</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>These sorts of decorator have the same considerations as before; they also provide total
encapsulation because a user of the web framework rarely (if ever) needs to know what
the <code class="docutils literal notranslate"><span class="pre">&#64;route</span></code> decorator is doing. In this case, we know that the decorator is doing
something more, such as registering these functions to a mapper to the URL, and also that it
is changing the signature of the original function to provide us with a nicer interface that
receives a request object with all the information already set.</p>
<p>The previous two examples are enough to make us notice something else about this use of
decorators. They conform to an API. These libraries of frameworks are exposing their
functionality to users through decorators, and it turns out that decorators are an excellent
way of defining a clean programming interface.</p>
<p>This is probably the best way we should think about to decorators. Much like in the
example of the class decorator that tells us how the attributes of the event are going to be
handled, a good decorator should provide a clean interface so that users of the code know
what to expect from the decorator, without needing to know how it works, or any of its
details for that matter.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../descriptors/index.html" class="btn btn-neutral float-right" title="Descriptors" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../solid_principles/index.html" class="btn btn-neutral float-left" title="SOLID" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>