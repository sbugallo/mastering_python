

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1. Creating a package &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                16/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../craftmanship/index.html">Craftmanship</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../structures_algorithms/index.html">Data structures and algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimization/index.html">Code optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../technical_architecture/index.html">Technical architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../low_level/index.html">Low level Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Code distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references/index.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
      <li>1. Creating a package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/parts/distribution/chapters/packaging/creating_package.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="creating-a-package">
<h1>1. Creating a package<a class="headerlink" href="#creating-a-package" title="Permalink to this headline">¶</a></h1>
<p>Python packaging can be a bit overwhelming at first. The main reason for that is the
confusion about proper tools for creating Python packages. Anyway, once you create your
first package, you will see that this is not as hard as it looks. Also, knowing proper, state-of-
the art packaging tools helps a lot.</p>
<p>You should know how to create packages even if you are not interested in distributing your
code as open source. Knowing how to make your own packages will give you more insight
in the packaging ecosystem and will help you to work with third-party code that is
available on PyPI that you are probably already using.</p>
<p>Also, having your closed source project or its components available as source distribution
packages can help you to deploy your code in different environments. The advantages of
leveraging the Python packaging ecosystem in the code deployment process will be
described in more detail in the next chapter. Here we will focus on proper tools and
techniques to create such distributions.</p>
<div class="section" id="the-confusing-state-of-python-packaging-tools">
<h2>1.1. The confusing state of Python packaging tools<a class="headerlink" href="#the-confusing-state-of-python-packaging-tools" title="Permalink to this headline">¶</a></h2>
<p>The state of Python packaging was very confusing for a long time and it took many years to
bring organization to this topic. Everything started with the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> package introduced in
1998, which was later enhanced by setuptools in 2003. These two projects started a long and
knotted story of forks, alternative projects, and complete rewrites that tried to (once and for
all) fix the Python packaging ecosystem. Unfortunately, most of these attempts never
succeeded. The effect was quite the opposite. Each new project that aimed to
supersede <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> or <code class="docutils literal notranslate"><span class="pre">distutils</span></code> only added to the already huge confusion around
packaging tools. Some of such forks were merged back to their ancestors (such as
<code class="docutils literal notranslate"><span class="pre">distribute</span></code> which was a fork of <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>) but some were left abandoned (such as
<code class="docutils literal notranslate"><span class="pre">distutils2</span></code>).</p>
<p>Fortunately, this state is gradually changing. An organization called the Python Packaging
Authority (PyPA) was formed to bring back the order and organization to the packaging
ecosystem. The Python Packaging User Guide (<a class="reference external" href="https://packaging.python.org">https://packaging.python.org</a>),
maintained by PyPA, is the authoritative source of information about the latest packaging
tools and best practices. Treat that site as the best source of information about packaging
and complementary reading for this chapter. This guide also contains a detailed history of
changes and new projects related to packaging. So it is worth reading it, even if you already
know a bit about packaging, to make sure you still use the proper tools.</p>
<p>Stay away from other popular internet resources, such as “The Hitchhiker’s Guide to
Packaging”. It is old, not maintained, and mostly obsolete. It may be interesting only for
historical reasons, and the Python Packaging User Guide is in fact a fork of this old
resource.</p>
<div class="section" id="the-current-landscape-of-python-packaging-thanks-to-pypa">
<h3>1.1.1. The current landscape of Python packaging thanks to PyPA<a class="headerlink" href="#the-current-landscape-of-python-packaging-thanks-to-pypa" title="Permalink to this headline">¶</a></h3>
<p>PyPA, besides providing an authoritative guide for packaging, also maintains packaging
projects and a standardization process for new official aspects of Python packaging. All of
PyPA’s projects can be found under a single organization on GitHub:
<a class="reference external" href="https://github.com/pypa">https://github.com/pypa</a></p>
<p>Some of them were already mentioned. The following are the most notable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pip</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtualenv</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">twine</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warehouse</span></code></p></li>
</ul>
<p>Note that most of them were started outside of this organization and were moved under
PyPA patronage when they become mature and widespread solutions.</p>
<p>Thanks to PyPA engagement, the progressive abandonment of the eggs format in favor of
wheels for built distributions has already happened. Also thanks to the commitment of the
PyPA community, the old PyPI implementation was finally totally rewritten in the form of
the Warehouse project. Now, PyPI has got a modernized user interface and many long-
awaited usability improvements and features.</p>
</div>
<div class="section" id="tool-recommendations">
<h3>1.1.2. Tool recommendations<a class="headerlink" href="#tool-recommendations" title="Permalink to this headline">¶</a></h3>
<p>The Python Packaging User Guide gives a few suggestions on recommended tools for
working with packages. They can be generally divided into the following two groups:</p>
<ul class="simple">
<li><p>Tools for installing packages</p></li>
<li><p>Tools for package creation and distribution</p></li>
</ul>
<p>Utilities from the first group recommended are:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">pip</span></code> for installing packages from PyPI.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">virtualenv</span></code> or <code class="docutils literal notranslate"><span class="pre">venv</span></code> for application-level isolation of the Python runtime environment.</p></li>
</ul>
<p>The Python Packaging User Guide recommendations of tools for package creation and
distribution are as follows:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> to define projects and create <strong>source distributions</strong>.</p></li>
<li><p>Use <strong>wheels</strong> in favor of <strong>eggs</strong> to create <strong>built distributions</strong>.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">twine</span></code> to upload package distributions to PyPI.</p></li>
</ul>
</div>
</div>
<div class="section" id="project-configuration">
<h2>1.2. Project configuration<a class="headerlink" href="#project-configuration" title="Permalink to this headline">¶</a></h2>
<p>It should be obvious that the easiest way to organize the code of big applications is to split
them into several packages. This makes the code simpler, easier to understand, maintain,
and change. It also maximizes the reusability of your code. Separate packages act as
components that can be used in various programs.</p>
<div class="section" id="setup-py">
<h3>1.2.1. setup.py<a class="headerlink" href="#setup-py" title="Permalink to this headline">¶</a></h3>
<p>The root directory of a package that has to be distributed contains a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. It
defines all metadata as described in the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> module. Package metadata is expressed
as arguments in a call to the standard <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function. Despite <code class="docutils literal notranslate"><span class="pre">distutils</span></code> being the
standard library module provided for the purpose of code packaging, it is actually
recommended to use the <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> instead. The <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> package provides several
enhancements over the standard <code class="docutils literal notranslate"><span class="pre">distutils</span></code> module.</p>
<p>Therefore, the minimum content for this file is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mypackage&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">name</span></code> gives the full name of the package. From there, the script provides several commands
that can be listed with the <code class="docutils literal notranslate"><span class="pre">--help-commands</span></code> option, as shown in the following code:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 setup.py --help-commands
Standard commands:
    build           build everything needed to install
    clean           clean up temporary files from <span class="s1">&#39;build&#39;</span> <span class="nb">command</span>
    install         install everything from build directory
    sdist           create a <span class="nb">source</span> distribution <span class="o">(</span>tarball, zip file, etc.<span class="o">)</span>
    register        register the distribution with the Python package index
    bdist           create a built <span class="o">(</span>binary<span class="o">)</span> distribution
    check           perform some checks on the package
    upload          upload binary package to PyPI

Extra commands:
    bdist_wheel     create a wheel distribution
    <span class="nb">alias</span>           define a shortcut to invoke one or more commands
    develop         install package in <span class="s1">&#39;development mode&#39;</span>

usage: setup.py <span class="o">[</span>global_opts<span class="o">]</span> cmd1 <span class="o">[</span>cmd1_opts<span class="o">]</span> <span class="o">[</span>cmd2 <span class="o">[</span>cmd2_opts<span class="o">]</span> ...<span class="o">]</span>
or: setup.py --help <span class="o">[</span>cmd1 cmd2 ...<span class="o">]</span>
or: setup.py --help-commands
or: setup.py cmd --help
</pre></div>
</div>
<p>The actual list of commands is longer and can vary depending on the available
<code class="docutils literal notranslate"><span class="pre">setuptools</span></code> extensions. It was truncated to show only those that are most important and
relevant to this chapter. <strong>Standard commands</strong> are the built-in commands provided
by <code class="docutils literal notranslate"><span class="pre">distutils</span></code>, whereas <strong>extra commands</strong> are the ones provided by third-party packages,
such as <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> or any other package that defines and registers a new command.
Here, one such extra command registered by another package is <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code>, provided
by the <code class="docutils literal notranslate"><span class="pre">wheel</span></code> package.</p>
</div>
<div class="section" id="setup-cfg">
<h3>1.2.2. setup.cfg<a class="headerlink" href="#setup-cfg" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> file contains default options for commands of the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. This is
very useful if the process for building and distributing the package is more complex and
requires many optional arguments to be passed to the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script commands.
This <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> file allows you to store such default parameters together with your source
code on a per project basis. This will make your distribution flow independent from the
project and also provides transparency about how your package was built/distributed to
the users and other team members.</p>
<p>The syntax for the <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> file is the same as provided by the built-in
<code class="docutils literal notranslate"><span class="pre">configparser</span></code> module so it is similar to the popular Microsoft Windows INI files. Here
is an example of the <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> configuration file that provides some <code class="docutils literal notranslate"><span class="pre">global</span></code>, <code class="docutils literal notranslate"><span class="pre">sdist</span></code>,
and <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> commands’ defaults:</p>
<div class="highlight-cfg notranslate"><div class="highlight"><pre><span></span><span class="k">[global]</span>
<span class="na">quiet</span><span class="o">=</span><span class="s">1</span>

<span class="k">[sdist]</span>
<span class="na">formats</span><span class="o">=</span><span class="s">zip,tar</span>

<span class="k">[bdist_wheel]</span>
<span class="na">universal</span><span class="o">=</span><span class="s">1</span>
</pre></div>
</div>
<p>This example configuration will ensure that source distributions (<code class="docutils literal notranslate"><span class="pre">sdist</span></code> section) will
always be created in two formats (ZIP and TAR) and the built <code class="docutils literal notranslate"><span class="pre">wheel</span></code> distributions
(<code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> section) will be created as universal wheels that are independent from the
Python version. Also most of the output will be suppressed on every command by the
global <code class="docutils literal notranslate"><span class="pre">--quiet</span></code> switch. Note that this option is included here only for demonstration
purposes and it may not be a reasonable choice to suppress the output for every command
by default.</p>
</div>
<div class="section" id="manifest-in">
<h3>1.2.3. MANIFEST.in<a class="headerlink" href="#manifest-in" title="Permalink to this headline">¶</a></h3>
<p>When building a distribution with the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> command, the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> module browses
the package directory looking for files to include in the archive. By default <code class="docutils literal notranslate"><span class="pre">distutils</span></code> will
include the following:</p>
<ul class="simple">
<li><p>All Python source files implied by the <code class="docutils literal notranslate"><span class="pre">py_modules</span></code>, <code class="docutils literal notranslate"><span class="pre">packages</span></code>, and <code class="docutils literal notranslate"><span class="pre">scripts</span></code> arguments</p></li>
<li><p>All C source files listed in the <code class="docutils literal notranslate"><span class="pre">ext_modules</span></code> argument</p></li>
<li><p>Files that match the glob pattern <code class="docutils literal notranslate"><span class="pre">test/test*.py</span></code></p></li>
<li><p>Files named <code class="docutils literal notranslate"><span class="pre">README</span></code>, <code class="docutils literal notranslate"><span class="pre">README.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>, and <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code></p></li>
</ul>
<p>Besides that, if your package is versioned with a version control system such as Subversion,
Mercurial, or Git, there is the possibility to auto-include all version controlled files using
additional <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> extensions such as <code class="docutils literal notranslate"><span class="pre">setuptools-svn</span></code>, <code class="docutils literal notranslate"><span class="pre">setuptools-hg</span></code>,
and <code class="docutils literal notranslate"><span class="pre">setuptools-git</span></code>. Integration with other version control systems is also possible
through other custom extensions. No matter if it is the default built-in collection strategy or
one defined by custom extension, the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> will create a <code class="docutils literal notranslate"><span class="pre">MANIFEST</span></code> file that lists all files
and will include them in the final archive.</p>
<p>Let’s say you are not using any extra extensions, and you need to include in your package
distribution some files that are not captured by default. You can define a template
called <code class="docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> in your package root directory (the same directory as <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file).
This template directs the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> command on which files to include.</p>
<p>This <code class="docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> template defines one inclusion or exclusion rule per line:</p>
<div class="highlight-cfg notranslate"><div class="highlight"><pre><span></span><span class="na">include HISTORY.txt</span>
<span class="na">include README.txt</span>
<span class="na">include CHANGES.txt</span>
<span class="na">include CONTRIBUTORS.txt</span>
<span class="na">include LICENSE</span>
<span class="na">recursive-include *.txt *.py</span>
</pre></div>
</div>
<p>The full list of the <code class="docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> commands can be found in the official <code class="docutils literal notranslate"><span class="pre">distutils</span></code>
documentation.</p>
</div>
<div class="section" id="most-important-metadata">
<h3>1.2.4. Most important metadata<a class="headerlink" href="#most-important-metadata" title="Permalink to this headline">¶</a></h3>
<p>Besides the name and the version of the package being distributed, the most important
arguments that the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function can receive are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">description</span></code>: This includes a few sentences to describe the package.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">long_description</span></code>: This includes a full description that can be in reStructuredText (default) or other supported markup languages.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">long_description_content_type</span></code>: this defines MIME type of long description; it is used to tell the package repository what kind of markup language is used for the package description.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keywords</span></code>: This is a list of keywords that define the package and allow for better indexing in the package repository.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">author</span></code>: This is the name of the package author or organization that takes care of it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">author_email</span></code>: This is the contact email address.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">url</span></code>: This is the URL of the project.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">license</span></code>: This is the name of the license (GPL, LGPL, and so on) under which the package is distributed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packages</span></code>: This is a list of all package names in the package distribution; <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> provides a small function called <code class="docutils literal notranslate"><span class="pre">find_packages</span></code> that can automatically find package names to include.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace_packages</span></code>: This is a list of namespace packages within package distribution.</p></li>
</ul>
</div>
<div class="section" id="trove-classifiers">
<h3>1.2.5. Trove classifiers<a class="headerlink" href="#trove-classifiers" title="Permalink to this headline">¶</a></h3>
<p>PyPI and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> provide a solution for categorizing applications with the set of
classifiers called trove classifiers. All trove classifiers form a tree-like structure. Each
classifier string defines a list of nested namespaces where every namespace is separated by
the :: substring. Their list is provided to the package definition as
a classifiers argument of the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function.</p>
<p>Here is an example list of classifiers taken from <code class="docutils literal notranslate"><span class="pre">solrq</span></code> project available on PyPI:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;solrq&quot;</span><span class="p">,</span>
    <span class="c1"># (...)</span>
    <span class="n">classifiers</span><span class="o">=</span><span class="p">[</span>
    <span class="s1">&#39;Development Status :: 4 - Beta&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Intended Audience :: Developers&#39;</span><span class="p">,</span>
    <span class="s1">&#39;License :: OSI Approved :: BSD License&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Operating System :: OS Independent&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 2.6&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 2.7&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3.2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3.3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3.4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: Implementation :: PyPy&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Topic :: Internet :: WWW/HTTP :: Indexing/Search&#39;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Trove classifiers are completely optional in the package definition but provide a useful
extension to the basic metadata available in the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> interface. Among others, trove
classifiers may provide information about supported Python versions, supported operating
systems, the development stage of the project, or the license under which the code is
released. Many PyPI users search and browse the available packages by categories so a
proper classification helps packages to reach their target.</p>
<p>Trove classifiers serve an important role in the whole packaging ecosystem and should
never be ignored. There is no organization that verifies packages classification, so it is your
responsibility to provide proper classifiers for your packages and not introduce chaos to the
whole package index.</p>
<p>At the time of writing this section, there are 667 classifiers available on PyPI that are grouped
into the following nine major categories:</p>
<ul class="simple">
<li><p>Development status</p></li>
<li><p>Environment</p></li>
<li><p>Framework</p></li>
<li><p>Intended audience</p></li>
<li><p>License</p></li>
<li><p>Natural language</p></li>
<li><p>Operating system</p></li>
<li><p>Programming language</p></li>
<li><p>Topic</p></li>
</ul>
<p>This list is ever-growing, and new classifiers are added from time to time. It is thus possible
that the total count of them will be different at the time you read this. The full list of
currently available trove classifiers is available at <a class="reference external" href="https://pypi.org/classifiers">https://pypi.org/classifiers</a>.</p>
</div>
<div class="section" id="common-patterns">
<h3>1.2.6. Common patterns<a class="headerlink" href="#common-patterns" title="Permalink to this headline">¶</a></h3>
<p>Creating a package for distribution can be a tedious task for unexperienced developers.
Most of the metadata that <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> or <code class="docutils literal notranslate"><span class="pre">distutils</span></code> accept in their <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function call
can be provided manually ignoring the fact that this metadata may be also available in
other parts of the project. Here is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myproject&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;mypackage project short description&quot;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Longer description of mypackage project</span>
<span class="s2">        possibly with some documentation and/or</span>
<span class="s2">        usage examples</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;dependency1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;dependency2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;etc&#39;</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Some of the metadata elements are often found in different places in a typical Python
project. For instance, content of long description is commonly included in the project’s
<code class="docutils literal notranslate"><span class="pre">README</span></code> file, and it is a good convention to put a version specifier in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> module
of the package. Hardcoding such package metadata as <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function
arguments redundancy to the project that allows for easy mistakes and inconsistencies in
future. Both <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> cannot automatically pick metadata information
from the project sources, so you need to provide it yourself. There are some common
patterns among the Python community for solving the most popular problems such as
dependency management, version/readme inclusion, and so on. It is worth knowing at least
a few of them because they are so popular that they could be considered as packaging
idioms.</p>
<div class="section" id="automated-inclusion-of-version-string-from-package">
<h4>1.2.6.1. Automated inclusion of version string from package<a class="headerlink" href="#automated-inclusion-of-version-string-from-package" title="Permalink to this headline">¶</a></h4>
<p>The PEP 440 “Version Identification and Dependency Specification” document specifies a standard
for version and dependency specification. It is a long document that covers accepted
version specification schemes and defines how version matching and comparison in Python
packaging tools should work. If you are using or plan to use a complex project version
numbering scheme, then you should definitely read this document carefully. If you are
using a simple scheme that consists just of one, two, three, or more numbers separated by
dots, then you don’t have to dig into the details of PEP 440. If you don’t know how to
choose the proper versioning scheme, I greatly recommend following the semantic
versioning scheme.</p>
<p>The other problem related to code versioning is where to include that version specifier for a
package or module. There is PEP 396 (Module Version Numbers) that deals exactly with
this problem. PEP 396 is only an informational document and has a deferred status, so it is
not a part of the official Python standards track. Anyway, it describes what seems to be a
<em>de facto</em> standard now. According to PEP 396, if a package or module has a specific version
defined, the version specifier should be included as a <code class="docutils literal notranslate"><span class="pre">__version__</span></code> attribute of package
root <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> INI file or distributed module file. Another <em>de facto</em> standard is to also
include the <code class="docutils literal notranslate"><span class="pre">VERSION</span></code> attribute that contains the tuple of the version specifier parts. This
helps users to write compatibility code because such version tuples can be easily compared
if the versioning scheme is simple enough.</p>
<p>So many packages available on PyPI follow both conventions. Their <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> files
contain version attributes that look like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">VERSION</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">VERSION</span><span class="p">])</span>
</pre></div>
</div>
<p>The other suggestion of PEP 396 is that the version argument provided in
the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function of the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script should be derived from <code class="docutils literal notranslate"><span class="pre">__version__</span></code>, or the
other way around. The Python Packaging User Guide features multiple patterns for single-
sourcing project versioning, and each of them has its own advantages and limitations. My
personal favorite is rather long and is not included in the PyPA’s guide, but has the
advantage of limiting the complexity only to the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. This boilerplate assumes
that the version specifier is provided by the <code class="docutils literal notranslate"><span class="pre">VERSION</span></code> attribute of the
package’s <code class="docutils literal notranslate"><span class="pre">__init__</span></code> module and extracts this data for inclusion in the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> call. Here
is an excerpt from some imaginary package’s setup.py script that illustrates this approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">get_version</span><span class="p">(</span><span class="n">version_tuple</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">version_tuple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">version_tuple</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">version_tuple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">version_tuple</span><span class="p">))</span>

<span class="n">init</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="s1">&#39;some_package&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__.py&#39;</span><span class="p">)</span>
<span class="n">version_line</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;VERSION&#39;</span><span class="p">),</span> <span class="nb">open</span><span class="p">(</span><span class="n">init</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">PKG_VERSION</span> <span class="o">=</span> <span class="n">get_version</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">version_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="n">PKG_VERSION</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="readme-file">
<h4>1.2.6.2. README file<a class="headerlink" href="#readme-file" title="Permalink to this headline">¶</a></h4>
<p>The Python Package Index can display the project’s README file or the value of
<code class="docutils literal notranslate"><span class="pre">long_description</span></code> on the package page in the PyPI portal. PyPI is able to interpret the
markup used in the <code class="docutils literal notranslate"><span class="pre">long_description</span></code> content and render it as HTML on the package
page. The type of markup language is controlled through
the <code class="docutils literal notranslate"><span class="pre">long_description_content_type</span></code> argument of the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> call. For now, there are
the following three choices for markup available:</p>
<ul class="simple">
<li><p>Plain text with <code class="docutils literal notranslate"><span class="pre">long_description_content_type='text/plain'</span></code></p></li>
<li><p>reStructuredText with <code class="docutils literal notranslate"><span class="pre">long_description_content_type='text/x-rst'</span></code></p></li>
<li><p>Markdown with <code class="docutils literal notranslate"><span class="pre">long_description_content_type='text/markdown'</span></code></p></li>
</ul>
<p>Markdown and reStructuredText are the most popular choices among Python developers,
but some might still want to use different markup languages for various reasons. If you
want to use something different as your markup language for your project’s README, you
can still provide it as a project description on the PyPI page in a readable form. The trick
lies in using the <code class="docutils literal notranslate"><span class="pre">pypandoc</span></code> package to translate your other markup language into
reStructuredText (or Markdown) while uploading the package to the Python Package
Index. It is important to do it with a fallback to plain content of your README file, so the
installation won’t fail if the user has no <code class="docutils literal notranslate"><span class="pre">pypandoc</span></code> installed. The following is an example of
a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script that is able to read the content of the README file written in AsciiDoc
markup language and translate it to reStructuredText before including
a <code class="docutils literal notranslate"><span class="pre">long_description</span></code> argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pypandoc</span> <span class="kn">import</span> <span class="n">convert</span>

    <span class="k">def</span> <span class="nf">read_md</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s1">&#39;rst&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;asciidoc&#39;</span><span class="p">)</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;warning: pypandoc module not found, could not convert Asciidoc to RST&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_md</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">README</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;README&#39;</span><span class="p">)</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="n">read_md</span><span class="p">(</span><span class="n">README</span><span class="p">),</span>
    <span class="n">long_description_content_type</span><span class="o">=</span><span class="s1">&#39;text/x-rst&#39;</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="managing-dependencies">
<h4>1.2.6.3. Managing dependencies<a class="headerlink" href="#managing-dependencies" title="Permalink to this headline">¶</a></h4>
<p>Many projects require some external packages to be installed in order to work properly.
When the list of dependencies is very long, there comes a question as to how to manage it.
The answer in most cases is very simple. Do not over-engineer it. Keep it simple and
provide the list of dependencies explicitly in your setup.py script as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;requests&#39;</span><span class="p">,</span> <span class="s1">&#39;delorean&#39;</span><span class="p">]</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Some Python developers like to use <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> files for tracking lists of
dependencies for their packages. In some situations, you might find some reason for doing
that, but in most cases, this is a relic of times where the code of that project was not
properly packaged. Anyway, even such notable projects as Celery still stick to this
convention. So if you are not willing to change your habits or you are somehow forced to
use requirement files, then at least do it properly. Here is one of the popular idioms for
reading the list of dependencies from the <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">strip_comments</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reqs</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">strip_comments</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="o">*</span><span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]))</span>
<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="n">reqs</span><span class="p">(</span><span class="s1">&#39;requirements.txt&#39;</span><span class="p">)</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="the-custom-setup-command">
<h2>1.2.7. The custom setup command<a class="headerlink" href="#the-custom-setup-command" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">distutils</span></code> allows you to create new commands. A new command can be registered with
an entry point, which was introduced by <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> as a simple way to define packages
as plugins.</p>
<p>An entry point is a named link to a class or a function that is made available through some
APIs in <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>. Any application can scan for all registered packages and use the
linked code as a plugin.</p>
<p>To link the new command, the entry_points metadata can be used in the setup call as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my.command&quot;</span><span class="p">,</span>
    <span class="n">entry_points</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        [distutils.commands]</span>
<span class="s2">        my_command = my.command.module.Class</span>
<span class="s2">    &quot;&quot;&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>All named links are gathered in named sections. When <code class="docutils literal notranslate"><span class="pre">distutils</span></code> is loaded, it scans for
links that were registered under <code class="docutils literal notranslate"><span class="pre">distutils.commands</span></code>.</p>
<p>This mechanism is used by numerous Python applications that provide extensibility.</p>
</div>
<div class="section" id="working-with-packages-during-development">
<h2>1.3. Working with packages during development<a class="headerlink" href="#working-with-packages-during-development" title="Permalink to this headline">¶</a></h2>
<p>Working with <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> is mostly about building and distributing packages. However,
you still need to use <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> to install packages directly from project sources. And the
reason for that is simple. It is a good habit to test if our packaging code works properly
before submitting your package to PyPI. And the simplest way to test it is by installing it. If
you send a broken package to the repository, then in order to re-upload it, you need to
increase the version number.</p>
<p>Testing if your code is packaged properly before the final distribution saves you from
unnecessary version number inflation and obviously from wasting your time. Also,
installation directly from your own sources using <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> may be essential when
working on multiple related packages at the same time.</p>
<div class="section" id="setup-py-install">
<h3>1.3.1. setup.py install<a class="headerlink" href="#setup-py-install" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">install</span></code> command installs the package in your current Python environment. It will try
to build the package if no previous build was made and then inject the result into the
filesystem directory where Python is looking for installed packages. If you have an archive
with a source distribution of some package, you can decompress it in a temporary folder
and then install it with this command. The <code class="docutils literal notranslate"><span class="pre">install</span></code> command will also install
dependencies that are defined in the <code class="docutils literal notranslate"><span class="pre">install_requires</span></code> argument. Dependencies will be
installed from the Python Package Index.</p>
<p>An alternative to the bare <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script when installing a package is to use <code class="docutils literal notranslate"><span class="pre">pip</span></code>. Since it
is a tool that is recommended by PyPA, you should use it even when installing a package in
your local environment just for development purposes. In order to install a package from
local sources, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip install &lt;project-path&gt;
</pre></div>
</div>
</div>
<div class="section" id="uninstalling-packages">
<h3>1.3.2. Uninstalling packages<a class="headerlink" href="#uninstalling-packages" title="Permalink to this headline">¶</a></h3>
<p>Amazingly, <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> lack the <code class="docutils literal notranslate"><span class="pre">uninstall</span></code> command. Fortunately, it is
possible to uninstall any Python package using <code class="docutils literal notranslate"><span class="pre">pip</span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip uninstall &lt;package-name&gt;
</pre></div>
</div>
<p>Uninstalling can be a dangerous operation when attempted on system-wide packages. This
is another reason why it is so important to use virtual environments for any development.</p>
</div>
<div class="section" id="setup-py-develop-or-pip-e">
<h3>1.3.3. setup.py develop or pip -e<a class="headerlink" href="#setup-py-develop-or-pip-e" title="Permalink to this headline">¶</a></h3>
<p>Packages installed with <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> install are copied to the site-packages directory of
your current Python environment. This means that whenever you make a change to the
sources of that package, you are required to reinstall it. This is often a problem during
intensive development because it is very easy to forget about the need to perform
installation again. This is why <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> provides an extra <code class="docutils literal notranslate"><span class="pre">develop</span></code> command that
allows you to install packages in the development mode. This command creates a special
link to project sources in the deployment directory (site-packages) instead of copying
the whole package there. Package sources can be edited without the need for reinstallation
and are available in the <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> as if they were installed normally.</p>
<p><code class="docutils literal notranslate"><span class="pre">pip</span></code> also allows you to install packages in such a mode. This installation option is
called editable mode and can be enabled with the <code class="docutils literal notranslate"><span class="pre">-e</span></code> parameter in the <code class="docutils literal notranslate"><span class="pre">install</span></code> command
as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip install -e &lt;project-path&gt;
</pre></div>
</div>
<p>Once you install the package in your environment in editable mode, you can freely modify
the installed package in place and all the changes will be immediately visible without the
need to reinstall the package.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>