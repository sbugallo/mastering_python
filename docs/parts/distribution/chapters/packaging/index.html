

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Packaging &mdash; Mastering Python</title>
  

  
  
    <link rel="shortcut icon" href="../../../../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/styles.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="prev" title="Code distribution" href="../../index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Mastering Python
          

          
            
            <img src="../../../../_static/logo-white.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                05/03/2020
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../craftmanship/index.html">Craftmanship</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quality/index.html">Code quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optimization/index.html">Code optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../technical_architecture/index.html">Technical architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../low_level/index.html">Low level Python</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Code distribution</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Packaging</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-package">1. Creating a package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-confusing-state-of-python-packaging-tools">1.1. The confusing state of Python packaging tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#project-configuration">1.2. Project configuration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-custom-setup-command">1.2.7. The custom setup command</a></li>
<li class="toctree-l4"><a class="reference internal" href="#working-with-packages-during-development">1.3. Working with packages during development</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#namespace-packages">2. Namespace packages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-namespace-packages">2.1. Implicit namespace packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#namespace-packages-in-previous-python-versions">2.2. Namespace packages in previous Python versions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uploading-a-package">3. Uploading a package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pypi-python-package-index">3.1. PyPI: Python Package Index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-packages-versus-built-packages">3.2. Source packages versus built packages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sdist">3.2.1. sdist</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#standalone-executables">4. Standalone executables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#when-standalone-executables-useful">4.1. When standalone executables useful?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#popular-tools">4.2. Popular tools</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Mastering Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Code distribution</a> &raquo;</li>
        
      <li>Packaging</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../../_sources/parts/distribution/chapters/packaging/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
      
        <a href="../../index.html" class="btn btn-neutral float-left" title="Code distribution" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="packaging">
<h1>Packaging<a class="headerlink" href="#packaging" title="Permalink to this headline">¶</a></h1>
<p>This chapter focuses on a repeatable process of writing and releasing Python packages. We
will see how to shorten the time needed to set up everything before starting the real work.
We will also learn how to provide a standardized way to write packages and ease the use of
a test-driven development approach. We will finally learn how to facilitate the release
process.</p>
<p>It is organized into the following four parts:</p>
<ul class="simple">
<li><p>A <strong>common pattern</strong> for all packages that describes the similarities between all Python packages, and how distutils and setuptools play a central role the packaging process.</p></li>
<li><p>What are <strong>namespace packages</strong> and why they can be useful?</p></li>
<li><p>How to register and upload packages in the <strong>Python Package Index (PyPI)</strong> with emphasis on security and common pitfalls.</p></li>
<li><p>The <strong>standalone executables</strong> as an alternative way to package and distribute Python applications.</p></li>
</ul>
<div class="section" id="creating-a-package">
<h2>1. Creating a package<a class="headerlink" href="#creating-a-package" title="Permalink to this headline">¶</a></h2>
<p>Python packaging can be a bit overwhelming at first. The main reason for that is the
confusion about proper tools for creating Python packages. Anyway, once you create your
first package, you will see that this is not as hard as it looks. Also, knowing proper, state-of-
the art packaging tools helps a lot.</p>
<p>You should know how to create packages even if you are not interested in distributing your
code as open source. Knowing how to make your own packages will give you more insight
in the packaging ecosystem and will help you to work with third-party code that is
available on PyPI that you are probably already using.</p>
<p>Also, having your closed source project or its components available as source distribution
packages can help you to deploy your code in different environments. The advantages of
leveraging the Python packaging ecosystem in the code deployment process will be
described in more detail in the next chapter. Here we will focus on proper tools and
techniques to create such distributions.</p>
<div class="section" id="the-confusing-state-of-python-packaging-tools">
<h3>1.1. The confusing state of Python packaging tools<a class="headerlink" href="#the-confusing-state-of-python-packaging-tools" title="Permalink to this headline">¶</a></h3>
<p>The state of Python packaging was very confusing for a long time and it took many years to
bring organization to this topic. Everything started with the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> package introduced in
1998, which was later enhanced by setuptools in 2003. These two projects started a long and
knotted story of forks, alternative projects, and complete rewrites that tried to (once and for
all) fix the Python packaging ecosystem. Unfortunately, most of these attempts never
succeeded. The effect was quite the opposite. Each new project that aimed to
supersede <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> or <code class="docutils literal notranslate"><span class="pre">distutils</span></code> only added to the already huge confusion around
packaging tools. Some of such forks were merged back to their ancestors (such as
<code class="docutils literal notranslate"><span class="pre">distribute</span></code> which was a fork of <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>) but some were left abandoned (such as
<code class="docutils literal notranslate"><span class="pre">distutils2</span></code>).</p>
<p>Fortunately, this state is gradually changing. An organization called the Python Packaging
Authority (PyPA) was formed to bring back the order and organization to the packaging
ecosystem. The Python Packaging User Guide (<a class="reference external" href="https://packaging.python.org">https://packaging.python.org</a>),
maintained by PyPA, is the authoritative source of information about the latest packaging
tools and best practices. Treat that site as the best source of information about packaging
and complementary reading for this chapter. This guide also contains a detailed history of
changes and new projects related to packaging. So it is worth reading it, even if you already
know a bit about packaging, to make sure you still use the proper tools.</p>
<p>Stay away from other popular internet resources, such as “The Hitchhiker’s Guide to
Packaging”. It is old, not maintained, and mostly obsolete. It may be interesting only for
historical reasons, and the Python Packaging User Guide is in fact a fork of this old
resource.</p>
<div class="section" id="the-current-landscape-of-python-packaging-thanks-to-pypa">
<h4>1.1.1. The current landscape of Python packaging thanks to PyPA<a class="headerlink" href="#the-current-landscape-of-python-packaging-thanks-to-pypa" title="Permalink to this headline">¶</a></h4>
<p>PyPA, besides providing an authoritative guide for packaging, also maintains packaging
projects and a standardization process for new official aspects of Python packaging. All of
PyPA’s projects can be found under a single organization on GitHub:
<a class="reference external" href="https://github.com/pypa">https://github.com/pypa</a></p>
<p>Some of them were already mentioned. The following are the most notable:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pip</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">virtualenv</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">twine</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warehouse</span></code></p></li>
</ul>
<p>Note that most of them were started outside of this organization and were moved under
PyPA patronage when they become mature and widespread solutions.</p>
<p>Thanks to PyPA engagement, the progressive abandonment of the eggs format in favor of
wheels for built distributions has already happened. Also thanks to the commitment of the
PyPA community, the old PyPI implementation was finally totally rewritten in the form of
the Warehouse project. Now, PyPI has got a modernized user interface and many long-
awaited usability improvements and features.</p>
</div>
<div class="section" id="tool-recommendations">
<h4>1.1.2. Tool recommendations<a class="headerlink" href="#tool-recommendations" title="Permalink to this headline">¶</a></h4>
<p>The Python Packaging User Guide gives a few suggestions on recommended tools for
working with packages. They can be generally divided into the following two groups:</p>
<ul class="simple">
<li><p>Tools for installing packages</p></li>
<li><p>Tools for package creation and distribution</p></li>
</ul>
<p>Utilities from the first group recommended are:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">pip</span></code> for installing packages from PyPI.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">virtualenv</span></code> or <code class="docutils literal notranslate"><span class="pre">venv</span></code> for application-level isolation of the Python runtime environment.</p></li>
</ul>
<p>The Python Packaging User Guide recommendations of tools for package creation and
distribution are as follows:</p>
<ul class="simple">
<li><p>Use <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> to define projects and create <strong>source distributions</strong>.</p></li>
<li><p>Use <strong>wheels</strong> in favor of <strong>eggs</strong> to create <strong>built distributions</strong>.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">twine</span></code> to upload package distributions to PyPI.</p></li>
</ul>
</div>
</div>
<div class="section" id="project-configuration">
<h3>1.2. Project configuration<a class="headerlink" href="#project-configuration" title="Permalink to this headline">¶</a></h3>
<p>It should be obvious that the easiest way to organize the code of big applications is to split
them into several packages. This makes the code simpler, easier to understand, maintain,
and change. It also maximizes the reusability of your code. Separate packages act as
components that can be used in various programs.</p>
<div class="section" id="setup-py">
<h4>1.2.1. setup.py<a class="headerlink" href="#setup-py" title="Permalink to this headline">¶</a></h4>
<p>The root directory of a package that has to be distributed contains a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. It
defines all metadata as described in the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> module. Package metadata is expressed
as arguments in a call to the standard <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function. Despite <code class="docutils literal notranslate"><span class="pre">distutils</span></code> being the
standard library module provided for the purpose of code packaging, it is actually
recommended to use the <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> instead. The <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> package provides several
enhancements over the standard <code class="docutils literal notranslate"><span class="pre">distutils</span></code> module.</p>
<p>Therefore, the minimum content for this file is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mypackage&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">name</span></code> gives the full name of the package. From there, the script provides several commands
that can be listed with the <code class="docutils literal notranslate"><span class="pre">--help-commands</span></code> option, as shown in the following code:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python3 setup.py --help-commands
Standard commands:
    build           build everything needed to install
    clean           clean up temporary files from <span class="s1">&#39;build&#39;</span> <span class="nb">command</span>
    install         install everything from build directory
    sdist           create a <span class="nb">source</span> distribution <span class="o">(</span>tarball, zip file, etc.<span class="o">)</span>
    register        register the distribution with the Python package index
    bdist           create a built <span class="o">(</span>binary<span class="o">)</span> distribution
    check           perform some checks on the package
    upload          upload binary package to PyPI

Extra commands:
    bdist_wheel     create a wheel distribution
    <span class="nb">alias</span>           define a shortcut to invoke one or more commands
    develop         install package in <span class="s1">&#39;development mode&#39;</span>

usage: setup.py <span class="o">[</span>global_opts<span class="o">]</span> cmd1 <span class="o">[</span>cmd1_opts<span class="o">]</span> <span class="o">[</span>cmd2 <span class="o">[</span>cmd2_opts<span class="o">]</span> ...<span class="o">]</span>
or: setup.py --help <span class="o">[</span>cmd1 cmd2 ...<span class="o">]</span>
or: setup.py --help-commands
or: setup.py cmd --help
</pre></div>
</div>
<p>The actual list of commands is longer and can vary depending on the available
<code class="docutils literal notranslate"><span class="pre">setuptools</span></code> extensions. It was truncated to show only those that are most important and
relevant to this chapter. <strong>Standard commands</strong> are the built-in commands provided
by <code class="docutils literal notranslate"><span class="pre">distutils</span></code>, whereas <strong>extra commands</strong> are the ones provided by third-party packages,
such as <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> or any other package that defines and registers a new command.
Here, one such extra command registered by another package is <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code>, provided
by the <code class="docutils literal notranslate"><span class="pre">wheel</span></code> package.</p>
</div>
<div class="section" id="setup-cfg">
<h4>1.2.2. setup.cfg<a class="headerlink" href="#setup-cfg" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> file contains default options for commands of the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. This is
very useful if the process for building and distributing the package is more complex and
requires many optional arguments to be passed to the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script commands.
This <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> file allows you to store such default parameters together with your source
code on a per project basis. This will make your distribution flow independent from the
project and also provides transparency about how your package was built/distributed to
the users and other team members.</p>
<p>The syntax for the <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> file is the same as provided by the built-in
<code class="docutils literal notranslate"><span class="pre">configparser</span></code> module so it is similar to the popular Microsoft Windows INI files. Here
is an example of the <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code> configuration file that provides some <code class="docutils literal notranslate"><span class="pre">global</span></code>, <code class="docutils literal notranslate"><span class="pre">sdist</span></code>,
and <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> commands’ defaults:</p>
<div class="highlight-cfg notranslate"><div class="highlight"><pre><span></span><span class="k">[global]</span>
<span class="na">quiet</span><span class="o">=</span><span class="s">1</span>

<span class="k">[sdist]</span>
<span class="na">formats</span><span class="o">=</span><span class="s">zip,tar</span>

<span class="k">[bdist_wheel]</span>
<span class="na">universal</span><span class="o">=</span><span class="s">1</span>
</pre></div>
</div>
<p>This example configuration will ensure that source distributions (<code class="docutils literal notranslate"><span class="pre">sdist</span></code> section) will
always be created in two formats (ZIP and TAR) and the built <code class="docutils literal notranslate"><span class="pre">wheel</span></code> distributions
(<code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> section) will be created as universal wheels that are independent from the
Python version. Also most of the output will be suppressed on every command by the
global <code class="docutils literal notranslate"><span class="pre">--quiet</span></code> switch. Note that this option is included here only for demonstration
purposes and it may not be a reasonable choice to suppress the output for every command
by default.</p>
</div>
<div class="section" id="manifest-in">
<h4>1.2.3. MANIFEST.in<a class="headerlink" href="#manifest-in" title="Permalink to this headline">¶</a></h4>
<p>When building a distribution with the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> command, the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> module browses
the package directory looking for files to include in the archive. By default <code class="docutils literal notranslate"><span class="pre">distutils</span></code> will
include the following:</p>
<ul class="simple">
<li><p>All Python source files implied by the <code class="docutils literal notranslate"><span class="pre">py_modules</span></code>, <code class="docutils literal notranslate"><span class="pre">packages</span></code>, and <code class="docutils literal notranslate"><span class="pre">scripts</span></code> arguments</p></li>
<li><p>All C source files listed in the <code class="docutils literal notranslate"><span class="pre">ext_modules</span></code> argument</p></li>
<li><p>Files that match the glob pattern <code class="docutils literal notranslate"><span class="pre">test/test*.py</span></code></p></li>
<li><p>Files named <code class="docutils literal notranslate"><span class="pre">README</span></code>, <code class="docutils literal notranslate"><span class="pre">README.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>, and <code class="docutils literal notranslate"><span class="pre">setup.cfg</span></code></p></li>
</ul>
<p>Besides that, if your package is versioned with a version control system such as Subversion,
Mercurial, or Git, there is the possibility to auto-include all version controlled files using
additional <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> extensions such as <code class="docutils literal notranslate"><span class="pre">setuptools-svn</span></code>, <code class="docutils literal notranslate"><span class="pre">setuptools-hg</span></code>,
and <code class="docutils literal notranslate"><span class="pre">setuptools-git</span></code>. Integration with other version control systems is also possible
through other custom extensions. No matter if it is the default built-in collection strategy or
one defined by custom extension, the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> will create a <code class="docutils literal notranslate"><span class="pre">MANIFEST</span></code> file that lists all files
and will include them in the final archive.</p>
<p>Let’s say you are not using any extra extensions, and you need to include in your package
distribution some files that are not captured by default. You can define a template
called <code class="docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> in your package root directory (the same directory as <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> file).
This template directs the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> command on which files to include.</p>
<p>This <code class="docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> template defines one inclusion or exclusion rule per line:</p>
<div class="highlight-cfg notranslate"><div class="highlight"><pre><span></span><span class="na">include HISTORY.txt</span>
<span class="na">include README.txt</span>
<span class="na">include CHANGES.txt</span>
<span class="na">include CONTRIBUTORS.txt</span>
<span class="na">include LICENSE</span>
<span class="na">recursive-include *.txt *.py</span>
</pre></div>
</div>
<p>The full list of the <code class="docutils literal notranslate"><span class="pre">MANIFEST.in</span></code> commands can be found in the official <code class="docutils literal notranslate"><span class="pre">distutils</span></code>
documentation.</p>
</div>
<div class="section" id="most-important-metadata">
<h4>1.2.4. Most important metadata<a class="headerlink" href="#most-important-metadata" title="Permalink to this headline">¶</a></h4>
<p>Besides the name and the version of the package being distributed, the most important
arguments that the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function can receive are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">description</span></code>: This includes a few sentences to describe the package.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">long_description</span></code>: This includes a full description that can be in reStructuredText (default) or other supported markup languages.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">long_description_content_type</span></code>: this defines MIME type of long description; it is used to tell the package repository what kind of markup language is used for the package description.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">keywords</span></code>: This is a list of keywords that define the package and allow for better indexing in the package repository.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">author</span></code>: This is the name of the package author or organization that takes care of it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">author_email</span></code>: This is the contact email address.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">url</span></code>: This is the URL of the project.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">license</span></code>: This is the name of the license (GPL, LGPL, and so on) under which the package is distributed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">packages</span></code>: This is a list of all package names in the package distribution; <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> provides a small function called <code class="docutils literal notranslate"><span class="pre">find_packages</span></code> that can automatically find package names to include.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">namespace_packages</span></code>: This is a list of namespace packages within package distribution.</p></li>
</ul>
</div>
<div class="section" id="trove-classifiers">
<h4>1.2.5. Trove classifiers<a class="headerlink" href="#trove-classifiers" title="Permalink to this headline">¶</a></h4>
<p>PyPI and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> provide a solution for categorizing applications with the set of
classifiers called trove classifiers. All trove classifiers form a tree-like structure. Each
classifier string defines a list of nested namespaces where every namespace is separated by
the :: substring. Their list is provided to the package definition as
a classifiers argument of the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function.</p>
<p>Here is an example list of classifiers taken from <code class="docutils literal notranslate"><span class="pre">solrq</span></code> project available on PyPI:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;solrq&quot;</span><span class="p">,</span>
    <span class="c1"># (...)</span>
    <span class="n">classifiers</span><span class="o">=</span><span class="p">[</span>
    <span class="s1">&#39;Development Status :: 4 - Beta&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Intended Audience :: Developers&#39;</span><span class="p">,</span>
    <span class="s1">&#39;License :: OSI Approved :: BSD License&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Operating System :: OS Independent&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 2.6&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 2.7&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3.2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3.3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: 3.4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Programming Language :: Python :: Implementation :: PyPy&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Topic :: Internet :: WWW/HTTP :: Indexing/Search&#39;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Trove classifiers are completely optional in the package definition but provide a useful
extension to the basic metadata available in the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> interface. Among others, trove
classifiers may provide information about supported Python versions, supported operating
systems, the development stage of the project, or the license under which the code is
released. Many PyPI users search and browse the available packages by categories so a
proper classification helps packages to reach their target.</p>
<p>Trove classifiers serve an important role in the whole packaging ecosystem and should
never be ignored. There is no organization that verifies packages classification, so it is your
responsibility to provide proper classifiers for your packages and not introduce chaos to the
whole package index.</p>
<p>At the time of writing this section, there are 667 classifiers available on PyPI that are grouped
into the following nine major categories:</p>
<ul class="simple">
<li><p>Development status</p></li>
<li><p>Environment</p></li>
<li><p>Framework</p></li>
<li><p>Intended audience</p></li>
<li><p>License</p></li>
<li><p>Natural language</p></li>
<li><p>Operating system</p></li>
<li><p>Programming language</p></li>
<li><p>Topic</p></li>
</ul>
<p>This list is ever-growing, and new classifiers are added from time to time. It is thus possible
that the total count of them will be different at the time you read this. The full list of
currently available trove classifiers is available at <a class="reference external" href="https://pypi.org/classifiers">https://pypi.org/classifiers</a>.</p>
</div>
<div class="section" id="common-patterns">
<h4>1.2.6. Common patterns<a class="headerlink" href="#common-patterns" title="Permalink to this headline">¶</a></h4>
<p>Creating a package for distribution can be a tedious task for unexperienced developers.
Most of the metadata that <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> or <code class="docutils literal notranslate"><span class="pre">distutils</span></code> accept in their <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function call
can be provided manually ignoring the fact that this metadata may be also available in
other parts of the project. Here is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myproject&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;mypackage project short description&quot;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Longer description of mypackage project</span>
<span class="s2">        possibly with some documentation and/or</span>
<span class="s2">        usage examples</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;dependency1&#39;</span><span class="p">,</span>
        <span class="s1">&#39;dependency2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;etc&#39;</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Some of the metadata elements are often found in different places in a typical Python
project. For instance, content of long description is commonly included in the project’s
<code class="docutils literal notranslate"><span class="pre">README</span></code> file, and it is a good convention to put a version specifier in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> module
of the package. Hardcoding such package metadata as <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function
arguments redundancy to the project that allows for easy mistakes and inconsistencies in
future. Both <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> cannot automatically pick metadata information
from the project sources, so you need to provide it yourself. There are some common
patterns among the Python community for solving the most popular problems such as
dependency management, version/readme inclusion, and so on. It is worth knowing at least
a few of them because they are so popular that they could be considered as packaging
idioms.</p>
<div class="section" id="automated-inclusion-of-version-string-from-package">
<h5>1.2.6.1. Automated inclusion of version string from package<a class="headerlink" href="#automated-inclusion-of-version-string-from-package" title="Permalink to this headline">¶</a></h5>
<p>The PEP 440 “Version Identification and Dependency Specification” document specifies a standard
for version and dependency specification. It is a long document that covers accepted
version specification schemes and defines how version matching and comparison in Python
packaging tools should work. If you are using or plan to use a complex project version
numbering scheme, then you should definitely read this document carefully. If you are
using a simple scheme that consists just of one, two, three, or more numbers separated by
dots, then you don’t have to dig into the details of PEP 440. If you don’t know how to
choose the proper versioning scheme, I greatly recommend following the semantic
versioning scheme.</p>
<p>The other problem related to code versioning is where to include that version specifier for a
package or module. There is PEP 396 (Module Version Numbers) that deals exactly with
this problem. PEP 396 is only an informational document and has a deferred status, so it is
not a part of the official Python standards track. Anyway, it describes what seems to be a
<em>de facto</em> standard now. According to PEP 396, if a package or module has a specific version
defined, the version specifier should be included as a <code class="docutils literal notranslate"><span class="pre">__version__</span></code> attribute of package
root <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> INI file or distributed module file. Another <em>de facto</em> standard is to also
include the <code class="docutils literal notranslate"><span class="pre">VERSION</span></code> attribute that contains the tuple of the version specifier parts. This
helps users to write compatibility code because such version tuples can be easily compared
if the versioning scheme is simple enough.</p>
<p>So many packages available on PyPI follow both conventions. Their <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> files
contain version attributes that look like the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">VERSION</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">VERSION</span><span class="p">])</span>
</pre></div>
</div>
<p>The other suggestion of PEP 396 is that the version argument provided in
the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> function of the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script should be derived from <code class="docutils literal notranslate"><span class="pre">__version__</span></code>, or the
other way around. The Python Packaging User Guide features multiple patterns for single-
sourcing project versioning, and each of them has its own advantages and limitations. My
personal favorite is rather long and is not included in the PyPA’s guide, but has the
advantage of limiting the complexity only to the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. This boilerplate assumes
that the version specifier is provided by the <code class="docutils literal notranslate"><span class="pre">VERSION</span></code> attribute of the
package’s <code class="docutils literal notranslate"><span class="pre">__init__</span></code> module and extracts this data for inclusion in the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> call. Here
is an excerpt from some imaginary package’s setup.py script that illustrates this approach:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">get_version</span><span class="p">(</span><span class="n">version_tuple</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">version_tuple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">version_tuple</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">version_tuple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">version_tuple</span><span class="p">))</span>

<span class="n">init</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;src&#39;</span><span class="p">,</span> <span class="s1">&#39;some_package&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__.py&#39;</span><span class="p">)</span>
<span class="n">version_line</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;VERSION&#39;</span><span class="p">),</span> <span class="nb">open</span><span class="p">(</span><span class="n">init</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">PKG_VERSION</span> <span class="o">=</span> <span class="n">get_version</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">version_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="n">PKG_VERSION</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="readme-file">
<h5>1.2.6.2. README file<a class="headerlink" href="#readme-file" title="Permalink to this headline">¶</a></h5>
<p>The Python Package Index can display the project’s README file or the value of
<code class="docutils literal notranslate"><span class="pre">long_description</span></code> on the package page in the PyPI portal. PyPI is able to interpret the
markup used in the <code class="docutils literal notranslate"><span class="pre">long_description</span></code> content and render it as HTML on the package
page. The type of markup language is controlled through
the <code class="docutils literal notranslate"><span class="pre">long_description_content_type</span></code> argument of the <code class="docutils literal notranslate"><span class="pre">setup()</span></code> call. For now, there are
the following three choices for markup available:</p>
<ul class="simple">
<li><p>Plain text with <code class="docutils literal notranslate"><span class="pre">long_description_content_type='text/plain'</span></code></p></li>
<li><p>reStructuredText with <code class="docutils literal notranslate"><span class="pre">long_description_content_type='text/x-rst'</span></code></p></li>
<li><p>Markdown with <code class="docutils literal notranslate"><span class="pre">long_description_content_type='text/markdown'</span></code></p></li>
</ul>
<p>Markdown and reStructuredText are the most popular choices among Python developers,
but some might still want to use different markup languages for various reasons. If you
want to use something different as your markup language for your project’s README, you
can still provide it as a project description on the PyPI page in a readable form. The trick
lies in using the <code class="docutils literal notranslate"><span class="pre">pypandoc</span></code> package to translate your other markup language into
reStructuredText (or Markdown) while uploading the package to the Python Package
Index. It is important to do it with a fallback to plain content of your README file, so the
installation won’t fail if the user has no <code class="docutils literal notranslate"><span class="pre">pypandoc</span></code> installed. The following is an example of
a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script that is able to read the content of the README file written in AsciiDoc
markup language and translate it to reStructuredText before including
a <code class="docutils literal notranslate"><span class="pre">long_description</span></code> argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pypandoc</span> <span class="kn">import</span> <span class="n">convert</span>

    <span class="k">def</span> <span class="nf">read_md</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s1">&#39;rst&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;asciidoc&#39;</span><span class="p">)</span>

<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">convert</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;warning: pypandoc module not found, could not convert Asciidoc to RST&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_md</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">README</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;README&#39;</span><span class="p">)</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">long_description</span><span class="o">=</span><span class="n">read_md</span><span class="p">(</span><span class="n">README</span><span class="p">),</span>
    <span class="n">long_description_content_type</span><span class="o">=</span><span class="s1">&#39;text/x-rst&#39;</span><span class="p">,</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="managing-dependencies">
<h5>1.2.6.3. Managing dependencies<a class="headerlink" href="#managing-dependencies" title="Permalink to this headline">¶</a></h5>
<p>Many projects require some external packages to be installed in order to work properly.
When the list of dependencies is very long, there comes a question as to how to manage it.
The answer in most cases is very simple. Do not over-engineer it. Keep it simple and
provide the list of dependencies explicitly in your setup.py script as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;falcon&#39;</span><span class="p">,</span> <span class="s1">&#39;requests&#39;</span><span class="p">,</span> <span class="s1">&#39;delorean&#39;</span><span class="p">]</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Some Python developers like to use <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> files for tracking lists of
dependencies for their packages. In some situations, you might find some reason for doing
that, but in most cases, this is a relic of times where the code of that project was not
properly packaged. Anyway, even such notable projects as Celery still stick to this
convention. So if you are not willing to change your habits or you are somehow forced to
use requirement files, then at least do it properly. Here is one of the popular idioms for
reading the list of dependencies from the <code class="docutils literal notranslate"><span class="pre">requirements.txt</span></code> file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">strip_comments</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">reqs</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">strip_comments</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="o">*</span><span class="n">f</span><span class="p">))</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]))</span>
<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;some-package&#39;</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="n">reqs</span><span class="p">(</span><span class="s1">&#39;requirements.txt&#39;</span><span class="p">)</span>
    <span class="c1"># ...</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="the-custom-setup-command">
<h3>1.2.7. The custom setup command<a class="headerlink" href="#the-custom-setup-command" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">distutils</span></code> allows you to create new commands. A new command can be registered with
an entry point, which was introduced by <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> as a simple way to define packages
as plugins.</p>
<p>An entry point is a named link to a class or a function that is made available through some
APIs in <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>. Any application can scan for all registered packages and use the
linked code as a plugin.</p>
<p>To link the new command, the entry_points metadata can be used in the setup call as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my.command&quot;</span><span class="p">,</span>
    <span class="n">entry_points</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        [distutils.commands]</span>
<span class="s2">        my_command = my.command.module.Class</span>
<span class="s2">    &quot;&quot;&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>All named links are gathered in named sections. When <code class="docutils literal notranslate"><span class="pre">distutils</span></code> is loaded, it scans for
links that were registered under <code class="docutils literal notranslate"><span class="pre">distutils.commands</span></code>.</p>
<p>This mechanism is used by numerous Python applications that provide extensibility.</p>
</div>
<div class="section" id="working-with-packages-during-development">
<h3>1.3. Working with packages during development<a class="headerlink" href="#working-with-packages-during-development" title="Permalink to this headline">¶</a></h3>
<p>Working with <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> is mostly about building and distributing packages. However,
you still need to use <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> to install packages directly from project sources. And the
reason for that is simple. It is a good habit to test if our packaging code works properly
before submitting your package to PyPI. And the simplest way to test it is by installing it. If
you send a broken package to the repository, then in order to re-upload it, you need to
increase the version number.</p>
<p>Testing if your code is packaged properly before the final distribution saves you from
unnecessary version number inflation and obviously from wasting your time. Also,
installation directly from your own sources using <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> may be essential when
working on multiple related packages at the same time.</p>
<div class="section" id="setup-py-install">
<h4>1.3.1. setup.py install<a class="headerlink" href="#setup-py-install" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">install</span></code> command installs the package in your current Python environment. It will try
to build the package if no previous build was made and then inject the result into the
filesystem directory where Python is looking for installed packages. If you have an archive
with a source distribution of some package, you can decompress it in a temporary folder
and then install it with this command. The <code class="docutils literal notranslate"><span class="pre">install</span></code> command will also install
dependencies that are defined in the <code class="docutils literal notranslate"><span class="pre">install_requires</span></code> argument. Dependencies will be
installed from the Python Package Index.</p>
<p>An alternative to the bare <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script when installing a package is to use <code class="docutils literal notranslate"><span class="pre">pip</span></code>. Since it
is a tool that is recommended by PyPA, you should use it even when installing a package in
your local environment just for development purposes. In order to install a package from
local sources, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip install &lt;project-path&gt;
</pre></div>
</div>
</div>
<div class="section" id="uninstalling-packages">
<h4>1.3.2. Uninstalling packages<a class="headerlink" href="#uninstalling-packages" title="Permalink to this headline">¶</a></h4>
<p>Amazingly, <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> lack the <code class="docutils literal notranslate"><span class="pre">uninstall</span></code> command. Fortunately, it is
possible to uninstall any Python package using <code class="docutils literal notranslate"><span class="pre">pip</span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip uninstall &lt;package-name&gt;
</pre></div>
</div>
<p>Uninstalling can be a dangerous operation when attempted on system-wide packages. This
is another reason why it is so important to use virtual environments for any development.</p>
</div>
<div class="section" id="setup-py-develop-or-pip-e">
<h4>1.3.3. setup.py develop or pip -e<a class="headerlink" href="#setup-py-develop-or-pip-e" title="Permalink to this headline">¶</a></h4>
<p>Packages installed with <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> install are copied to the site-packages directory of
your current Python environment. This means that whenever you make a change to the
sources of that package, you are required to reinstall it. This is often a problem during
intensive development because it is very easy to forget about the need to perform
installation again. This is why <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> provides an extra <code class="docutils literal notranslate"><span class="pre">develop</span></code> command that
allows you to install packages in the development mode. This command creates a special
link to project sources in the deployment directory (site-packages) instead of copying
the whole package there. Package sources can be edited without the need for reinstallation
and are available in the <code class="docutils literal notranslate"><span class="pre">sys.path</span></code> as if they were installed normally.</p>
<p><code class="docutils literal notranslate"><span class="pre">pip</span></code> also allows you to install packages in such a mode. This installation option is
called editable mode and can be enabled with the <code class="docutils literal notranslate"><span class="pre">-e</span></code> parameter in the <code class="docutils literal notranslate"><span class="pre">install</span></code> command
as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>pip install -e &lt;project-path&gt;
</pre></div>
</div>
<p>Once you install the package in your environment in editable mode, you can freely modify
the installed package in place and all the changes will be immediately visible without the
need to reinstall the package.</p>
</div>
</div>
</div>
<div class="section" id="namespace-packages">
<h2>2. Namespace packages<a class="headerlink" href="#namespace-packages" title="Permalink to this headline">¶</a></h2>
<p><em>The Zen of Python</em> that you can read after writing <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code> in the interpreter session
says the following about namespaces:</p>
<p><em>“Namespaces are one honking great idea-let’s do more of those!”</em></p>
<p>And this can be understood in at least two ways. The first is a namespace in context of the
language. We all use the following namespaces without even knowing:</p>
<ul class="simple">
<li><p>The global namespace of a module</p></li>
<li><p>The local namespace of the function or method invocation</p></li>
<li><p>The class namespace</p></li>
</ul>
<p>The other kind of namespaces can be provided at the packaging level. These are <strong>namespace
packages</strong>. This is often an overlooked feature of Python packaging that can be very useful
in structuring the package ecosystem in your organization or in a very large project.</p>
<p>Namespace packages can be understood as a way of grouping related packages, where each
of these packages can be installed independently.</p>
<p>Namespace packages are especially useful if you have components of your application
developed, packaged, and versioned independently but you still want to access them from
the same namespace. This also helps to make clear to which organization or project every
package belongs. For instance, for some imaginary Acme company, the common
namespace could be <code class="docutils literal notranslate"><span class="pre">acme</span></code>. Therefore this organization could create the
general <code class="docutils literal notranslate"><span class="pre">acme</span></code> namespace package that could serve as a container for other packages from
this organization. For example, if someone from Acme wants to contribute to this
namespace with, for example, an SQL-related library, they can create a
new <code class="docutils literal notranslate"><span class="pre">acme.sql</span></code> package that registers itself in the acme namespace.</p>
<p>It is important to know what’s the difference between normal and namespace packages and
what problem they solve. Normally (without namespace packages), you would create a
package called <code class="docutils literal notranslate"><span class="pre">acme</span></code> with an <code class="docutils literal notranslate"><span class="pre">sql</span></code> subpackage/submodule with the following file structure:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree acme/
acme/
├── acme
│    ├── __init__.py
│    └── sql
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">3</span> files
</pre></div>
</div>
<p>Whenever you want to add a new subpackage, let’s say <code class="docutils literal notranslate"><span class="pre">templating</span></code>, you are forced to
include it in the source tree of <code class="docutils literal notranslate"><span class="pre">acme</span></code> as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree acme/
acme/
├── acme
│   ├── __init__.py
│   ├── sql
│   │    └── __init__.py
│   └── templating
│        └── __init__.py
└── setup.py

<span class="m">3</span> directories, <span class="m">4</span> files
</pre></div>
</div>
<p>Such an approach makes independent development
of <code class="docutils literal notranslate"><span class="pre">acme.sql</span></code> and <code class="docutils literal notranslate"><span class="pre">acme.templating</span></code> almost impossible. The <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script will also
have to specify all dependencies for every subpackage. So it is impossible (or at least very
hard) to have an installation of some of the <code class="docutils literal notranslate"><span class="pre">acme</span></code> components optional. Also, with enough
subpackages it is practically impossible to avoid dependency conflicts.</p>
<p>With namespace packages, you can store the source tree for each of these subpackages
independently as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree acme.sql/
acme.sql/
├── acme
│    └── sql
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">2</span> files


$ tree acme.templating/
acme.templating/
├── acme
│   └── templating
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">2</span> files
</pre></div>
</div>
<p>And you can also register them independently in PyPI or any package index you use. Users
can choose which of the subpackages they want to install from the acme namespace as
follows, but they never install the general <code class="docutils literal notranslate"><span class="pre">acme</span></code> package (it doesn’t even have to exist):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ pip install acme.sql acme.templating
</pre></div>
</div>
<p>Note that independent source trees are not enough to create namespace packages in
Python. You need a bit of additional work if you don’t want your packages to not overwrite
each other. Also proper handling may be different depending on the Python language
version you target. Details of that are described in the next two sections.</p>
<div class="section" id="implicit-namespace-packages">
<h3>2.1. Implicit namespace packages<a class="headerlink" href="#implicit-namespace-packages" title="Permalink to this headline">¶</a></h3>
<p>If you use and target only Python 3, then there is good news for you. PEP 420 (Implicit
Namespace Packages) introduced a new way to define namespace packages. It is part of
the standards track and became an official part of the language since version 3.3. In short,
every directory that contains Python packages or modules (including namespace packages
too) is considered a namespace package if it does not contain the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file. So, the
following are examples of file structures presented in the previous section:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree acme.sql/
acme.sql/
├── acme
│    └── sql
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">2</span> files


$ tree acme.templating/
acme.templating/
├── acme
│   └── templating
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">2</span> files
</pre></div>
</div>
<p>They are enough to define that acme is a namespace package under Python 3.3 and later.
Minimal <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> for <code class="docutils literal notranslate"><span class="pre">acme.templating</span></code> package will look like following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;acme.templating&#39;</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;acme.templating&#39;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Unfortunately, the <code class="docutils literal notranslate"><span class="pre">setuptools.find_packages()</span></code> function does not support PEP 420 at
the time of writing this section. This may change in the future. Also, a requirement to
explicitly define a list of packages seems to be a very small price to pay for easy integration
of namespace packages.</p>
</div>
<div class="section" id="namespace-packages-in-previous-python-versions">
<h3>2.2. Namespace packages in previous Python versions<a class="headerlink" href="#namespace-packages-in-previous-python-versions" title="Permalink to this headline">¶</a></h3>
<p>You can’t use implicit namespace packages (PEP 420 layout) in Python versions older than
3.3. Still, the concept of namespace packages is very old and was commonly used for years
in such mature projects such as Zope. It means that it is definitely possible to use
namespace packages in older version of Python. Actually, there are several ways to define
that the package should be treated as a namespace.</p>
<p>The simplest one is to create a file structure for each component that resembles an ordinary
package layout without implicit namespace packages and leave everything to <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>.</p>
<p>So, the example layout for <code class="docutils literal notranslate"><span class="pre">acme.sql</span></code> and a <code class="docutils literal notranslate"><span class="pre">cme.templating</span></code> could be the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree acme.sql/
acme.sql/
├── acme
│    ├── __init__.py
│    └── sql
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">3</span> files


$ tree acme.templating/
acme.templating/
├── acme
│    ├── __init__.py
│    └── templating
│       └── __init__.py
└── setup.py

<span class="m">2</span> directories, <span class="m">3</span> files
</pre></div>
</div>
<p>Note that for both <code class="docutils literal notranslate"><span class="pre">acme.sql</span></code> and <code class="docutils literal notranslate"><span class="pre">acme.templating</span></code>, there is an additional source
file, <code class="docutils literal notranslate"><span class="pre">acme/__init__.py</span></code>. This file must be left empty. The <code class="docutils literal notranslate"><span class="pre">acme</span></code> namespace package will be
created if we provide its name as a value of the <code class="docutils literal notranslate"><span class="pre">namespace_packages</span></code> keyword argument
of the <code class="docutils literal notranslate"><span class="pre">setuptools.setup()</span></code> function as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;acme.templating&#39;</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;acme.templating&#39;</span><span class="p">],</span>
    <span class="n">namespace_packages</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;acme&#39;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Easiest does not mean best. The <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> module in order to register a new namespace
will call for the <code class="docutils literal notranslate"><span class="pre">pkg_resources.declare_namespace()</span></code> function in
your <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file. It will happen even if the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file is empty. Anyway, as
the official documentation says, it is your own responsibility to declare namespaces in
the <code class="docutils literal notranslate"><span class="pre">__init__.py</span></code> file, and this implicit behavior of <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> may be dropped in the
future. In order to be safe and future-proof, you need to add the following line to
the <code class="docutils literal notranslate"><span class="pre">acme/__init__.py</span></code> file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">__import__</span><span class="p">(</span><span class="s1">&#39;pkg_resources&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">declare_namespace</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>
</div>
<p>This line will make your namespace package safe from potential future changes regarding
namespace packages in the <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> module.</p>
</div>
</div>
<div class="section" id="uploading-a-package">
<h2>3. Uploading a package<a class="headerlink" href="#uploading-a-package" title="Permalink to this headline">¶</a></h2>
<p>Packages would be useless without an organized way to store, upload, and download
them. Python Package Index is the main source of open source packages in the Python
community. Anyone can freely upload new packages and the only requirement is to
register on the PyPI site: <a class="reference external" href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a>.</p>
<p>You are not, of course, limited to only this index and all Python packaging tools support the
usage of alternative package repositories. This is especially useful for distributing closed
source code among internal organizations or for deployment purposes. Details of such
packaging usage with instructions on how to create your own package index will be
explained in the next chapter. Here we focus mainly on open source uploads to PyPI, with
only little mention on how to specify alternative repositories.</p>
<div class="section" id="pypi-python-package-index">
<h3>3.1. PyPI: Python Package Index<a class="headerlink" href="#pypi-python-package-index" title="Permalink to this headline">¶</a></h3>
<p>Python Package Index is, as already mentioned, the official source of open source package
distributions. Downloading from it does not require any account or permission. The only
thing you need is a package manager that can download new distributions from PyPI. Your
preferred choice should be <code class="docutils literal notranslate"><span class="pre">pip</span></code>.</p>
<div class="section" id="uploading-to-pypi">
<h4>3.1.1. Uploading to PyPI<a class="headerlink" href="#uploading-to-pypi" title="Permalink to this headline">¶</a></h4>
<p>Anyone can register and upload packages to PyPI provided that he or she has an account
registered. Packages are bound to the user, so, by default, only the user that registered the
name of the package is its admin and can upload new distributions. This could be a
problem for bigger projects, so there is an option to mark other users as package
maintainers so that they are able to upload new distributions too.</p>
<p>The easiest way to upload a package is to use the following upload command of
the setup.py script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py &lt;dist-commands&gt; upload
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">&lt;dist-commands&gt;</span></code> is a list of commands that creates distributions to upload. Only
distributions created during the same <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> execution will be uploaded to the
repository. So, if you upload source distribution, built distribution, and <code class="docutils literal notranslate"><span class="pre">wheel</span></code> package at
once, then you need to issue the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist bdist bdist_wheel upload
</pre></div>
</div>
<p>When uploading using <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>, you cannot reuse distributions that were already built in
previous command calls and are forced to rebuild them on every upload. This may be
inconvenient for large or complex projects where creation of the actual distribution may
take a considerable amount of time. Another problem of <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> upload is that it can
use plain text HTTP or unverified HTTPS connections on some Python versions. This is
why Twine is recommended as a secure replacement for the <code class="docutils literal notranslate"><span class="pre">setup.py</span> <span class="pre">upload</span></code> command.</p>
<p>Twine is the utility for interacting with PyPI that currently serves only one
purpose: securely uploading packages to the repository. It supports any packaging format
and always ensures that the connection is secure. It also allows you to upload files that
were already created, so you are able to test distributions before release. The following
example usage of twine still requires invoking the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script for building
distributions:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist bdist_wheel
$ twine upload dist/*
</pre></div>
</div>
</div>
<div class="section" id="pypirc">
<h4>3.1.2. .pypirc<a class="headerlink" href="#pypirc" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">.pypirc</span></code> is a configuration file that stores information about Python packages repositories.
It should be located in your home directory. The format for this file is as follows:</p>
<div class="highlight-cfg notranslate"><div class="highlight"><pre><span></span><span class="k">[distutils]</span>
<span class="na">index-servers</span> <span class="o">=</span><span class="s"></span>
<span class="s">    pypi</span>
<span class="s">    other</span>

<span class="k">[pypi]</span>
<span class="na">repository: &lt;repository-url&gt;</span>
<span class="na">username: &lt;username&gt;</span>
<span class="na">password: &lt;password&gt;</span>

<span class="k">[other]</span>
<span class="na">repository: https://example.com/pypi</span>
<span class="na">username: &lt;username&gt;</span>
<span class="na">password: &lt;password&gt;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">distutils</span></code> section should have the <code class="docutils literal notranslate"><span class="pre">index-servers</span></code> variable that lists all sections
describing all the available repositories and credentials for them. There are only the
following three variables that can be modified for each repository section:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">repository</span></code>: This is the URL of the package repository (it defaults to <a class="reference external" href="https://pypi.org">https://pypi.org/</a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">username</span></code>: This is the username for authentication in the given repository.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">password</span></code>: This is the user password for authentication in the given repository (in plain text).</p></li>
</ul>
<p>Note that storing your repository password in plain text may not be the wisest security
choice. You can always leave it blank and you should be prompted for it whenever it is
necessary.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">.pypirc</span></code> file should be respected by every packaging tool built for Python. While this
may not be true for every packaging-related utility out there, it is supported by the most
important ones, such as <code class="docutils literal notranslate"><span class="pre">pip</span></code>, <code class="docutils literal notranslate"><span class="pre">twine</span></code>, <code class="docutils literal notranslate"><span class="pre">distutils</span></code> and <code class="docutils literal notranslate"><span class="pre">setuptools</span></code>.</p>
</div>
</div>
<div class="section" id="source-packages-versus-built-packages">
<h3>3.2. Source packages versus built packages<a class="headerlink" href="#source-packages-versus-built-packages" title="Permalink to this headline">¶</a></h3>
<p>There are generally the following two types of distributions for Python packages:</p>
<ul class="simple">
<li><p>Source distributions</p></li>
<li><p>Built (binary) distributions</p></li>
</ul>
<p>Source distributions are the simplest and most platform independent. For pure Python
packages, it is a no-brainer. Such a distribution contains only Python sources and these
should already be highly portable.</p>
<p>A more complex situation is when your package introduces some extensions written, for
example, in C. Source distributions will still work provided that the package user has
proper development toolchain in his/her environment. This consists mostly of the compiler
and proper C header files. For such cases, the build distribution format may be better suited
because it can provide already built extensions for specific platforms.</p>
</div>
<div class="section" id="sdist">
<h3>3.2.1. sdist<a class="headerlink" href="#sdist" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">sdist</span></code> command is the simplest command available. It creates a release tree where
everything that is needed to run the package is copied to. This tree is then archived in one
or many archived files (often, it just creates one tarball). The archive is basically a copy of
the source tree.</p>
<p>This command is the easiest way to distribute a package that would be independent from
the target system. It creates a <code class="docutils literal notranslate"><span class="pre">dist/</span></code> directory for storing the archives to be distributed.
Before you create the first distribution, you have to provide a <code class="docutils literal notranslate"><span class="pre">setup()</span></code> call with a version
number, as follows. If you don’t, <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> module will assume default value
of <code class="docutils literal notranslate"><span class="pre">version</span> <span class="pre">=</span> <span class="pre">'0.0.0'</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;acme.sql&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;0.1.1&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Every time a package is released, the version number should be increased so that the target
system knows the package has changed.</p>
<p>Let’s run the following <code class="docutils literal notranslate"><span class="pre">sdist</span></code> command for <code class="docutils literal notranslate"><span class="pre">acme.sql</span></code> package in <code class="docutils literal notranslate"><span class="pre">0.1.1</span></code> version:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py sdist
running sdist
...
creating dist
tar -cf dist/acme.sql-0.1.1.tar acme.sql-0.1.1
gzip -f9 dist/acme.sql-0.1.1.tar
removing <span class="s1">&#39;acme.sql-0.1.1&#39;</span> <span class="o">(</span>and everything under it<span class="o">)</span>

$ ls dist/
acme.sql-0.1.1.tar.gz
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On Windows, the default archive type will be ZIP.</p>
</div>
<p>The version is used to mark the name of the archive, which can be distributed and installed
on any system that has Python. In the <code class="docutils literal notranslate"><span class="pre">sdist</span></code> distribution, if the package contains C libraries
or extensions, the target system is responsible for compiling them. This is very common for
Linux-based systems or macOS because they commonly provide a compiler. But it is less
usual to have it under Windows. That’s why a package should always be distributed with a
prebuilt distribution as well, when it is intended to be run on several platforms.</p>
<div class="section" id="bdist-and-wheels">
<h4>3.2.2. bdist and wheels<a class="headerlink" href="#bdist-and-wheels" title="Permalink to this headline">¶</a></h4>
<p>To be able to distribute a prebuilt distribution, <code class="docutils literal notranslate"><span class="pre">distutils</span></code> provides the <code class="docutils literal notranslate"><span class="pre">build</span></code> command.
This commands compiles the package in the following four steps:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">build_py</span></code>: This builds pure Python modules by byte-compiling them and copying them into the build folder.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">build_clib</span></code>: This builds C libraries, when the package contains any, using Python compiler and creating a static library in the build folder.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">build_ext</span></code>: This builds C extensions and puts the result in the build folder like <code class="docutils literal notranslate"><span class="pre">build_clib</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">build_scripts</span></code>: This builds the modules that are marked as scripts. It also changes the interpreter path when the first line was set (using <code class="docutils literal notranslate"><span class="pre">!#</span></code> prefix) and fixes the file mode so that it is executable.</p></li>
</ul>
<p>Each of these steps is a command that can be called independently. The result of the
compilation process is a <code class="docutils literal notranslate"><span class="pre">build</span></code> folder that contains everything needed for the package to be
installed. There’s no cross-compiler option yet in the <code class="docutils literal notranslate"><span class="pre">distutils</span></code> package. This means that
the result of the command is always specific to the system it was built on.</p>
<p>When some C extensions have to be created, the build process uses the default system
compiler and the Python header file (<code class="docutils literal notranslate"><span class="pre">Python.h</span></code>). This include file is available from the time
Python was built from the sources. For a packaged distribution, an extra package for your
system distribution is probably required. At least in popular Linux distributions, it is often
named <code class="docutils literal notranslate"><span class="pre">python-dev</span></code>. It contains all the necessary header files for building Python
extensions.</p>
<p>The C compiler used in the build process is the compiler that is default for your operating
system. For a Linux-based system or macOS, this would be gcc or clang respectively. For
Windows, Microsoft Visual C++ can be used (there’s a free command-line version
available). The open source project MinGW can be used as well. This can be configured
in <code class="docutils literal notranslate"><span class="pre">distutils</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">build</span></code> command is used by the <code class="docutils literal notranslate"><span class="pre">bdist</span></code> command to build a binary distribution. It
invokes <code class="docutils literal notranslate"><span class="pre">build</span></code> and all the dependent commands, and then creates an archive in the same
way as <code class="docutils literal notranslate"><span class="pre">sdist</span></code> does.</p>
<p>Let’s create a binary distribution for <code class="docutils literal notranslate"><span class="pre">acme.sql</span></code> on macOS as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py bdist
running bdist
running bdist_dumb
running build
...
running install_scripts
tar -cf dist/acme.sql-0.1.1.macosx-10.3-fat.tar .
gzip -f9 acme.sql-0.1.1.macosx-10.3-fat.tar
removing <span class="s1">&#39;build/bdist.macosx-10.3-fat/dumb&#39;</span> <span class="o">(</span>and everything under it<span class="o">)</span>

$ ls dist/
acme.sql-0.1.1.macosx-10.3-fat.tar.gz
acme.sql-0.1.1.tar.gz
</pre></div>
</div>
<p>Notice that the newly created archive’s name contains the name of the system and the
distribution it was built on (macOS 10.3).</p>
<p>The same command invoked on Windows will create a another system, specific distribution
archive as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>C:<span class="se">\a</span>cme.sql&gt; python.exe setup.py bdist
...

C:<span class="se">\a</span>cme.sql&gt; dir dist
<span class="m">25</span>/02/2008      <span class="m">08</span>:18       &lt;DIR&gt;       .
<span class="m">25</span>/02/2008      <span class="m">08</span>:18       &lt;DIR&gt;       ..
<span class="m">25</span>/02/2008      <span class="m">08</span>:24                   <span class="m">16</span> <span class="m">055</span> acme.sql-0.1.1.win32.zip
                    <span class="m">1</span> File<span class="o">(</span>s<span class="o">)</span>   <span class="m">16</span> <span class="m">055</span> bytes
                    <span class="m">2</span> Dir<span class="o">(</span>s<span class="o">)</span>    <span class="m">22</span> <span class="m">239</span> <span class="m">752</span> <span class="m">192</span> bytes free
</pre></div>
</div>
<p>If a package contains C code, apart from a source distribution, it’s important to release as
many different binary distributions as possible. At the very least, a Windows binary
distribution is important for those who most probably don’t have a C compiler installed.</p>
<p>A binary release contains a tree that can be copied directly into the Python tree. It mainly
contains a folder that is copied into Python’s <code class="docutils literal notranslate"><span class="pre">site-packages</span></code> folder. It may also contain
cached bytecode files (<code class="docutils literal notranslate"><span class="pre">*.pyc</span></code> files on Python 2 and <code class="docutils literal notranslate"><span class="pre">__pycache__/*.pyc</span></code> on Python 3).</p>
<p>The other kind of build distributions are wheels provided by the <code class="docutils literal notranslate"><span class="pre">wheel</span></code> package. When
installed (for example, using <code class="docutils literal notranslate"><span class="pre">pip</span></code>), the wheel package adds a new <code class="docutils literal notranslate"><span class="pre">bdist_wheel</span></code> command
to the <code class="docutils literal notranslate"><span class="pre">distutils</span></code>. It allows creating platform specific distributions (currently only for
Windows, macOS, and Linux) that are better alternatives to normal bdist distributions. It
was designed to replace another distribution format introduced earlier
by <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> called eggs. Eggs are now obsolete, so won’t be featured in here. The
list of advantages of using wheels is quite long. Here are the ones that are mentioned on the
Python Wheels page (<a class="reference external" href="http://pythonwheels.com">http://pythonwheels.com/</a>):</p>
<ul class="simple">
<li><p>Faster installation for pure Python and native C extension packages</p></li>
<li><p>Avoids arbitrary code execution for installation. (avoids <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>)</p></li>
<li><p>Installation of a C extension does not require a compiler on Windows, macOS, or Linux.</p></li>
<li><p>Allows better caching for testing and continuous integration.</p></li>
<li><p>Creates <code class="docutils literal notranslate"><span class="pre">.pyc</span></code> files as part of the installation to ensure they match the Python interpreter used</p></li>
<li><p>More consistent installs across platforms and machines</p></li>
</ul>
<p>According to PyPA’s recommendation, wheels should be your default distribution format.
For a very long time, the binary wheels for Linux were not supported, but that has changed
fortunately. Binary wheels for Linux are called manylinux wheels. The process of building
them is unfortunately not as straightforward as for Windows and macOS binary wheels.
For these kind of wheels, PyPA maintains special Docker images that serve as a ready-to-
use build environments. For sources of these images and more information, you can visit
their official repository on GitHub: <a class="reference external" href="https://github.com/pypa/manylinux">https://github.com/pypa/manylinux</a>.</p>
</div>
</div>
</div>
<div class="section" id="standalone-executables">
<h2>4. Standalone executables<a class="headerlink" href="#standalone-executables" title="Permalink to this headline">¶</a></h2>
<p>Creating standalone executables is a commonly overlooked topic in materials that cover
packaging of Python code. This is mainly because Python lacks proper tools in its standard
library that could allow programmers to create simple executables that could be run by
users without the need to install the Python interpreter.</p>
<p>Compiled languages have a big advantage over Python in that they allow you to create an
executable application for the given system architecture that could be run by users in a way
that does not require from them any knowledge of the underlying technology. Python code,
when distributed as a package, requires the Python interpreter in order to be run. This
creates a big inconvenience for users who do not have enough technical proficiency.</p>
<p>Developer-friendly operating systems, such as macOS or most Linux distributions, come
with Python interpreter preinstalled. So, for their users, the Python-based application still
could be distributed as a source package that relies on a specific <strong>interpreter directive</strong> in the
main script file that is popularly called <strong>shebang</strong>. For most of Python applications, this takes
the following form:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
</pre></div>
</div>
<p>Such directive when used as a first line of script will mark it to be interpreted in the default
Python version for the given environment. This can, of course, take a more detailed form
that requires a specific Python version such as <code class="docutils literal notranslate"><span class="pre">python3.4</span></code>, <code class="docutils literal notranslate"><span class="pre">python3</span></code>, <code class="docutils literal notranslate"><span class="pre">python2</span></code> and so on.
Note that this will work in most popular POSIX systems, but isn’t portable at all. This
solution relies on the existence of specific Python versions and also the availability of
an <code class="docutils literal notranslate"><span class="pre">env</span></code> executable exactly at <code class="docutils literal notranslate"><span class="pre">/usr/bin/env</span></code>. Both of these assumptions may fail on some
operating systems. Also, shebang will not work on Windows at all. Additionally,
bootstrapping of the Python environment on Windows can be a challenge even for
experienced developers, so you cannot expect that nontechnical users will be able to do that
by themselves.</p>
<p>The other thing to consider is the simple user experience in the desktop environment. Users
usually expect that applications can be run from the desktop by simply clicking on them.
Not every desktop environment will support that with Python applications distributed as a
source.</p>
<p>So it would be best if we are able to create a binary distribution that would work as any
other compiled executable. Fortunately, it is possible to create an executable that has both
the Python interpreter and our project embedded. This allows users to open our application
without caring about Python or any other dependency.</p>
<div class="section" id="when-standalone-executables-useful">
<h3>4.1. When standalone executables useful?<a class="headerlink" href="#when-standalone-executables-useful" title="Permalink to this headline">¶</a></h3>
<p>Standalone executables are useful in situations where simplicity of the user experience is
more important than the user’s ability to interfere with the applications code. Note that the
fact that you are distributing applications as executables only makes code reading or
modification harder, not impossible. It is not a way to secure application code and should
only be used as a way to make interacting with the application simpler.</p>
<p>Standalone executables should be a preferred way of distributing applications for
nontechnical end users and also seems to be the only reasonable way of distributing any
Python application for Windows.</p>
<p>Standalone executables are usually a good choice for the following:</p>
<ul class="simple">
<li><p>Applications that depend on specific Python versions that may not be easily available on the target operating systems</p></li>
<li><p>Applications that rely on modified precompiled CPython sources</p></li>
<li><p>Applications with graphical interfaces</p></li>
<li><p>Projects that have many binary extensions written in different languages</p></li>
<li><p>Games</p></li>
</ul>
</div>
<div class="section" id="popular-tools">
<h3>4.2. Popular tools<a class="headerlink" href="#popular-tools" title="Permalink to this headline">¶</a></h3>
<p>Python does not have any built-in support for building standalone executables.
Fortunately, there are some community projects solving that problem with varied amounts
of success. The following four are the most notable:</p>
<ul class="simple">
<li><p>PyInstaller</p></li>
<li><p>cx_Freeze</p></li>
<li><p>py2exe</p></li>
<li><p>py2app</p></li>
</ul>
<p>Each one of them is slightly different in use and also each one of them has slightly different
limitations. Before choosing your tool, you need to decide which platform you want to
target, because every packaging tool can support only a specific set of operating systems.</p>
<p>It is best if you make such a decision at the very beginning of the project’s life. None of
these tools, of course, requires deep interaction in your code, but if you start building
standalone packages early, you can automate the whole process and save future integration
time and costs. If you leave this for later, you may find yourself in a situation where the
project is built in such a sophisticated way that none of the available tools will work.
Providing a standalone executable for such a project will be problematic and will take a lot
of your time.</p>
<div class="section" id="pyinstaller">
<h4>4.2.1. PyInstaller<a class="headerlink" href="#pyinstaller" title="Permalink to this headline">¶</a></h4>
<p>PyInstaller (<a class="reference external" href="http://www.pyinstaller.org">http://www.pyinstaller.org</a>)
is by far the most advanced program to freeze
Python packages into standalone executables. It provides the most extensive multiplatform
compatibility among every available solution at the moment, so it is the most highly
recommended one. PyInstaller supports the following platforms:</p>
<ul class="simple">
<li><p>Windows (32-bit and 64-bit)</p></li>
<li><p>Linux (32-bit and 64-bit)</p></li>
<li><p>macOS (32-bit and 64-bit)</p></li>
<li><p>FreeBSD, Solaris, and AIX</p></li>
</ul>
<p>Supported versions of Python are Python 2.7 and Python 3.3, 3.4, and 3.5. It is available on
PyPI, so it can be installed in your working environment using pip. If you have problems
installing it this way, you can always download the installer from the project’s page.</p>
<p>Unfortunately, cross-platform building (cross-compilation) is not supported, so if you want
to build your standalone executable for a specific platform, then you need to perform
building on that platform. This is not a big problem today with the advent of many
virtualization tools. If you don’t have a specific system installed on your computer, you can
always use Vagrant, which will provide you with the desired operating system as a virtual
machine.</p>
<p>Usage for simple applications is pretty straightforward. Let’s assume our application is
contained in the script named <code class="docutils literal notranslate"><span class="pre">myscript.py</span></code> . This is a simple hello world application. We
want to create a standalone executable for Windows users and we have our sources located
under <code class="docutils literal notranslate"><span class="pre">D://dev/app</span></code> in the filesystem. Our application can be bundled with the following
short command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ pyinstaller myscript.py
<span class="m">2121</span> INFO: PyInstaller: <span class="m">3</span>.1
<span class="m">2121</span> INFO: Python: <span class="m">2</span>.7.10
<span class="m">2121</span> INFO: Platform: Windows-7-6.1.7601-SP1
<span class="m">2121</span> INFO: wrote D:<span class="se">\d</span>ev<span class="se">\a</span>pp<span class="se">\m</span>yscript.spec
<span class="m">2137</span> INFO: UPX is not available.
<span class="m">2138</span> INFO: Extending PYTHONPATH with paths <span class="o">[</span><span class="s1">&#39;D:\\dev\\app&#39;</span>, <span class="s1">&#39;D:\\dev\\app&#39;</span><span class="o">]</span>
<span class="m">2138</span> INFO: checking Analysis
<span class="m">2138</span> INFO: Building Analysis because out00-Analysis.toc is non existent
<span class="m">2138</span> INFO: Initializing module dependency graph...
<span class="m">2154</span> INFO: Initializing module graph hooks...
<span class="m">2325</span> INFO: running Analysis out00-Analysis.toc
<span class="o">(</span>...<span class="o">)</span>
<span class="m">25884</span> INFO: Updating resource <span class="nb">type</span> <span class="m">24</span> name <span class="m">2</span> language <span class="m">1033</span>
</pre></div>
</div>
<p>PyInstaller’s standard output is quite long, even for simple applications, so it was truncated
in the preceding example for the sake of brevity. If run on Windows, the resulting structure
of directories and files will be as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree /0066
│   ├─── myscript.py
│   └─── myscript.spec
│
├───build
│    └───myscript
│           ├─── myscript.exe
│           ├─── myscript.exe.manifest
│           ├─── out00-Analysis.toc
│           ├─── out00-COLLECT.toc
│           ├─── out00-EXE.toc
│           ├─── out00-PKG.pkg
│           ├─── out00-PKG.toc
│           ├─── out00-PYZ.pyz
│           ├─── out00-PYZ.toc
│           └─── warnmyscript.txt
│
└───dist
    └───myscript
            ├─── bz2.pyd
            ├─── Microsoft.VC90.CRT.manifest
            ├─── msvcm90.dll
            ├─── msvcp90.dll
            ├─── msvcr90.dll
            ├─── myscript.exe
            ├─── myscript.exe.manifest
            ├─── python27.dll
            ├─── <span class="k">select</span>.pyd
            ├─── unicodedata.pyd
            └───_hashlib.pyd
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">dist/myscript</span></code> directory contains the built application that can now be distributed to
the users. Note that whole directory must be distributed. It contains all the additional files
that are required to run our application (DLLs, compiled extension libraries, and so on). A
more compact distribution can be obtained with the <code class="docutils literal notranslate"><span class="pre">--onefile</span></code> switch of
the <code class="docutils literal notranslate"><span class="pre">pyinstaller</span></code> command as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ pyinstaller --onefile myscript.py
<span class="o">(</span>...<span class="o">)</span>

$ tree /f
├───build
│    └───myscript
│           ├─── myscript.exe.manifest
│           ├─── out00-Analysis.toc
│           ├─── out00-EXE.toc
│           ├─── out00-PKG.pkg
│           ├─── out00-PKG.toc
│           ├─── out00-PYZ.pyz
│           ├─── out00-PYZ.toc
│           └─── warnmyscript.txt
│
└───dist
    └───myscript
            └─── myscript.exe
</pre></div>
</div>
<p>When built with the <code class="docutils literal notranslate"><span class="pre">--onefile</span></code> option, the only file you need to distribute to other users is
the single executable found in the <code class="docutils literal notranslate"><span class="pre">dist</span></code> directory (here, <code class="docutils literal notranslate"><span class="pre">myscript.exe</span></code>). For small
applications, this is probably the preferred option.</p>
<p>One of the side effects of running the <code class="docutils literal notranslate"><span class="pre">pyinstaller</span></code> command is the creation of
the <code class="docutils literal notranslate"><span class="pre">*.spec</span></code> file. This is an auto generated Python module containing specification on how
to create executables from your sources. This is the example specification file created
automatically for <code class="docutils literal notranslate"><span class="pre">myscript.py</span></code> code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># -*- mode: python -*-</span>
<span class="n">block_cipher</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">Analysis</span><span class="p">([</span><span class="s1">&#39;myscript.py&#39;</span><span class="p">],</span>
             <span class="n">pathex</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;D:</span><span class="se">\\</span><span class="s1">dev</span><span class="se">\\</span><span class="s1">app&#39;</span><span class="p">],</span>
             <span class="n">binaries</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">datas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">hiddenimports</span><span class="o">=</span><span class="p">[],</span>
             <span class="n">hookspath</span><span class="o">=</span><span class="p">[],</span>
             <span class="n">runtime_hooks</span><span class="o">=</span><span class="p">[],</span>
             <span class="n">excludes</span><span class="o">=</span><span class="p">[],</span>
             <span class="n">win_no_prefer_redirects</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">win_private_assemblies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">cipher</span><span class="o">=</span><span class="n">block_cipher</span><span class="p">)</span>
<span class="n">pyz</span> <span class="o">=</span> <span class="n">PYZ</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">zipped_data</span><span class="p">,</span> <span class="n">cipher</span><span class="o">=</span><span class="n">block_cipher</span><span class="p">)</span>
<span class="n">exe</span> <span class="o">=</span> <span class="n">EXE</span><span class="p">(</span><span class="n">pyz</span><span class="p">,</span>
          <span class="n">a</span><span class="o">.</span><span class="n">scripts</span><span class="p">,</span>
          <span class="n">a</span><span class="o">.</span><span class="n">binaries</span><span class="p">,</span>
          <span class="n">a</span><span class="o">.</span><span class="n">zipfiles</span><span class="p">,</span>
          <span class="n">a</span><span class="o">.</span><span class="n">datas</span><span class="p">,</span>
          <span class="n">name</span><span class="o">=</span><span class="s1">&#39;myscript&#39;</span><span class="p">,</span>
          <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">strip</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">upx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
          <span class="n">console</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This <code class="docutils literal notranslate"><span class="pre">.spec</span></code> file contains all <code class="docutils literal notranslate"><span class="pre">pyinstaller</span></code> arguments specified earlier. This is very useful if
you have performed a lot of customizations to your build. Once created, you can use it as
an argument to the <code class="docutils literal notranslate"><span class="pre">pyinstaller</span></code> command instead of your Python script as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ pyinstaller.exe myscript.spec
</pre></div>
</div>
<p>Note that this is a real Python module, so you can extend it and perform more complex
customizations to the building procedure. Customizing the <code class="docutils literal notranslate"><span class="pre">.spec</span></code> file is especially useful
when you are targeting many different platforms. Also, not all of the <code class="docutils literal notranslate"><span class="pre">pyinstaller</span></code> options
are available through the command-line interface and can be used only when
modifying <code class="docutils literal notranslate"><span class="pre">.spec</span></code> file.</p>
<p>PyInstaller is an extensive tool, which by its usage is very simple for the great majority of
programs. Anyway, thorough reading of its documentation is recommended if you are
interested in using it as a tool to distribute your applications.</p>
</div>
<div class="section" id="cx-freeze">
<h4>4.2.2. cx_Freeze<a class="headerlink" href="#cx-freeze" title="Permalink to this headline">¶</a></h4>
<p>cx_Freeze ( <a class="reference external" href="http://cx-freeze.sourceforge.net/">http://cx-freeze.sourceforge.net/</a>)
is another tool for creating standalone
executables. It is a simpler solution than PyInstaller, but also supports the following three
major platforms:</p>
<ul class="simple">
<li><p>Windows</p></li>
<li><p>Linux</p></li>
<li><p>macOS</p></li>
</ul>
<p>Like PyInstaller, it does not allow you to perform cross-platform builds, so you need to
create your executables on the same operating system you are distributing to. The major
disadvantage of cx_Freeze is that it does not allow you to create real single-file executables.
Applications built with it need to be distributed with related DLL files and libraries.
Assuming that we have the same application as featured in the PyInstaller section, the
example usage is very simple as well:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ cxfreeze myscript.py
copying C:<span class="se">\P</span>ython27<span class="se">\l</span>ib<span class="se">\s</span>ite-packages<span class="se">\c</span>x_Freeze<span class="se">\b</span>ases<span class="se">\C</span>onsole.exe -&gt;
D:<span class="se">\d</span>ev<span class="se">\a</span>pp<span class="se">\d</span>ist<span class="se">\m</span>yscript.exe
copying C:<span class="se">\W</span>indows<span class="se">\s</span>ystem32<span class="se">\p</span>ython27.dll -&gt;
D:<span class="se">\d</span>ev<span class="se">\a</span>pp<span class="se">\d</span>ist<span class="se">\p</span>ython27.dll
writing zip file D:<span class="se">\d</span>ev<span class="se">\a</span>pp<span class="se">\d</span>ist<span class="se">\m</span>yscript.exe
<span class="o">(</span>...<span class="o">)</span>
copying C:<span class="se">\P</span>ython27<span class="se">\D</span>LLs<span class="se">\b</span>z2.pyd -&gt; D:<span class="se">\d</span>ev<span class="se">\a</span>pp<span class="se">\d</span>ist<span class="se">\b</span>z2.pyd
copying C:<span class="se">\P</span>ython27<span class="se">\D</span>LLs<span class="se">\u</span>nicodedata.pyd -&gt; D:<span class="se">\d</span>ev<span class="se">\a</span>pp<span class="se">\d</span>ist<span class="se">\u</span>nicodedata.pyd
</pre></div>
</div>
<p>Resulting structure of files is as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ tree /f
│   └─── myscript.py
│
└───dist
    ├─── bz2.pyd
    ├─── myscript.exe
    ├─── python27.dll
    └─── unicodedata.pyd
</pre></div>
</div>
<p>Instead of providing the own format for build specification (like PyInstaller does),
cx_Freeze extends the distutils package. This means you can configure how your
standalone executable is built with the familiar setup.py script. This makes cx_Freeze very
convenient if you already distribute your package
using setuptools or distutils because additional integration requires only small
changes to your setup.py script. Here is an example of such a setup.py script
using cx_Freeze.setup() for creating standalone executables on Windows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">cx_Freeze</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">Executable</span>

<span class="c1"># Dependencies are automatically detected, but it might need fine tuning.</span>
<span class="n">build_exe_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;packages&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;os&quot;</span><span class="p">],</span> <span class="s2">&quot;excludes&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tkinter&quot;</span><span class="p">]}</span>
<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;myscript&quot;</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;My Hello World application!&quot;</span><span class="p">,</span>
    <span class="n">options</span><span class="o">=</span><span class="p">{</span>
        <span class="s2">&quot;build_exe&quot;</span><span class="p">:</span> <span class="n">build_exe_options</span>
    <span class="p">},</span>
    <span class="n">executables</span><span class="o">=</span><span class="p">[</span><span class="n">Executable</span><span class="p">(</span><span class="s2">&quot;myscript.py&quot;</span><span class="p">)]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>With such a file, the new executable can be created using the new <code class="docutils literal notranslate"><span class="pre">build_exe</span></code> command
added to the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ python setup.py build_exe
</pre></div>
</div>
<p>The usage of <code class="docutils literal notranslate"><span class="pre">cx_Freeze</span></code> seems a bit easier than PyInstaller’s, and <code class="docutils literal notranslate"><span class="pre">distutils</span></code> integration is
a very useful feature. Unfortunately this project may cause some trouble for inexperienced
developers due to the following reasons:</p>
<ul class="simple">
<li><p>Installation using pip may be problematic under Windows.</p></li>
<li><p>The official documentation is very brief and lacking in some places.</p></li>
</ul>
</div>
<div class="section" id="py2exe-and-py2app">
<h4>4.2.3. py2exe and py2app<a class="headerlink" href="#py2exe-and-py2app" title="Permalink to this headline">¶</a></h4>
<p>py2exe (<a class="reference external" href="http://www.py2exe.org">http://www.py2exe.org</a>) and py2app
(<a class="reference external" href="https:://py2app.readthedocs.io/en/latest/">https:://py2app.readthedocs.io/en/latest/</a>)
are two complementary programs that integrate with Python packaging either
via <code class="docutils literal notranslate"><span class="pre">distutils</span></code> or <code class="docutils literal notranslate"><span class="pre">setuptools</span></code> in order to create standalone executables. Here they are
mentioned together because they are very similar in both usage and their limitations. The
major drawback of py2exe and py2app is that they target only a single platform:</p>
<ul class="simple">
<li><p>py2exe allows building Windows executables.</p></li>
<li><p>py2app allows building macOS apps.</p></li>
</ul>
<p>Because the usage is very similar and requires only modification of the setup.py script,
these packages complement each other. The documentation of the py2app project provides
the following example of the setup.py script, which allows you to build standalone
executables with the right tool (either py2exe or py2app) depending on the platform used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>


<span class="n">mainscript</span> <span class="o">=</span> <span class="s1">&#39;MyApplication.py&#39;</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;darwin&#39;</span><span class="p">:</span>
    <span class="n">extra_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">setup_requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;py2app&#39;</span><span class="p">],</span>
        <span class="n">app</span><span class="o">=</span><span class="p">[</span><span class="n">mainscript</span><span class="p">],</span>
        <span class="c1"># Cross-platform applications generally expect sys.argv to</span>
        <span class="c1"># be used for opening files.</span>
        <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">py2app</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">argv_emulation</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="p">)</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
    <span class="n">extra_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">setup_requires</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;py2exe&#39;</span><span class="p">],</span>
        <span class="n">app</span><span class="o">=</span><span class="p">[</span><span class="n">mainscript</span><span class="p">]</span>
    <span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">extra_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># Normally unix-like platforms will use &quot;setup.py install&quot;</span>
    <span class="c1"># and install the main script as such</span>
        <span class="n">scripts</span><span class="o">=</span><span class="p">[</span><span class="n">mainscript</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">setup</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;MyApplication&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">extra_options</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>With such a script, you can build your Windows executable using the python <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
<code class="docutils literal notranslate"><span class="pre">py2exe</span></code> command and macOS app using <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">py2app</span></code>. Cross-compilation
is, of course, not possible.</p>
<p>Despite py2app and py2exe having obvious limitations and offering less elasticity than
PyInstaller or cx_Freeze, it is always good to be familiar with them. In some cases,
PyInstaller or cx_Freeze might fail to build the executable for the project properly. In such
situations, it is always worth checking whether other solutions can handle your code.</p>
</div>
<div class="section" id="security-of-python-code-in-executable-packages">
<h4>4.3. Security of Python code in executable packages<a class="headerlink" href="#security-of-python-code-in-executable-packages" title="Permalink to this headline">¶</a></h4>
<p>It is important to know that standalone executables do not make the application code
secure by any means. It is not an easy task to decompile the embedded code from such
executable files, but it is definitely doable. What is even more important is that the results
of such decompilation (if done with proper tools) might look strikingly similar to original
sources.</p>
<p>This fact makes standalone Python executables not a viable solution for closed source
projects where leaking of the application code could harm the organization. So, if your
whole business can be copied simply by copying the source code of you application, then
you should think of other ways to distribute the application. Maybe providing software as
a service will be a better choice for you.</p>
</div>
<div class="section" id="making-decompilation-harder">
<h4>4.3.1. Making decompilation harder<a class="headerlink" href="#making-decompilation-harder" title="Permalink to this headline">¶</a></h4>
<p>As already said, there is no reliable way to secure applications from decompilation with the
tools available at the moment. Still, there are some ways to make this process harder. But
harder does not mean less probable. For some of us, the most tempting challenges are the
hardest ones. And we all know that the eventual price in this challenge is very high—the
code that you tried to secure.</p>
<p>Usually the process of decompilation consists of the following steps:</p>
<ol class="arabic simple">
<li><p>Extracting the project’s binary representation of bytecode from standalone executables</p></li>
<li><p>Mapping of a binary representation to bytecode of a specific Python version</p></li>
<li><p>Translation of bytecode to AST</p></li>
<li><p>Re-creation of sources directly from AST</p></li>
</ol>
<p>Providing the exact solutions for deterring developers from such reverse engineering of
standalone executables would be pointless for obvious reasons. So here are only some ideas
for hampering the decompilation process or devaluing its results:</p>
<ul class="simple">
<li><p>Removing any code metadata available at runtime (docstrings) so the eventual results will be a bit less readable.</p></li>
<li><p>Modifying the bytecode values used by the CPython interpreter; so conversion from binary to bytecode and later to AST requires more effort.</p></li>
<li><p>Using a version of CPython sources modified in such a complex way that even if decompiled sources of the application are available, they are useless without decompiling the modified CPython binary.</p></li>
<li><p>Using obfuscation scripts on sources before bundling them into an executable, which will make sources less valuable after the decompilation.</p></li>
</ul>
<p>Such solutions make the development process a lot harder. Some of the preceding ideas
require a very deep understanding of Python runtime, but each one of them is riddled with
many pitfalls and disadvantages. Mostly, they only defer what is anyway inevitable. Once
your trick is broken, it renders all your additional efforts a waste of time and resources.</p>
<p>The only reliable way to not allow your closed code to leak outside of your application is to
not ship it directly to users in any form. And this is only possible if other aspects of your
organization security stay airtight.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="../../index.html" class="btn btn-neutral float-left" title="Code distribution" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sergio Bugallo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>